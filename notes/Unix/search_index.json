[
["index.html", "Learn Unix Statement", " Learn Unix Hui Lin 2017-11-23 Statement This is my learning notes on Unix. It is initially from Sean Kross’ Coursera course “The Unix Workbench.” He has a book with the same name. I will be adding material while I learn. The notes here only includes topics that I was not familiar with, or I want to understand in more detail. Thank you, Sean Kross, for getting me started with learning Unix systematically! "],
["basic-command-line.html", "Chapter 1 Basic Command Line 1.1 Hello Terminal! 1.2 Navigating the Command Line 1.3 Creation and Inspection 1.4 Migration and Destruction", " Chapter 1 Basic Command Line 1.1 Hello Terminal! You type command line commands after the prompt. Every command line command is actually a little computer program, even commands as simple as clear. These commands all tend to have the following structure: [command] [options] [arguments] Options are usually preceded by a hyphen (-) and they tweak the behavior of the command clear will clean up your terminal. echo prints text to your terminal. echo &#39;Hello World!&#39; 1.2 Navigating the Command Line pwd prints the working directory cd .. changes the working directory to the folder above the current working directory cd ~/ goes to your home folder ls command will list files and folders in a directory 1.3 Creation and Inspection mkdir create a new directory (mkdir week1) touch create a blank file (touch newfile.txt) ls -l get long listing of files in a directory drwxr-xr-x 24 happyrabbit staff 816 Oct 25 20:15 anaconda drwxr-xr-x 10 happyrabbit staff 340 Jan 22 2015 nltk_data drwxr-xr-x 10 happyrabbit staff 340 Mar 25 2016 scrapy-newagtalk -rw-r--r-- 1 happyrabbit staff 418 Sep 23 11:47 unknown-0.0-py36_0.tar.bz2 &gt; - There is a row in the resulting table for each file or folder. If the entry in the first column is a **d**, then the row in the table corresponds to a **d**irectory, otherwise the information in the row corresponds to a file. &gt; - The string of characters following the **d** in the case of a directory or following the first **-** in the case of a file represent the _**permissions**_ for that file or directory. &gt; - The columns of this table also show: (1) who created the file (2) the group that the creator of the file belongs to (3) the size of the file (4) the time and date when the file was last modified (5) then finally the name of the file wc view the word count and other information about the file Huis-MacBook-Pro-2:happyrabbit.github.com happyrabbit$ wc Salt.html 73 143 2342 Salt.html The wc command displays the number of lines in a file followed by the number of words and then the number of characters. cat prints file to the console &gt; The cat command is often used to print text files to the terminal, despite the fact that it’s really meant to concatenate files. You can see this concatenation in action in the following example: cat Salt.html archive.html less view multi-page files &gt; you can scroll up and down the file line-by-line using the up and down arrow keys, and if you want to scroll faster you can use the spacebar to go to the next page and the b key to go to the previous page. &gt; - In order to quit less and go back to the prompt press the q key. You can specify the number of lines printed with the -n option followed by the number of lines you’d like to see: head -n 4 Salt.html The tail program works exactly the same way: tail -n 4 Salt.html 1.3.1 More on creating and editing files One easy way to create a file is using output redirection. Output redirection stores text that would be normally printed to the command line in a text file. You can use output redirection by typing the greater-than sign (&gt;) at the end of a command followed by the name of the new file that will contain the output from the proceeding command. Let’s try an example using echo: echo &quot;I am in the file.&quot; &gt; archive.html cat archive.html ## I am in the file. ou can also append text to the end of a file using two greater-than signs (&gt;&gt;). Let’s try this feature out: echo &quot;I have been appended.&quot; &gt;&gt; archive.html cat archive.html ## I am in the file. ## I have been appended. Unfortunately I have unintentionally overwritten what was already contained in archive.html. There’s no undo button in Unix so I’ll have to live with this mistake. Luckly, I am using Github so that I can recover. This is the first of several lessons demonstrating the damage that you should try to avoid inflicting with Unix. Make sure to take extra care when executing commands that can modify or delete a file, a typo in the command can be potentially devastating. Thankfully there are a few strategies for protecting yourself from mistakes, including managing permissions for files, and tracking versions of your files with Git. Finally we should discuss how to edit text files. There are several file editors that are available for your terminal including vim and emacs. Entire books have been written about how to use both of these text editors, and if you’re interested in one of them you should look for resources online about how to use them. The one text editor we will discuss using is called nano. Just like less, nano uses your entire terminal window. Let’s edit todo.txt using nano: nano archive.html Once you’ve started nano you can start editing the text file. The top line of the nano editor shows the file you’re currently working on, and the bottom two lines show a few commands that you can use in nano. The carrot character (^) represents the Control key on your keyboard, so you can for example type Control + O in order to save the changes you’ve made to the text file, or Control + X in order to exit nano and go back to the prompt. 1.3.2 Summary Use mkdir to create new directories. The touch command creates empty files. You can use &gt; to redirect the output of a command into a file. &gt;&gt; will append command output to the end of a file. Print a text file to the command line using cat. Inspect properties of a text file with wc. Peak at the beginning and end of a text file with head and tail. Scroll through a large text file with less. nano is simple text editor. 1.4 Migration and Destruction 1.4.1 moving Make a new directory to store readme.txt mkdir Journal mv readme.txt Journal move Journal directory into the Others folder mv Journal Others 1.4.2 renaming You can use mv to rename files and folders mv readme.txt readme_new.txt 1.4.3 copying cp command copies a file or folder from one location to another cp readme.txt Desktop when copying folders you need to specify the -r option, which is short for recursive. This ensures that the underlying directory structure of the directory you wish to copy remains intact. Let’s try copying my Documents directory into the Desktop directory: cp -r Documents Desktop 1.4.4 deleting A word of extreme caution: in general I don’t recommend deleting files or folders on the command line because there is no undo button on the command line. If you delete a file that is critical to your computer functioning you may cause irreparable damage. I highly recommend moving files or folders to a designated trash folder and then deleting them the way you would normally delete files and folders outside of the command line (The path to the Trash Bin is ~/.Trash on Mac and ~/.local/share/Trash on Ubuntu). If you decide to delete a file or folder on your computer make absolutely sure that the command you’ve typed is correct before you press Enter. If you do delete a file or folder by accident stop using your computer immediately and consult with a computer professional or your IT department so they can try to recover the file. rm readme.txt rm command requires you to use the -r option when deleting entire directories: # create a new folder mkdir RemoveMe # add new files to the folder touch RemoveMe/file1.txt touch RemoveMe/file2.txt touch RemoveMe/file3.txt # remove the folder rm -r RemoveMe "],
["working-with-unix.html", "Chapter 2 Working with Unix 2.1 Self-Help 2.2 Wildcard 2.3 Search", " Chapter 2 Working with Unix 2.1 Self-Help Each of the commands that we’ve discussed so far are thoroughly documented, and you can view their documentation using the man command, where the first argument to man is the command you’re curious about. Let’s take a look at the documentation for ls: man ls LS(1) BSD General Commands Manual LS(1) NAME ls -- list directory contents SYNOPSIS ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...] DESCRIPTION For each operand that names a file of a type other than directory, ls displays its name as well as any requested, associated information. The controls for navigating man pages are the same as they are for less. You can use man pages for quickly searching for an option. For example, if you want to know how to get ls to print a long list. After typing man ls to open the page, type / in order to start a search. Then type the word or phrase that you’re searching for, in this case type in long list and then press Enter. The page jumps to this entry: -l (The lowercase letter ``ell&#39;&#39;.) List in long format. (See below.) If the output is to a terminal, a total sum for all the file sizes is output on a line before the long listing. Press the n key in order to search for the next occurrence of the word, and if you want to go to the previous occurrence type Shift + n. This method of searching also works with less. When you’re finished looking at a man page type q to get back to the prompt. The man command works wonderfully when you know which command you want to look up, but what if you’ve forgotten the name of the command you’re looking for? You can use apropos to search all of the available commands and their descriptions. For example if you forget the name of your favourite command line text editor, you could type apropos editor into the command line which will print a list of results: apropos editor dyld(1) - the dynamic link editor ed(1), red(1) - text editor nano(1) - Nano&#39;s ANOther editor, an enhanced free Pico clone pdisk(8) - Apple partition table editor psed(1) - a stream editor sed(1) - stream editor vim(1) - Vi IMproved, a programmers text editor zshzle(1) - zsh command line editor Mach-O(5) - Mach-O assembler and link editor output Both man and apropos are useful when a search is only a few keystrokes away, but if you’re looking for detailed examples and explanations you’re better off using a search engine if you have access to a web browser. 2.1.1 Summary Use man to look up the documentation for a command. If you can’t think of the name of a command use apropos to search for a word associated with that command. If you have access to a web browser, using a search engine might be better than man or apropos. 2.2 Wildcard A wildcard is a character that represents other characters, much like how joker in a deck of cards can represent other cards in the deck. Wildcards are a subset of metacharacters. The * (“star”) wildcard represents zero or more of any character, and it can be used to match names of files and folders in the command line. For example if I wanted to list all of the files in my Photos directory which have a name that starts with “2017” I could do the following: ls 2017* ls 2017* literally means: list the files that start with “2017” followed by zero or more of any character. As you can imagine using wildcards is a powerful tool for working with groups of files that are similarly named. list the files with names ending in .jpg: ls *.jpg list all files containing specific string: ls *first_day* moved all files that start with “2017-” into the 2017 folder mv 2017-* 2017/ 2.3 Search 2.3.1 Regular Expressions We will show how to through text files using a list of the names of US states. You can download the file here. grep # get state names that contain at least one instance of the letter &quot;x&quot; grep &quot;x&quot; states.txt 2.3.2 Metacharacters Metacharacters are characters that can represent other characters. To take full advantage of all of the metacharacters we should use grep’s cousin egrep. The first metacharacter we should discuss is the . metacharacter. .: represents any character ## search states.txt for the character “i”, ## followed by any character, followed by the character “g” egrep &quot;i.g&quot; states.txt ## Virginia ## Washington ## West Virginia ## Wyoming Besides characters that can represent other characters, there are also metacharacters called quantifiers which allow you to specify the number of times a particular regular expression should appear in a string. One of the most basic quantifiers is “+”: +: represents one or more occurrences of the preceeding expression. &gt; s+as: one or more “s” followed by “as” egrep &quot;s+as&quot; states.txt ## Arkansas ## Kansas *: represents 0 or more occurrences of the preceding expression (remember + represents 1 or more) egrep &quot;s*as&quot; states.txt ## Alaska ## Arkansas ## Kansas ## Massachusetts ## Nebraska ## Texas ## Washington { }: specifies an exact number of occurrences of an expression egrep &quot;s{2}&quot; states.txt ## Massachusetts ## Mississippi ## Missouri ## Tennessee &gt; &quot;`s{2}`&quot; == &quot;`ss`&quot; (exactly two occurrences) egrep &quot;s{2,3}&quot; states.txt &gt; &quot;`s{2,3}`&quot;: state names that have between two and three adjacent occurrences of the letter “s” ( ): creates capturing groups within regular expressions. You can use a capturing group in order to search for multiple occurrences of a string. egrep &quot;(iss){2}&quot; states.txt ## Mississippi &gt; search for the string “iss” occurring twice in a state name We could combine more quantifiers and capturing groups to dream up even more complicated regular expressions: egrep &quot;(i.{2}){3}&quot; states.txt ## Mississippi &gt; three occurrences of an “i” followed by two of any character 2.3.3 Character Sets For the next couple of examples we’re going to need some text data beyond the names of the states. Let’s just create a short text file from the console: touch small.txt echo &quot;abcdefghijklmnopqrstuvwxyz&quot; &gt;&gt; small.txt echo &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; &gt;&gt; small.txt echo &quot;0123456789&quot; &gt;&gt; small.txt echo &quot;aa bb cc&quot; &gt;&gt; small.txt echo &quot;rhythms&quot; &gt;&gt; small.txt echo &quot;xyz&quot; &gt;&gt; small.txt echo &quot;abc&quot; &gt;&gt; small.txt echo &quot;tragedy + time = humor&quot; &gt;&gt; small.txt echo &quot;http://www.jhsph.edu/&quot; &gt;&gt; small.txt echo &quot;#%&amp;-=***=-&amp;%#&quot; &gt;&gt; small.txt In addition to quantifiers there are also regular expressions for describing sets of characters. \\w: all “word” characters \\d: all “number” characters \\s: “space” characters egrep &quot;\\w&quot; small.txt # abcdefghijklmnopqrstuvwxyz # ABCDEFGHIJKLMNOPQRSTUVWXYZ # 0123456789 # aa bb cc # rhythms # xyz # abc # tragedy + time = humor # http://www.jhsph.edu/ \\w metacharacter matches all letters, numbers, and even the underscore character (_) egrep &quot;\\d&quot; small.txt # 0123456789 egrep &quot;\\s&quot; small.txt # aa bb cc # tragedy + time = humor The -v flag (which stands for invert match) makes grep return all of the lines not matched by the regular expression. add -v to the commandis to get the compliment: egrep -v &quot;\\w&quot; small.txt # #%&amp;-=***=-&amp;%# Note that the character sets for regular expressions also have their inverse sets: \\W for non-words \\D for non-digits \\S for non-spaces egrep &quot;\\W&quot; small.txt ## aa bb cc ## tragedy + time = humor ## http://www.jhsph.edu/ ## #%&amp;-=***=-&amp;%# The returned strings all contain non-word characters. Note the difference between the results of using the invert flag -v versus using an inverse set regular expression. In addition to general character sets we can also create specific character sets using square brackets ([ ]) and then including the characters we wish to match in the square brackets. For example the regular expression for the set of vowels is [aeiou]. You can also create a regular expression for the compliment of a set by including a caret (^) in the beginning of a set. For example the regular expression [^aeiou] matches all characters that are not vowels. Let’s test both on small.txt: egrep &quot;[aeiou]&quot; small.txt ## abcdefghijklmnopqrstuvwxyz ## aa bb cc ## abc ## tragedy + time = humor ## http://www.jhsph.edu/ egrep &quot;[^aeiou]&quot; small.txt ## abcdefghijklmnopqrstuvwxyz ## ABCDEFGHIJKLMNOPQRSTUVWXYZ ## 0123456789 ## aa bb cc ## rhythms ## xyz ## abc ## tragedy + time = humor ## http://www.jhsph.edu/ ## #%&amp;-=***=-&amp;%# Every line in the file is printed, because every line contains at least one non-vowel! If you want to specify a range of characters you can use a hyphen (-) inside of the square brackets. For example the regular expression [e-q] matches all of the lowercase letters between “e” and “q” in the alphabet inclusively. Case matters when you’re specifying character sets, so if you wanted to only match uppercase characters you’d need to use [E-Q]. To ignore the case of your match you could combine the character sets with the [e-qE-Q] regex (short for regular expression), or you could use the -i flag with grep to ignore the case. Note that the -i flag will work for any provided regular expression, not just character sets. Let’s take a look at some examples using the regular expressions that we just described: egrep &quot;[e-q]&quot; small.txt ## abcdefghijklmnopqrstuvwxyz ## rhythms ## tragedy + time = humor ## http://www.jhsph.edu/ egrep &quot;[E-Q]&quot; small.txt ## ABCDEFGHIJKLMNOPQRSTUVWXYZ egrep &quot;[e-qE-Q]&quot; small.txt ## abcdefghijklmnopqrstuvwxyz ## ABCDEFGHIJKLMNOPQRSTUVWXYZ ## rhythms ## tragedy + time = humor ## http://www.jhsph.edu/ egrep -i &quot;[E-Q]&quot; small.txt ## abcdefghijklmnopqrstuvwxyz ## ABCDEFGHIJKLMNOPQRSTUVWXYZ ## rhythms ## tragedy + time = humor ## http://www.jhsph.edu/ "]
]
