<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Learn Unix</title>
  <meta name="description" content="This is my notes on Unix">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="Learn Unix" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is my notes on Unix" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Learn Unix" />
  
  <meta name="twitter:description" content="This is my notes on Unix" />
  

<meta name="author" content="Hui Lin">


<meta name="date" content="2018-01-05">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="basic-command-line.html">
<link rel="next" href="use-digitalocean-to-setup-your-shiny-app.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Statement</a></li>
<li class="chapter" data-level="1" data-path="basic-command-line.html"><a href="basic-command-line.html"><i class="fa fa-check"></i><b>1</b> Basic Command Line</a><ul>
<li class="chapter" data-level="1.1" data-path="basic-command-line.html"><a href="basic-command-line.html#hello-terminal"><i class="fa fa-check"></i><b>1.1</b> Hello Terminal!</a></li>
<li class="chapter" data-level="1.2" data-path="basic-command-line.html"><a href="basic-command-line.html#navigating-the-command-line"><i class="fa fa-check"></i><b>1.2</b> Navigating the Command Line</a></li>
<li class="chapter" data-level="1.3" data-path="basic-command-line.html"><a href="basic-command-line.html#creation-and-inspection"><i class="fa fa-check"></i><b>1.3</b> Creation and Inspection</a><ul>
<li class="chapter" data-level="1.3.1" data-path="basic-command-line.html"><a href="basic-command-line.html#more-on-creating-and-editing-files"><i class="fa fa-check"></i><b>1.3.1</b> More on creating and editing files</a></li>
<li class="chapter" data-level="1.3.2" data-path="basic-command-line.html"><a href="basic-command-line.html#summary"><i class="fa fa-check"></i><b>1.3.2</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="basic-command-line.html"><a href="basic-command-line.html#migration-and-destruction"><i class="fa fa-check"></i><b>1.4</b> Migration and Destruction</a><ul>
<li class="chapter" data-level="1.4.1" data-path="basic-command-line.html"><a href="basic-command-line.html#moving"><i class="fa fa-check"></i><b>1.4.1</b> moving</a></li>
<li class="chapter" data-level="1.4.2" data-path="basic-command-line.html"><a href="basic-command-line.html#renaming"><i class="fa fa-check"></i><b>1.4.2</b> renaming</a></li>
<li class="chapter" data-level="1.4.3" data-path="basic-command-line.html"><a href="basic-command-line.html#copying"><i class="fa fa-check"></i><b>1.4.3</b> copying</a></li>
<li class="chapter" data-level="1.4.4" data-path="basic-command-line.html"><a href="basic-command-line.html#deleting"><i class="fa fa-check"></i><b>1.4.4</b> deleting</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="working-with-unix.html"><a href="working-with-unix.html"><i class="fa fa-check"></i><b>2</b> Working with Unix</a><ul>
<li class="chapter" data-level="2.1" data-path="working-with-unix.html"><a href="working-with-unix.html#self-help"><i class="fa fa-check"></i><b>2.1</b> Self-Help</a><ul>
<li class="chapter" data-level="2.1.1" data-path="working-with-unix.html"><a href="working-with-unix.html#summary-1"><i class="fa fa-check"></i><b>2.1.1</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="working-with-unix.html"><a href="working-with-unix.html#wildcard"><i class="fa fa-check"></i><b>2.2</b> Wildcard</a></li>
<li class="chapter" data-level="2.3" data-path="working-with-unix.html"><a href="working-with-unix.html#regular-expression"><i class="fa fa-check"></i><b>2.3</b> Regular Expression</a><ul>
<li class="chapter" data-level="2.3.1" data-path="working-with-unix.html"><a href="working-with-unix.html#metacharacters"><i class="fa fa-check"></i><b>2.3.1</b> Metacharacters</a></li>
<li class="chapter" data-level="2.3.2" data-path="working-with-unix.html"><a href="working-with-unix.html#character-sets"><i class="fa fa-check"></i><b>2.3.2</b> Character Sets</a></li>
<li class="chapter" data-level="2.3.3" data-path="working-with-unix.html"><a href="working-with-unix.html#escaping-anchors-odds-and-ends"><i class="fa fa-check"></i><b>2.3.3</b> Escaping, Anchors, Odds and Ends</a></li>
<li class="chapter" data-level="2.3.4" data-path="working-with-unix.html"><a href="working-with-unix.html#find"><i class="fa fa-check"></i><b>2.3.4</b> Find</a></li>
<li class="chapter" data-level="2.3.5" data-path="working-with-unix.html"><a href="working-with-unix.html#summary-2"><i class="fa fa-check"></i><b>2.3.5</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="working-with-unix.html"><a href="working-with-unix.html#configure"><i class="fa fa-check"></i><b>2.4</b> Configure</a><ul>
<li class="chapter" data-level="2.4.1" data-path="working-with-unix.html"><a href="working-with-unix.html#history"><i class="fa fa-check"></i><b>2.4.1</b> History</a></li>
<li class="chapter" data-level="2.4.2" data-path="working-with-unix.html"><a href="working-with-unix.html#customizing-bash"><i class="fa fa-check"></i><b>2.4.2</b> Customizing Bash</a></li>
<li class="chapter" data-level="2.4.3" data-path="working-with-unix.html"><a href="working-with-unix.html#summary-3"><i class="fa fa-check"></i><b>2.4.3</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="working-with-unix.html"><a href="working-with-unix.html#differentiate"><i class="fa fa-check"></i><b>2.5</b> Differentiate</a><ul>
<li class="chapter" data-level="2.5.1" data-path="working-with-unix.html"><a href="working-with-unix.html#summary-4"><i class="fa fa-check"></i><b>2.5.1</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="working-with-unix.html"><a href="working-with-unix.html#pipes"><i class="fa fa-check"></i><b>2.6</b> Pipes</a><ul>
<li class="chapter" data-level="2.6.1" data-path="working-with-unix.html"><a href="working-with-unix.html#summary-5"><i class="fa fa-check"></i><b>2.6.1</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="working-with-unix.html"><a href="working-with-unix.html#make"><i class="fa fa-check"></i><b>2.7</b> Make</a><ul>
<li class="chapter" data-level="2.7.1" data-path="working-with-unix.html"><a href="working-with-unix.html#summary-6"><i class="fa fa-check"></i><b>2.7.1</b> Summary</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="use-digitalocean-to-setup-your-shiny-app.html"><a href="use-digitalocean-to-setup-your-shiny-app.html"><i class="fa fa-check"></i><b>3</b> Use DigitalOcean to setup your Shiny App</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Learn Unix</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="working-with-unix" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> Working with Unix</h1>
<div id="self-help" class="section level2">
<h2><span class="header-section-number">2.1</span> Self-Help</h2>
<p>Each of the commands that we’ve discussed so far are thoroughly documented, and you can view their documentation using the <code>man</code> command, where the first argument to man is the command you’re curious about. Let’s take a look at the documentation for <code>ls</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">man</span> ls</code></pre></div>
<pre class="pre"><code>LS(1)                     BSD General Commands Manual                    LS(1)
NAME
     ls -- list directory contents
SYNOPSIS
     ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]
DESCRIPTION
     For each operand that names a file of a type other than directory, ls
     displays its name as well as any requested, associated information.  </code></pre>
<p>The controls for navigating <code>man</code> pages are the same as they are for less. You can use <code>man</code> pages for quickly searching for an option. For example, if you want to know how to get <code>ls</code> to print a long list. After typing <code>man ls</code> to open the page, <strong>type <code>/</code> in order to start a search</strong>. Then type the word or phrase that you’re searching for, in this case type in long list and then press Enter. The page jumps to this entry:</p>
<pre class="pre"><code>-l      (The lowercase letter ``ell&#39;&#39;.)  List in long format.  (See
             below.)  If the output is to a terminal, a total sum for all the
             file sizes is output on a line before the long listing.</code></pre>
<p>Press the <strong><code>n</code> key in order to search for the next occurrence</strong> of the word, and if you want to <strong>go to the previous occurrence type <code>Shift + n</code></strong>. This method of searching also works with less. When you’re finished looking at a <code>man</code> page <strong>type <code>q</code> to get back to the prompt</strong>.</p>
<p>The <code>man</code> command works wonderfully when you know which command you want to look up, but what if you’ve forgotten the name of the command you’re looking for? You can use <code>apropos</code> to search all of the available commands and their descriptions. For example if you forget the name of your favourite command line text editor, you could type <code>apropos editor</code> into the command line which will print a list of results:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">apropos</span> editor</code></pre></div>
<pre class="pre"><code>dyld(1)                  - the dynamic link editor
ed(1), red(1)            - text editor
nano(1)                  - Nano&#39;s ANOther editor, an enhanced free Pico clone
pdisk(8)                 - Apple partition table editor
psed(1)                  - a stream editor
sed(1)                   - stream editor
vim(1)                   - Vi IMproved, a programmers text editor
zshzle(1)                - zsh command line editor
Mach-O(5)                - Mach-O assembler and link editor output</code></pre>
<p>Both <code>man</code> and <code>apropos</code> are useful when a search is only a few keystrokes away, but if you’re looking for detailed examples and explanations you’re better off using a search engine if you have access to a web browser.</p>
<div id="summary-1" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Summary</h3>
<ul>
<li>Use <code>man</code> to look up the documentation for a command.</li>
<li>If you can’t think of the name of a command use <code>apropos</code> to search for a word associated with that command.</li>
<li>If you have access to a web browser, using a search engine might be better than <code>man</code> or <code>apropos</code>.</li>
</ul>
</div>
</div>
<div id="wildcard" class="section level2">
<h2><span class="header-section-number">2.2</span> Wildcard</h2>
<p>A <strong>wildcard</strong> is a character that represents other characters, much like how joker in a deck of cards can represent other cards in the deck. Wildcards are a subset of metacharacters. The <code>*</code> (“star”) wildcard represents <strong>zero or more of any character</strong>, and it can be used to match names of files and folders in the command line. For example if I wanted to list all of the files in my Photos directory which have a name that starts with “2017” I could do the following:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span> 2017*</code></pre></div>
<p><code>ls 2017*</code> literally means: list the files that start with “2017” followed by zero or more of any character. As you can imagine using wildcards is a powerful tool for working with groups of files that are similarly named.</p>
<ul>
<li>list the files with names ending in <code>.jpg</code>:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span> *.jpg</code></pre></div>
<ul>
<li>list all files containing specific string:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span> *first_day*</code></pre></div>
<ul>
<li>moved all files that start with “<code>2017-</code>” into the 2017 folder</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">mv</span> 2017-* 2017/</code></pre></div>
</div>
<div id="regular-expression" class="section level2">
<h2><span class="header-section-number">2.3</span> Regular Expression</h2>
<p>Regular expressions are a language used for parsing and manipulating text. You can use them to perform complex search-and-replace operations, and to validate that text data is well-formed. Most programming languages, as well as in many scripting languages, editors, applications, databases and command-line tools, all include regular expressions. Here we will focus Unix shell. One important thing to note is that the syntax and pattern-matching operations can be different for different languages.</p>
<p>We will show how to through text files using a list of the names of US states. You can download the file <a href="http://seankross.com/notes/states.txt">here</a>.</p>
<ul>
<li><code>grep</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># get state names that contain at least one instance of the letter &quot;x&quot;</span>
<span class="kw">grep</span> <span class="st">&quot;x&quot;</span> states.txt</code></pre></div>
<div id="metacharacters" class="section level3">
<h3><span class="header-section-number">2.3.1</span> Metacharacters</h3>
<p><strong>Metacharacters</strong> are <strong>characters that can represent other characters</strong>. To take full advantage of all of the metacharacters we should use <code>grep</code>’s cousin <code>egrep</code>. The first metacharacter we should discuss is the <code>.</code> metacharacter.</p>
<ul>
<li><code>.</code>: represents any character</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">## search states.txt for the character “i”, </span>
<span class="co">## followed by any character, followed by the character “g”</span>
<span class="kw">egrep</span> <span class="st">&quot;i.g&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## Virginia
## Washington
## West Virginia
## Wyoming</code></pre>
<p>Besides characters that can represent other characters, there are also metacharacters called <strong>quantifiers</strong> which allow you to <strong>specify the number of times a particular regular expression</strong> should appear in a string. One of the most basic quantifiers is “<code>+</code>”:</p>
<ul>
<li><code>+</code>: represents one or more occurrences of the preceeding expression. &gt; <code>s+as</code>: one or more “<code>s</code>” followed by “<code>as</code>”</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;s+as&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## Arkansas
## Kansas</code></pre>
<ul>
<li><code>*</code>: represents 0 or more occurrences of the preceding expression (remember <code>+</code> represents 1 or more)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;s*as&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## Alaska
## Arkansas
## Kansas
## Massachusetts
## Nebraska
## Texas
## Washington</code></pre>
<ul>
<li><code>{ }</code>: specifies an exact number of occurrences of an expression</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;s{2}&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## Massachusetts
## Mississippi
## Missouri
## Tennessee</code></pre>
<pre><code>&gt; &quot;`s{2}`&quot; == &quot;`ss`&quot; (exactly two occurrences)</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;s{2,3}&quot;</span> states.txt</code></pre></div>
<pre><code>&gt; &quot;`s{2,3}`&quot;: state names that have between two and three adjacent occurrences of the letter “s” </code></pre>
<ul>
<li><code>( )</code>: creates capturing groups within regular expressions. You can use a capturing group in order to search for multiple occurrences of a string.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;(iss){2}&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## Mississippi</code></pre>
<pre><code>&gt; search for the string “iss” occurring twice in a state name</code></pre>
<p>We could combine more quantifiers and capturing groups to dream up even more complicated regular expressions:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;(i.{2}){3}&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## Mississippi</code></pre>
<pre><code>&gt; three occurrences of an “i” followed by two of any character</code></pre>
</div>
<div id="character-sets" class="section level3">
<h3><span class="header-section-number">2.3.2</span> Character Sets</h3>
<p>For the next couple of examples we’re going to need some text data beyond the names of the states. Let’s just create a short text file from the console:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">touch</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;0123456789&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;aa bb cc&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;rhythms&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;xyz&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;abc&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;tragedy + time = humor&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;http://www.jhsph.edu/&quot;</span> <span class="kw">&gt;&gt;</span> small.txt
<span class="kw">echo</span> <span class="st">&quot;#%&amp;-=***=-&amp;%#&quot;</span> <span class="kw">&gt;&gt;</span> small.txt</code></pre></div>
<p>In addition to quantifiers there are also regular expressions for describing sets of characters.</p>
<ul>
<li><code>\w</code>: all “word” characters</li>
<li><code>\d</code>: all “number” characters</li>
<li><code>\s</code>: “space” characters</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;\w&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code># abcdefghijklmnopqrstuvwxyz
# ABCDEFGHIJKLMNOPQRSTUVWXYZ
# 0123456789
# aa bb cc
# rhythms
# xyz
# abc
# tragedy + time = humor
# http://www.jhsph.edu/</code></pre>
<blockquote>
<p><code>\w</code> metacharacter matches all letters, numbers, and even the underscore character (_)</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;\d&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code># 0123456789</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;\s&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code># aa bb cc
# tragedy + time = humor</code></pre>
<p>The <code>-v</code> flag (which stands for invert match) makes <code>grep</code> return all of the lines not matched by the regular expression.</p>
<ul>
<li>add <code>-v</code> to the commandis to get the compliment:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> -v <span class="st">&quot;\w&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code># #%&amp;-=***=-&amp;%#</code></pre>
<p>Note that the character sets for regular expressions also have their inverse sets:</p>
<ul>
<li><code>\W</code> for non-words</li>
<li><code>\D</code> for non-digits</li>
<li><code>\S</code> for non-spaces</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;\W&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## aa bb cc
## tragedy + time = humor
## http://www.jhsph.edu/
## #%&amp;-=***=-&amp;%#</code></pre>
<p>The returned strings all contain non-word characters. Note the difference between the results of using the invert flag <code>-v</code> versus using <strong>an inverse set regular expression</strong>.</p>
<p>In addition to general character sets we can also create specific character sets using square brackets (<code>[ ]</code>) and then including the characters we wish to match in the square brackets. For example the regular expression for the set of vowels is <code>[aeiou]</code>. You can also create a regular expression for the <strong>compliment of a set</strong> by including a caret (<code>^</code>) in the beginning of a set. For example the regular expression <code>[^aeiou]</code> matches all characters that are not vowels. Let’s test both on small.txt:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;[aeiou]&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## abcdefghijklmnopqrstuvwxyz
## aa bb cc
## abc
## tragedy + time = humor
## http://www.jhsph.edu/</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;[^aeiou]&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## abcdefghijklmnopqrstuvwxyz
## ABCDEFGHIJKLMNOPQRSTUVWXYZ
## 0123456789
## aa bb cc
## rhythms
## xyz
## abc
## tragedy + time = humor
## http://www.jhsph.edu/
## #%&amp;-=***=-&amp;%#</code></pre>
<p>Every line in the file is printed, because every line contains at least one non-vowel!</p>
<p>If you want to specify a range of characters you can use a hyphen (<code>-</code>) inside of the square brackets. For example the regular expression <code>[e-q]</code> matches all of the lowercase letters between “e” and “q” in the alphabet inclusively. Case matters when you’re specifying character sets, so if you wanted to only match uppercase characters you’d need to use <code>[E-Q]</code>. To ignore the case of your match you could combine the character sets with the <code>[e-qE-Q]</code> regex (short for regular expression), or you could use the <code>-i</code> flag with grep to ignore the case. Note that the <code>-i</code> flag will work for any provided regular expression, not just character sets. Let’s take a look at some examples using the regular expressions that we just described:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;[e-q]&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## abcdefghijklmnopqrstuvwxyz
## rhythms
## tragedy + time = humor
## http://www.jhsph.edu/</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;[E-Q]&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;[e-qE-Q]&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## abcdefghijklmnopqrstuvwxyz
## ABCDEFGHIJKLMNOPQRSTUVWXYZ
## rhythms
## tragedy + time = humor
## http://www.jhsph.edu/</code></pre>
<pre class="hash"><code>egrep -i &quot;[E-Q]&quot; small.txt</code></pre>
<pre class="pre"><code>## abcdefghijklmnopqrstuvwxyz
## ABCDEFGHIJKLMNOPQRSTUVWXYZ
## rhythms
## tragedy + time = humor
## http://www.jhsph.edu/</code></pre>
</div>
<div id="escaping-anchors-odds-and-ends" class="section level3">
<h3><span class="header-section-number">2.3.3</span> Escaping, Anchors, Odds and Ends</h3>
<p>How to search for certain punctuation marks in text considering that those same symbols are used as metacharacters? For example, how would you find a plus sign (<code>+</code>) in a line of text since the plus sign is also a metacharacter? The answer is simply using a backslash (<code>\</code>) before the plus sign in a regex, in order to “escape” the metacharacter functionality. Here are a few examples:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;\+&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## tragedy + time = humor</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;\.&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## http://www.jhsph.edu/</code></pre>
<p>There are three more metacharacters that we should discuss, and two of them come as a pair:</p>
<ul>
<li>caret (<code>^</code>), which represents the start of a line</li>
<li>dollar sign (<code>$</code>) which represents the end of line</li>
</ul>
<blockquote>
<p>These “anchor characters” only match the beginning and ends of lines when coupled with other regular expressions.</p>
</blockquote>
<p>The following command will search for all strings that begin with “A” :</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;^A&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## ABCDEFGHIJKLMNOPQRSTUVWXYZ</code></pre>
<p>There’s a mnemonic for remembering which metacharacter to use for each anchor:</p>
<blockquote>
<p>“First you get the power, then you get the money.”</p>
</blockquote>
<ul>
<li><strong>pipe character “<code>|</code>”</strong></li>
</ul>
<p>Now let’s talk about “or” metacharacter (<code>|</code>), which is also called the “<strong>pipe</strong>” character. This metacharacter allows you to match <strong>either</strong> the regex on the right or on the left side of the pipe. Let’s take a look at a small example:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;A|bc&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## abcdefghijklmnopqrstuvwxyz
## ABCDEFGHIJKLMNOPQRSTUVWXYZ
## abc</code></pre>
<p>You can also use multiple pipe characters to, for example, search for lines that contain the words for all of the cardinal directions:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;North|South|East|West&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## North Carolina
## North Dakota
## South Carolina
## South Dakota
## West Virginia</code></pre>
<p>Just two more notes on <code>grep</code>: you can display the line number that a match occurs on using the <code>-n</code> flag:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> -n <span class="st">&quot;t$&quot;</span> states.txt</code></pre></div>
<pre class="pre"><code>## 7:Connecticut
## 45:Vermont</code></pre>
<p>And you can also grep multiple files at once by providing multiple file arguments:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;New&quot;</span> states.txt canada.txt</code></pre></div>
<pre class="pre"><code>## states.txt:New Hampshire
## states.txt:New Jersey
## states.txt:New Mexico
## states.txt:New York
## canada.txt:Newfoundland and Labrador
## canada.txt:New Brunswick</code></pre>
<p>If you wanted to search for all strings that begin with a vowel and end with character {a, b, c}:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">egrep</span> <span class="st">&quot;^[aeiou]{1}.+[a-c]{1}$&quot;</span> small.txt</code></pre></div>
<pre class="pre"><code>## aa bb cc
## abc</code></pre>
<p><strong>Table of Metacharacters</strong></p>
<table>
<thead>
<tr class="header">
<th>Metacharacter</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>.</code></td>
<td>Any Character</td>
</tr>
<tr class="even">
<td><code>\w</code></td>
<td>A Word</td>
</tr>
<tr class="odd">
<td><code>\W</code></td>
<td>Not a Word</td>
</tr>
<tr class="even">
<td><code>\d</code></td>
<td>A Digit</td>
</tr>
<tr class="odd">
<td><code>\D</code></td>
<td>Not a Digit</td>
</tr>
<tr class="even">
<td><code>\s</code></td>
<td>Whitespace</td>
</tr>
<tr class="odd">
<td><code>\S</code></td>
<td>Not Whitespace</td>
</tr>
<tr class="even">
<td>[def]</td>
<td>A Set of Characters</td>
</tr>
<tr class="odd">
<td>[^def]</td>
<td>Negation of Set</td>
</tr>
<tr class="even">
<td>[e-q]</td>
<td>A Range of Characters</td>
</tr>
<tr class="odd">
<td>^</td>
<td>Beginning of String</td>
</tr>
<tr class="even">
<td>$</td>
<td>End of String</td>
</tr>
<tr class="odd">
<td><code>\n</code></td>
<td>Newline</td>
</tr>
<tr class="even">
<td>+</td>
<td>One or More of Previous</td>
</tr>
<tr class="odd">
<td>*</td>
<td>Zero or More of Previous</td>
</tr>
<tr class="even">
<td>?</td>
<td>Zero or One of Previous</td>
</tr>
<tr class="odd">
<td>|</td>
<td>Either the Previous or the Following</td>
</tr>
<tr class="even">
<td>{6}</td>
<td>Exactly 6 of Previous</td>
</tr>
<tr class="odd">
<td>{4, 6}</td>
<td>Between 4 and 6 or Previous</td>
</tr>
<tr class="even">
<td>{4, }</td>
<td>More than 4 of Previous</td>
</tr>
</tbody>
</table>
<p>If you want to experiment with writing regular expressions before you use them I highly recommend playing around with <a href="http://regexr.com/" class="uri">http://regexr.com/</a>.</p>
</div>
<div id="find" class="section level3">
<h3><span class="header-section-number">2.3.4</span> Find</h3>
<p>If you want to find the location of a file or the location of a group of files you can use the <code>find</code> command. This command has a specific structure where the first argument is the directory where you want to begin the search, and all directories contained within that directory will also be searched. The first argument is then followed by a flag that describes the method you want to use to search. In this case we’ll only be searching for a file by its name, so we’ll use the <code>-name</code> flag. The <code>-name</code> flag itself then takes an argument, the name of the file that you’re looking for. Let’s go back to the home directory and look for some files from there:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">find</span> . -name <span class="st">&quot;small.txt&quot;</span></code></pre></div>
<pre class="pre"><code>## ./Documents/GitHub/Unix/files/small.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">find</span> ./Documents -name <span class="st">&quot;*loop.sh&quot;</span></code></pre></div>
<pre class="pre"><code>## ./Documents/GitHub/Unix/files/foreverloop.sh
## ./Documents/GitHub/Unix/files/whileloop.sh
## ./Documents/GitHub/Unix/files/forloop.sh
## ./Documents/GitHub/Unix/files/ifloop.sh</code></pre>
</div>
<div id="summary-2" class="section level3">
<h3><span class="header-section-number">2.3.5</span> Summary</h3>
<ul>
<li><code>grep</code> and <code>egrep</code> can be used along with regular expressions to search for patterns of text in a file.</li>
<li>Metacharacters are used in regular expressions to describe patterns of characters.</li>
<li><code>find</code> can be used to search for the names of files in a directory.</li>
</ul>
</div>
</div>
<div id="configure" class="section level2">
<h2><span class="header-section-number">2.4</span> Configure</h2>
<div id="history" class="section level3">
<h3><span class="header-section-number">2.4.1</span> History</h3>
<p>Near the start of this book we discussed how you can browse the commands that you recently entered into the prompt using the Up and Down arrow keys. Bash keeps track of all of your recent commands, and you can browse your command history two different ways. The commands that we’ve used since opening our terminal can be accessed via the history command. Let’s try it out:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">history</span></code></pre></div>
<p>Whenever we close a terminal our recent commands are written to the <code>~/.bash_history</code> file. Let’s a take a look at the beginning of this file:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">head</span> -n 5 ~/.bash_history</code></pre></div>
<p>Searching your <code>~/.bash_history</code> file can be particularly useful if you’re trying to recall a command you’ve used in the past. The <code>~/.bash_history</code> file is just a regular text file, so you can search it with <code>grep</code>. Here’s a simple example:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">grep</span> <span class="st">&quot;canada&quot;</span> ~/.bash_history</code></pre></div>
<pre class="pre"><code>## egrep &quot;New&quot; states.txt canada.txt</code></pre>
</div>
<div id="customizing-bash" class="section level3">
<h3><span class="header-section-number">2.4.2</span> Customizing Bash</h3>
<p>Besides <code>~/.bash_history</code>, another text file in our home directory that we should be aware of is <code>~/.bash_profile</code>. The <code>~/.bash_profile</code> is a list of Unix commands that are run every time we open our terminal, usually with a different command on every line. One of the most common commands used in a <code>~/.bash_profile</code> is the alias command, which creates a shorter name for a command. Let’s take a look at a <code>~/.bash_profile</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">alias</span> docs=<span class="st">&#39;cd ~/Documents&#39;</span>
<span class="kw">alias</span> edbp=<span class="st">&#39;nano ~/.bash_profile&#39;</span></code></pre></div>
<p>The first alias creates a new command <code>docs</code>. Now entering <code>docs</code> into the command line is the equivalent of entering <code>cd ~/Documents</code> into the comamnd line. let’s edit our <code>~/.bash_profile</code> with <code>nano</code>. If there’s anything in your <code>~/.bash_profile</code> already then start adding lines at the end of the file. Add the line alias <code>docs='cd ~/Documents'</code>, then save the file and quit <code>nano</code>. In order to make the changes to our <code>~/.bash_profile</code> take effect we need to run <code>source ~/.bash_profile</code> in the console:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">source</span> ~/.bash_profile</code></pre></div>
<p>Now let’s try using docs:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">docs</span>
<span class="kw">pwd</span></code></pre></div>
<pre class="pre"><code>## /Users/sean/Documents</code></pre>
<p>It works! Setting different aliases allows you to save time if there are long commands that use often. In the example <code>~/.bash_profile</code> above, the second line, <code>alias edbp='nano ~/.bash_profile'</code> creates the command <code>edbp</code> (edit bash profile) so that you can quickly add aliases. Try adding it to your <code>~/.bash_profile</code> and take your new command for a spin!</p>
<p>There are a few other details about the <code>~/.bash_profile</code> that are important when you’re writing software which we’ll discuss in the Bash Programming chapter.</p>
</div>
<div id="summary-3" class="section level3">
<h3><span class="header-section-number">2.4.3</span> Summary</h3>
<ul>
<li><code>history</code> displays what commands we’ve entered into the console since opening our current terminal.</li>
<li>The <code>~/.bash_history</code> file lists commands we’ve used in the past. <code>alias</code> creates a command that can be used as a substitute for a longer command that we use often.</li>
<li>The <code>~/.bash_profile</code> is a text file that is run every time we start a shell, and it’s the best place to assign aliases.</li>
</ul>
</div>
</div>
<div id="differentiate" class="section level2">
<h2><span class="header-section-number">2.5</span> Differentiate</h2>
<p>It’s important to be able to examine differences between files. First let’s make two small simple text files in the <code>Documents/GitHub/Unix/files/</code> directory.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cd</span> ./Documents/GitHub/Unix/files/
<span class="kw">head</span> -n 4 small.txt <span class="kw">&gt;</span> four.txt
<span class="kw">head</span> -n 6 small.txt <span class="kw">&gt;</span> six.txt</code></pre></div>
<p>If we want to look at which lines in these files are different we can use the <code>diff</code> command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">diff</span> four.txt six.txt</code></pre></div>
<pre class="pre"><code>## 4a5,6
## &gt; rhythms
## &gt; xyz</code></pre>
<p>Only the differing lines are printed to the console. We could also compare differing lines in a side-by-side comparison using <code>sdiff</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sdiff</span> four.txt six.txt</code></pre></div>
<pre class="pre"><code>## abcdefghijklmnopqrstuvwxyz       abcdefghijklmnopqrstuvwxyz
## ABCDEFGHIJKLMNOPQRSTUVWXYZ       ABCDEFGHIJKLMNOPQRSTUVWXYZ
## 0123456789                       0123456789
## aa bb cc                         aa bb cc
##                                &gt; rhythms
##                                &gt; xyz</code></pre>
<p>In a common situation you might be sent a file, or you might download a file from the internet that comes with code known as a <code>checksum</code> or a <code>hash</code>. Hashing programs generate a unique code based on the contents of a file.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> People distribute hashes with files so that we can be sure that the file we think we’ve downloaded is the genuine file. <strong>One way we can prevent malicious individuals from sending us harmful files is to check to make sure the computed hash matches the provided hash.</strong> There are a few commonly used file hashes but we’ll talk about two called <code>MD5</code> and <code>SHA-1</code>.</p>
<p>Since <strong>hashes are generated based on file contents</strong>, then two identical files should have the same hash. Let’s test this my making a copy of states.txt.</p>
<pre class="pre"><code>cp small.txt small_copy.txt</code></pre>
<p>To compute the MD5 hash of a file we can use the <code>md5</code> command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">md5</span> small.txt</code></pre></div>
<pre class="pre"><code>## MD5 (small.txt) = 45ea2935d11b9d6057b8c8f901a37822</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">md5</span> small_copy.txt</code></pre></div>
<pre class="pre"><code>## MD5 (small_copy.txt) = 45ea2935d11b9d6057b8c8f901a37822</code></pre>
<p>As we expected they are the same! We can compute the <code>SHA-1</code> hash using the <code>shasum</code> command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">shasum</span> small.txt</code></pre></div>
<pre class="pre"><code>## 542a81f4556b79a0e1f8b6639657609437835fad  small.txtshasum states_copy.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">shasum</span> small_copy.txt</code></pre></div>
<pre class="pre"><code>## 542a81f4556b79a0e1f8b6639657609437835fad  small_copy.txt</code></pre>
<p>Once again, both copies produce the same hash. Let’s make a change to one of the files, just to illustrate the fact that the hash changes if file contents are different:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">head</span> -n 5 small_copy.txt <span class="kw">&gt;</span> small_copy.txt
<span class="kw">shasum</span> small_copy.txt</code></pre></div>
<pre class="pre"><code>## da39a3ee5e6b4b0d3255bfef95601890afd80709  small_copy.txt</code></pre>
<div id="summary-4" class="section level3">
<h3><span class="header-section-number">2.5.1</span> Summary</h3>
<p>The <code>md5</code> and <code>shasum</code> commands use different algorithms to create codes (called hashes or checksums) that are unique to the contents of a file. These hashes can be used to ensure that a file is genuine.</p>
</div>
</div>
<div id="pipes" class="section level2">
<h2><span class="header-section-number">2.6</span> Pipes</h2>
<p>Pipe (<code>|</code>) is one of the most powerful features of the command line. <strong>It allows us to take the output of a command, which would normally be printed to the console, and use it as the input to another command.</strong> It’s like fitting an actual pipe between the end of one program and connecting it to the beginning of another program! Let’s take a look at a basic example. We know the cat command takes the contents of a text file and prints it to the console:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cd</span> Documents/GitHub/Unix/files/
<span class="kw">cat</span> canada.txt</code></pre></div>
<pre class="pre"><code>## Nunavut
## Quebec
## Northwest Territories
## Ontario
## British Columbia
## Alberta
## Saskatchewan
## Manitoba
## Yukon
## Newfoundland and Labrador
## New Brunswick
## Nova Scotia
## Prince Edward Island</code></pre>
<p>This output from cat canada.txt will go into our pipe, and we will look at the first few lines of a file:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cat</span> canada.txt <span class="kw">|</span> <span class="kw">head</span> -n 5</code></pre></div>
<pre class="pre"><code>## Nunavut
## Quebec
## Northwest Territories
## Ontario
## British Columbia</code></pre>
<p>Notice that this is the same result we would get from head -n 5 canada.txt, we just used cat to illustrate how the pipe works. The general syntax of the pipe is <code>[program that produces output] | [program uses pipe output as input instead of a file]</code>.</p>
<p>A more common and useful example where we could use the pipe is answering the question: “How many US states end in a vowel?” We could use <code>grep</code> and regular expressions to list all of the state names that end with a vowel, then we could use <code>wc</code> to count all of the matching state names:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">grep</span> <span class="st">&quot;[aeiou]$&quot;</span> states.txt <span class="kw">|</span> <span class="kw">wc</span> -l</code></pre></div>
<pre class="pre"><code>## 32</code></pre>
<p>The pipe can also be used multiple times in one command in order to take the output from one piped command and use it as the input to yet another program! For example we could use three pipes with <code>ls</code>, <code>grep</code>, and <code>less</code> so that we could scroll through the files in the current directory that were created in October:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span> -al <span class="kw">|</span> <span class="kw">grep</span> <span class="st">&quot;Oct&quot;</span> <span class="kw">|</span> <span class="kw">less</span></code></pre></div>
<pre class="pre"><code>## drwxr-xr-x   2 happyrabbit  staff    64 Oct 31 17:00 .ipynb_checkpoints
## -rw-r--r--   1 happyrabbit  staff    74 Oct 29 16:28 four.txt
## -rw-r--r--@  1 happyrabbit  staff   106 Oct 29 20:19 iago.txt
## -rw-r--r--   1 happyrabbit  staff    82 Oct 29 22:39 math.sh
## -rw-r--r--   1 happyrabbit  staff    86 Oct 29 16:28 six.txt
## -rw-r--r--   1 happyrabbit  staff   149 Oct 28 07:46 small.txt
## -rw-r--r--   1 happyrabbit  staff     0 Oct 29 16:54 small_copy.txt
## -rw-r--r--@  1 happyrabbit  staff   472 Oct 13 18:19 states.txt
## -rw-r--r--   1 happyrabbit  staff   944 Oct 29 20:32 states2.txt
## -rw-r--r--   1 happyrabbit  staff     0 Oct 30 06:53 var_exe1.sh
## -rw-r--r--   1 happyrabbit  staff   111 Oct 30 06:51 vars.sh</code></pre>
<p>Remember you can use the <code>Q</code> key to quit <code>less</code> and return to the prompt.</p>
<div id="summary-5" class="section level3">
<h3><span class="header-section-number">2.6.1</span> Summary</h3>
<p>The pipe (<code>|</code>) takes the output of the program on its left side and directs the output to be the input for the program on its right side.</p>
</div>
</div>
<div id="make" class="section level2">
<h2><span class="header-section-number">2.7</span> Make</h2>
<p>Once upon a time there were no web browsers, file browsers, start menus, or search bars. When somebody booted up a computer all they got was a shell prompt, and all of the work they did started from that prompt. Back then there was always the problem of how software should be installed. The <code>make</code> program is the best attempt at solving this problem and still in wide use today. The guiding design goal of <code>make</code> is that in order to install some new piece of software one would:</p>
<ol style="list-style-type: decimal">
<li>Download all of the files required for installation into a directory.</li>
<li><code>cd</code> into that directory.</li>
<li>Run <code>make</code>.</li>
</ol>
<p>This is accomplished by specifying a file called <code>makefile</code>, which <strong>describes the relationships between different files and programs</strong>. In addition to installing programs, <code>make</code> is also useful for creating documents automatically. Let’s build up a <code>makefile</code> that creates a <code>readme.txt</code> file which is automatically populated with some information about our current directory.</p>
<p>Let’s start by creating a very basic <code>makefile</code> with <code>nano</code>:</p>
<pre class="pre"><code>cd Documents/GitHub/Unix/Journal/
nano makefile
draft_journal_entry.txt:
  touch draft_journal_entry.txt</code></pre>
<p>The simple <code>makefile</code> above shows a rule that has the following general format:</p>
<pre class="pre"><code>[target]: [dependencies...]
  [commands...]</code></pre>
<p>In the simple example, <code>draft_journal_entry.txt</code> is the target, a file which is created as the result of the command(s).</p>
<p><strong>It’s very important to note that any commands under a target must be indented with a Tab. If we don’t use Tabs to indent the commands then <code>make</code> will fail. </strong></p>
<p>Let’s save and close the <code>makefile</code>, then we can run the following in the console:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span></code></pre></div>
<pre class="pre"><code>## makefile</code></pre>
<p>Let’s use the <code>make</code> command with the target we want to be “made” as the only argument:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">make</span> draft_journal_entry.txt</code></pre></div>
<pre class="pre"><code>## touch draft_journal_entry.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span></code></pre></div>
<pre class="pre"><code>## draft_journal_entry.txt
## makefile</code></pre>
<p>The commands that are indented under our definition of the rule for the <code>draft_journal_entry.txt</code> target were executed, so now <code>draft_journal_entry.txt</code> exists! Let’s try running the same <code>make</code> command again:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">make</span> draft_journal_entry.txt</code></pre></div>
<pre class="pre"><code>## make: &#39;draft_journal_entry.txt&#39; is up to date.</code></pre>
<p>Since the target file already exists no action is taken, and instead we’re informed that the rule for <code>draft_journal_entry.txt</code> is “up to date” (there’s nothing to be done).</p>
<p>If we look at the general rule format we previously sketched out, we can see that we didn’t specify any dependencies for this rule. A dependency is a file that the target depends on in order to be built. If a dependency has been updated since the last time <code>make</code> was run for a target then the target is not “up to date.” This means that the commands for that target will be run the next time <code>make</code> is run for that target. This way, the changes to the dependency are incorperated into the target. The commands are only run when the dependencies change, or when the target doesn’t exist at all, in order to avoid running commands unnecessarily.</p>
<p>Let’s update our <code>makefile</code> to include a <code>readme.txt</code> that is built automatically. First, let’s add a table of contents for our journal:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">echo</span> <span class="st">&quot;1. 2017-06-15-In-Boston&quot;</span> <span class="kw">&gt;</span> toc.txt</code></pre></div>
<p>Now let’s update our <code>makefile</code> with <code>nano</code> to automatically generate a <code>readme.txt</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">nano</span> makefile</code></pre></div>
<pre class="pre"><code>draft_journal_entry.txt:
  touch draft_journal_entry.txt

readme.txt: toc.txt
  echo &quot;This journal contains the following number of entries:&quot; &gt; readme.txt
  wc -l toc.txt | egrep -o &quot;[0-9]+&quot; &gt;&gt; readme.txt</code></pre>
<p>Take note that the <code>-o</code> flag provided to <code>egrep</code> above extracts the regular expression match from the matching line, so that only the number of lines is appended to <code>readme.txt</code>. Now let’s run <code>make</code> with <code>readme.txt</code> as the target:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">make</span> readme.txt</code></pre></div>
<pre class="pre"><code>## echo &quot;This journal contains the following number of entries:&quot; &gt; readme.txt
## wc -l toc.txt | egrep -o &quot;[0-9]+&quot; &gt;&gt; readme.txt</code></pre>
<p>Now let’s take a look at <code>readme.txt</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cat</span> readme.txt</code></pre></div>
<pre class="pre"><code>## This journal contains the following number of entries:
## 1</code></pre>
<p>Looks like it worked! What do you think will happen if we run make <code>readme.txt</code> again?</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">make</span> readme.txt</code></pre></div>
<pre class="pre"><code>## make: &#39;readme.txt&#39; is up to date.</code></pre>
<p>You guessed it: nothing happened! Since the <code>readme.txt</code> file still exists and no changes were made to any of the dependencies for readme.txt (<code>toc.txt</code> is the only dependency) <code>make</code> doesn’t run the commands for the <code>readme.txt</code> rule. Now let’s modify <code>toc.txt</code> then we’ll try running <code>make</code> again.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">echo</span> <span class="st">&quot;2. 2017-06-16-IQSS-Talk&quot;</span> <span class="kw">&gt;&gt;</span> toc.txt
<span class="kw">make</span> readme.txt</code></pre></div>
<pre class="pre"><code>## echo &quot;This journal contains the following number of entries:&quot; &gt; readme.txt
## wc -l toc.txt | egrep -o &quot;[0-9]+&quot; &gt;&gt; readme.txt</code></pre>
<p>Looks like it ran! Let’s check <code>readme.txt</code> to make sure.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cat</span> readme.txt</code></pre></div>
<pre class="pre"><code>## This journal contains the following number of entries:
## 2</code></pre>
<p>It looks like make successfully updated <code>readme.txt</code>! With every change to <code>toc.txt</code>, running make <code>readme.txt</code> will programmatically update <code>readme.txt</code>.</p>
<p>In order to simplify the <code>make</code> experience, we can create a rule at the top of our <code>makefile</code> called “<code>all</code>” where we can list all of the files that are built by the <code>makefile</code>. By adding the <code>all</code> target we can simply run <code>make</code> without any arguments in order to build all of the targets in the <code>makefile</code>. Let’s open up <code>nano</code> and add this rule:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">nano</span> makefile</code></pre></div>
<pre class="pre"><code>all: draft_journal_entry.txt readme.txt
draft_journal_entry.txt:
  touch draft_journal_entry.txt
  
readme.txt: toc.txt
  echo &quot;This journal contains the following number of entries:&quot; &gt; readme.txt
  wc -l toc.txt | egrep -o &quot;[0-9]+&quot; &gt;&gt; readme.txt</code></pre>
<p>While we have <code>nano</code> open let’s add another special rule at the end of our makefile called <code>clean</code> which destroys the files created by our makefile:</p>
<pre class="pre"><code>all: draft_journal_entry.txt readme.txt
draft_journal_entry.txt:
  touch draft_journal_entry.txt
  
readme.txt: toc.txt
  echo &quot;This journal contains the following number of entries:&quot; &gt; readme.txt
  wc -l toc.txt | egrep -o &quot;[0-9]+&quot; &gt;&gt; readme.txt
  
clean:
  rm draft_journal_entry.txt
  rm readme.txt</code></pre>
<p>Let’s save and close our <code>makefile</code> then let’s test it out.</p>
<p>First let’s clean up our repository:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">make</span> clean</code></pre></div>
<pre class="pre"><code>## rm draft_journal_entry.txt
## rm readme.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span></code></pre></div>
<pre class="pre"><code>## makefile
## toc.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">make</span></code></pre></div>
<pre class="pre"><code>## touch draft_journal_entry.txt
## echo &quot;This journal contains the following number of entries:&quot; &gt; readme.txt
## wc -l toc.txt | egrep -o &quot;[0-9]+&quot; &gt;&gt; readme.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ls</span></code></pre></div>
<pre class="pre"><code>## draft_journal_entry.txt
## readme.txt
## makefile
## toc.txt</code></pre>
<p>Looks like our <code>makefile</code> works! The make command is extremely powerful, and this section is meant to just be an introduction. For more in-depth reading about make I recommend Karl Broman’s tutorial or Chase Lambert’s makefiletutorial.com.</p>
<div id="summary-6" class="section level3">
<h3><span class="header-section-number">2.7.1</span> Summary</h3>
<ul>
<li><code>make</code> is a tool for creating relationships between files and programs, so that files that depend on other files can be automatically rebuilt.</li>
<li><code>makefiles</code> are text files that contain a list of rules.</li>
<li>Rules are made up of targets (files to be built), commands (a list of bash commands that build the target), and dependencies (files that the target depends on to be built).</li>
</ul>

</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>Hashing is the transformation of a string of characters into a usually shorter fixed-length value or key that represents the original string. Hashing is used to index and retrieve items in a database because it is faster to find the item using the shorter hashed key than to find it using the original value.<a href="working-with-unix.html#fnref1">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="basic-command-line.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="use-digitalocean-to-setup-your-shiny-app.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": null,
"download": ["Unix.pdf", "Unix.epub", "Unix.mobi"],
"toc": {
"collapse": "subsection",
"scroll_highlight": true
},
"toolbar": {
"position": "fixed"
},
"search": true
});
});
</script>

</body>

</html>
