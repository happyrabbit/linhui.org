<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>数据科学家：R语言</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="This is my first book on data science">
  <meta name="generator" content="bookdown 0.1 and GitBook 2.6.7">

  <meta property="og:title" content="数据科学家：R语言" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is my first book on data science" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="数据科学家：R语言" />
  
  <meta name="twitter:description" content="This is my first book on data science" />
  

<meta name="author" content="林荟">

<meta name="date" content="2016-12-11">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="section-5.html">
<link rel="next" href="section-7.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">数据科学家：R语言</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> 介绍</a></li>
<li class="chapter" data-level="2" data-path="section-2.html"><a href="section-2.html"><i class="fa fa-check"></i><b>2</b> 数据科学</a><ul>
<li class="chapter" data-level="2.1" data-path="section-2.html"><a href="section-2.html#section-2.1"><i class="fa fa-check"></i><b>2.1</b> 什么是数据科学？</a></li>
<li class="chapter" data-level="2.2" data-path="section-2.html"><a href="section-2.html#section-2.2"><i class="fa fa-check"></i><b>2.2</b> 什么是数据科学家？</a></li>
<li class="chapter" data-level="2.3" data-path="section-2.html"><a href="section-2.html#section-2.3"><i class="fa fa-check"></i><b>2.3</b> 数据科学家需要的技能</a></li>
<li class="chapter" data-level="2.4" data-path="section-2.html"><a href="section-2.html#section-2.4"><i class="fa fa-check"></i><b>2.4</b> 数据科学可以解决什么问题？</a><ul>
<li class="chapter" data-level="2.4.1" data-path="section-2.html"><a href="section-2.html#section-2.4.1"><i class="fa fa-check"></i><b>2.4.1</b> 前提要求</a></li>
<li class="chapter" data-level="2.4.2" data-path="section-2.html"><a href="section-2.html#section-2.4.2"><i class="fa fa-check"></i><b>2.4.2</b> 问题种类</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="section-3.html"><a href="section-3.html"><i class="fa fa-check"></i><b>3</b> 数据集模拟和背景介绍</a><ul>
<li class="chapter" data-level="3.1" data-path="section-3.html"><a href="section-3.html#section-3.1"><i class="fa fa-check"></i><b>3.1</b> 服装消费者数据</a></li>
<li class="chapter" data-level="3.2" data-path="section-3.html"><a href="section-3.html#section-3.2"><i class="fa fa-check"></i><b>3.2</b> 航空公司满意度调查</a></li>
<li class="chapter" data-level="3.3" data-path="section-3.html"><a href="section-3.html#section-3.3"><i class="fa fa-check"></i><b>3.3</b> 生猪疫情风险预测数据</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="section-4.html"><a href="section-4.html"><i class="fa fa-check"></i><b>4</b> 数据分析一般流程</a><ul>
<li class="chapter" data-level="4.1" data-path="section-4.html"><a href="section-4.html#section-4.1"><i class="fa fa-check"></i><b>4.1</b> 问题到数据</a></li>
<li class="chapter" data-level="4.2" data-path="section-4.html"><a href="section-4.html#section-4.2"><i class="fa fa-check"></i><b>4.2</b> 数据到信息</a></li>
<li class="chapter" data-level="4.3" data-path="section-4.html"><a href="section-4.html#section-4.3"><i class="fa fa-check"></i><b>4.3</b> 信息到行动</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="section-5.html"><a href="section-5.html"><i class="fa fa-check"></i><b>5</b> 数据预处理</a><ul>
<li class="chapter" data-level="5.1" data-path="section-5.html"><a href="section-5.html#section-5.1"><i class="fa fa-check"></i><b>5.1</b> 介绍</a></li>
<li class="chapter" data-level="5.2" data-path="section-5.html"><a href="section-5.html#section-5.2"><i class="fa fa-check"></i><b>5.2</b> 数据清理</a></li>
<li class="chapter" data-level="5.3" data-path="section-5.html"><a href="section-5.html#section-5.3"><i class="fa fa-check"></i><b>5.3</b> 缺失值填补</a><ul>
<li class="chapter" data-level="5.3.1" data-path="section-5.html"><a href="section-5.html#section-5.3.1"><i class="fa fa-check"></i><b>5.3.1</b> 中位数或众数填补</a></li>
<li class="chapter" data-level="5.3.2" data-path="section-5.html"><a href="section-5.html#k-"><i class="fa fa-check"></i><b>5.3.2</b> K-近邻填补</a></li>
<li class="chapter" data-level="5.3.3" data-path="section-5.html"><a href="section-5.html#section-5.3.3"><i class="fa fa-check"></i><b>5.3.3</b> 袋状树填补</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="section-5.html"><a href="section-5.html#section-5.4"><i class="fa fa-check"></i><b>5.4</b> 中心化和标量化</a></li>
<li class="chapter" data-level="5.5" data-path="section-5.html"><a href="section-5.html#section-5.5"><i class="fa fa-check"></i><b>5.5</b> 有偏分布</a></li>
<li class="chapter" data-level="5.6" data-path="section-5.html"><a href="section-5.html#section-5.6"><i class="fa fa-check"></i><b>5.6</b> 处理离群点</a></li>
<li class="chapter" data-level="5.7" data-path="section-5.html"><a href="section-5.html#section-5.7"><i class="fa fa-check"></i><b>5.7</b> 共线性</a></li>
<li class="chapter" data-level="5.8" data-path="section-5.html"><a href="section-5.html#section-5.8"><i class="fa fa-check"></i><b>5.8</b> 稀疏变量</a></li>
<li class="chapter" data-level="5.9" data-path="section-5.html"><a href="section-5.html#section-5.9"><i class="fa fa-check"></i><b>5.9</b> 编码名义变量</a></li>
<li class="chapter" data-level="5.10" data-path="section-5.html"><a href="section-5.html#section-5.10"><i class="fa fa-check"></i><b>5.10</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="section-6.html"><a href="section-6.html"><i class="fa fa-check"></i><b>6</b> 数据操作</a><ul>
<li class="chapter" data-level="6.1" data-path="section-6.html"><a href="section-6.html#section-6.1"><i class="fa fa-check"></i><b>6.1</b> 数据读写</a><ul>
<li class="chapter" data-level="6.1.1" data-path="section-6.html"><a href="section-6.html#tibble"><i class="fa fa-check"></i><b>6.1.1</b> 取代传统数据框的<code>tibble</code>对象</a></li>
<li class="chapter" data-level="6.1.2" data-path="section-6.html"><a href="section-6.html#readr"><i class="fa fa-check"></i><b>6.1.2</b> 高效数据读写：<code>readr</code>包</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="section-6.html"><a href="section-6.html#section-6.2"><i class="fa fa-check"></i><b>6.2</b> 数据整合</a><ul>
<li class="chapter" data-level="6.2.1" data-path="section-6.html"><a href="section-6.html#baseapply"><i class="fa fa-check"></i><b>6.2.1</b> base包：apply()</a></li>
<li class="chapter" data-level="6.2.2" data-path="section-6.html"><a href="section-6.html#plyrddply"><i class="fa fa-check"></i><b>6.2.2</b> plyr包：ddply()函数</a></li>
<li class="chapter" data-level="6.2.3" data-path="section-6.html"><a href="section-6.html#dplyr"><i class="fa fa-check"></i><b>6.2.3</b> dplyr包</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="section-6.html"><a href="section-6.html#section-6.3"><i class="fa fa-check"></i><b>6.3</b> 数据整形</a><ul>
<li class="chapter" data-level="6.3.1" data-path="section-6.html"><a href="section-6.html#reshape2"><i class="fa fa-check"></i><b>6.3.1</b> <code>reshape2</code>包</a></li>
<li class="chapter" data-level="6.3.2" data-path="section-6.html"><a href="section-6.html#tidyr"><i class="fa fa-check"></i><b>6.3.2</b> <code>tidyr</code>包</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="section-6.html"><a href="section-6.html#-1"><i class="fa fa-check"></i><b>6.4</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="section-7.html"><a href="section-7.html"><i class="fa fa-check"></i><b>7</b> 基础建模技术</a><ul>
<li class="chapter" data-level="7.1" data-path="section-7.html"><a href="section-7.html#section-7.1"><i class="fa fa-check"></i><b>7.1</b> 有监督和无监督</a></li>
<li class="chapter" data-level="7.2" data-path="section-7.html"><a href="section-7.html#section-7.2"><i class="fa fa-check"></i><b>7.2</b> 误差及其来源</a><ul>
<li class="chapter" data-level="7.2.1" data-path="section-7.html"><a href="section-7.html#section-7.2.1"><i class="fa fa-check"></i><b>7.2.1</b> 系统误差和随机误差</a></li>
<li class="chapter" data-level="7.2.2" data-path="section-7.html"><a href="section-7.html#section-7.2.2"><i class="fa fa-check"></i><b>7.2.2</b> 应变量误差</a></li>
<li class="chapter" data-level="7.2.3" data-path="section-7.html"><a href="section-7.html#section-7.2.3"><i class="fa fa-check"></i><b>7.2.3</b> 自变量误差</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="section-7.html"><a href="section-7.html#section-7.3"><i class="fa fa-check"></i><b>7.3</b> 数据划分和再抽样</a><ul>
<li class="chapter" data-level="7.3.1" data-path="section-7.html"><a href="section-7.html#section-7.3.1"><i class="fa fa-check"></i><b>7.3.1</b> 划分训练集和测试集</a></li>
<li class="chapter" data-level="7.3.2" data-path="section-7.html"><a href="section-7.html#section-7.3.2"><i class="fa fa-check"></i><b>7.3.2</b> 重抽样</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="section-7.html"><a href="section-7.html#-2"><i class="fa fa-check"></i><b>7.4</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="section-8.html"><a href="section-8.html"><i class="fa fa-check"></i><b>8</b> 模型评估度量</a><ul>
<li class="chapter" data-level="8.1" data-path="section-8.html"><a href="section-8.html#section-8.1"><i class="fa fa-check"></i><b>8.1</b> 回归模型评估度量</a></li>
<li class="chapter" data-level="8.2" data-path="section-8.html"><a href="section-8.html#section-8.2"><i class="fa fa-check"></i><b>8.2</b> 分类模型评估度量</a><ul>
<li class="chapter" data-level="8.2.1" data-path="section-8.html"><a href="section-8.html#kappa"><i class="fa fa-check"></i><b>8.2.1</b> Kappa统计量</a></li>
<li class="chapter" data-level="8.2.2" data-path="section-8.html"><a href="section-8.html#roc"><i class="fa fa-check"></i><b>8.2.2</b> ROC曲线</a></li>
<li class="chapter" data-level="8.2.3" data-path="section-8.html"><a href="section-8.html#section-8.2.3"><i class="fa fa-check"></i><b>8.2.3</b> 提升图</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="section-8.html"><a href="section-8.html#-3"><i class="fa fa-check"></i><b>8.3</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="section-9.html"><a href="section-9.html"><i class="fa fa-check"></i><b>9</b> 特征工程</a><ul>
<li class="chapter" data-level="9.1" data-path="section-9.html"><a href="section-9.html#section-9.1"><i class="fa fa-check"></i><b>9.1</b> 特征构建</a></li>
<li class="chapter" data-level="9.2" data-path="section-9.html"><a href="section-9.html#section-9.2"><i class="fa fa-check"></i><b>9.2</b> 特征提取</a><ul>
<li class="chapter" data-level="9.2.1" data-path="section-9.html"><a href="section-9.html#section-9.2.1"><i class="fa fa-check"></i><b>9.2.1</b> 初步探索数据</a></li>
<li class="chapter" data-level="9.2.2" data-path="section-9.html"><a href="section-9.html#section-9.2.2"><i class="fa fa-check"></i><b>9.2.2</b> 主成分分析</a></li>
<li class="chapter" data-level="9.2.3" data-path="section-9.html"><a href="section-9.html#section-9.2.3"><i class="fa fa-check"></i><b>9.2.3</b> 探索性因子分析</a></li>
<li class="chapter" data-level="9.2.4" data-path="section-9.html"><a href="section-9.html#section-9.2.4"><i class="fa fa-check"></i><b>9.2.4</b> 高维标度化</a></li>
<li class="chapter" data-level="9.2.5" data-path="section-9.html"><a href="section-9.html#section-9.2.5"><i class="fa fa-check"></i><b>9.2.5</b> 知识扩展</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="section-9.html"><a href="section-9.html#section-9.3"><i class="fa fa-check"></i><b>9.3</b> 特征选择</a><ul>
<li class="chapter" data-level="9.3.1" data-path="section-9.html"><a href="section-9.html#section-9.3.1"><i class="fa fa-check"></i><b>9.3.1</b> 过滤法</a></li>
<li class="chapter" data-level="9.3.2" data-path="section-9.html"><a href="section-9.html#section-9.3.2"><i class="fa fa-check"></i><b>9.3.2</b> 绕封法</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="section-10.html"><a href="section-10.html"><i class="fa fa-check"></i><b>10</b> 线性回归极其衍生</a><ul>
<li class="chapter" data-level="10.1" data-path="section-10.html"><a href="section-10.html#section-10.1"><i class="fa fa-check"></i><b>10.1</b> 普通线性回归</a><ul>
<li class="chapter" data-level="10.1.1" data-path="section-10.html"><a href="section-10.html#section-10.1.1"><i class="fa fa-check"></i><b>10.1.1</b> 最小二乘线性模型</a></li>
<li class="chapter" data-level="10.1.2" data-path="section-10.html"><a href="section-10.html#section-10.1.2"><i class="fa fa-check"></i><b>10.1.2</b> 回归诊断</a></li>
<li class="chapter" data-level="10.1.3" data-path="section-10.html"><a href="section-10.html#section-10.1.3"><i class="fa fa-check"></i><b>10.1.3</b> 离群点，高杠杆点和强影响点</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="section-10.html"><a href="section-10.html#section-10.2"><i class="fa fa-check"></i><b>10.2</b> 收缩方法</a><ul>
<li class="chapter" data-level="10.2.1" data-path="section-10.html"><a href="section-10.html#section-10.2.1"><i class="fa fa-check"></i><b>10.2.1</b> 岭回归</a></li>
<li class="chapter" data-level="10.2.2" data-path="section-10.html"><a href="section-10.html#lasso"><i class="fa fa-check"></i><b>10.2.2</b> Lasso</a></li>
<li class="chapter" data-level="10.2.3" data-path="section-10.html"><a href="section-10.html#section-10.2.3"><i class="fa fa-check"></i><b>10.2.3</b> 弹性网络</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="section-10.html"><a href="section-10.html#lasso"><i class="fa fa-check"></i><b>10.3</b> 知识扩展：Lasso的变量选择功能</a></li>
<li class="chapter" data-level="10.4" data-path="section-10.html"><a href="section-10.html#section-10.4"><i class="fa fa-check"></i><b>10.4</b> 主成分和偏最小二乘回归</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="section-11.html"><a href="section-11.html"><i class="fa fa-check"></i><b>11</b> 广义线性模型压缩方法</a><ul>
<li class="chapter" data-level="11.1" data-path="section-11.html"><a href="section-11.html#glmnet"><i class="fa fa-check"></i><b>11.1</b> 初识<code>glmnet</code></a></li>
<li class="chapter" data-level="11.2" data-path="section-11.html"><a href="section-11.html#section-11.2"><i class="fa fa-check"></i><b>11.2</b> 收缩线性回归</a></li>
<li class="chapter" data-level="11.3" data-path="section-11.html"><a href="section-11.html#section-11.3"><i class="fa fa-check"></i><b>11.3</b> 逻辑回归</a><ul>
<li class="chapter" data-level="11.3.1" data-path="section-11.html"><a href="section-11.html#section-11.3.1"><i class="fa fa-check"></i><b>11.3.1</b> 普通逻辑回归</a></li>
<li class="chapter" data-level="11.3.2" data-path="section-11.html"><a href="section-11.html#section-11.3.2"><i class="fa fa-check"></i><b>11.3.2</b> 收缩逻辑回归</a></li>
<li class="chapter" data-level="11.3.3" data-path="section-10.html"><a href="section-10.html#lasso"><i class="fa fa-check"></i><b>11.3.3</b> 知识扩展：群组lasso逻辑回归</a></li>
</ul></li>
<li class="chapter" data-level="11.4" data-path="section-11.html"><a href="section-11.html#section-11.4"><i class="fa fa-check"></i><b>11.4</b> 收缩多项回归</a></li>
<li class="chapter" data-level="11.5" data-path="section-11.html"><a href="section-11.html#section-11.5"><i class="fa fa-check"></i><b>11.5</b> 泊松收缩回归</a></li>
<li class="chapter" data-level="11.6" data-path="section-11.html"><a href="section-11.html#-4"><i class="fa fa-check"></i><b>11.6</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="section-12.html"><a href="section-12.html"><i class="fa fa-check"></i><b>12</b> 树模型</a><ul>
<li class="chapter" data-level="12.1" data-path="section-12.html"><a href="section-12.html#section-12.1"><i class="fa fa-check"></i><b>12.1</b> 分裂准则</a></li>
<li class="chapter" data-level="12.2" data-path="section-12.html"><a href="section-12.html#section-12.2"><i class="fa fa-check"></i><b>12.2</b> 树的修剪</a></li>
<li class="chapter" data-level="12.3" data-path="section-12.html"><a href="section-12.html#section-12.3"><i class="fa fa-check"></i><b>12.3</b> 回归树和决策树</a><ul>
<li class="chapter" data-level="12.3.1" data-path="section-12.html"><a href="section-12.html#section-12.3.1"><i class="fa fa-check"></i><b>12.3.1</b> 回归树</a></li>
<li class="chapter" data-level="12.3.2" data-path="section-12.html"><a href="section-12.html#section-12.3.2"><i class="fa fa-check"></i><b>12.3.2</b> 决策树</a></li>
</ul></li>
<li class="chapter" data-level="12.4" data-path="section-12.html"><a href="section-12.html#section-12.4"><i class="fa fa-check"></i><b>12.4</b> 装袋树</a></li>
<li class="chapter" data-level="12.5" data-path="section-12.html"><a href="section-12.html#section-12.5"><i class="fa fa-check"></i><b>12.5</b> 随机森林</a></li>
<li class="chapter" data-level="12.6" data-path="section-12.html"><a href="section-12.html#section-12.6"><i class="fa fa-check"></i><b>12.6</b> 助推法</a></li>
<li class="chapter" data-level="12.7" data-path="section-12.html"><a href="section-12.html#section-12.7"><i class="fa fa-check"></i><b>12.7</b> 知识扩展：助推法的可加模型框架</a></li>
<li class="chapter" data-level="12.8" data-path="section-12.html"><a href="section-12.html#section-12.8"><i class="fa fa-check"></i><b>12.8</b> 知识扩展：助推树的数学框架</a><ul>
<li class="chapter" data-level="12.8.1" data-path="section-12.html"><a href="section-12.html#section-12.8.1"><i class="fa fa-check"></i><b>12.8.1</b> 数学表达</a></li>
<li class="chapter" data-level="12.8.2" data-path="section-12.html"><a href="section-12.html#section-12.8.2"><i class="fa fa-check"></i><b>12.8.2</b> 梯度助推数值优化</a></li>
</ul></li>
<li class="chapter" data-level="12.9" data-path="section-12.html"><a href="section-12.html#-5"><i class="fa fa-check"></i><b>12.9</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="section-13.html"><a href="section-13.html"><i class="fa fa-check"></i><b>13</b> 深度学习</a><ul>
<li class="chapter" data-level="13.1" data-path="section-6.html"><a href="section-6.html#-1"><i class="fa fa-check"></i><b>13.1</b> 介绍</a></li>
<li class="chapter" data-level="13.2" data-path="section-13.html"><a href="section-13.html#r"><i class="fa fa-check"></i><b>13.2</b> R中深度学习包</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>14</b> References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">数据科学家：R语言</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="section-6" class="section level1">
<h1><span class="header-section-number">第6章</span> 数据操作</h1>
<p>这章专门介绍一些经常用到的有效数据操作方法，展示如何用R实现。在进行分析之前用描述统计量（均值，标准差等等）和数据可视化总结探索数据集很重要，在分析之后对结果进行总结也很重要，此外我们还经常需要对数据的格式和排列方式进行变换，使得数据结构符合模型的要求。这里默认读者已经熟悉一些传统的R数据操作，如数据框的变量截取，删除。基础R包中的数据读写函数（<code>read.csv()</code>和<code>write.csv()</code>等）。接下来要介绍的是一些更加高效的实现这些操作的方法。</p>
<p>我们会跳过一些基础的变量水平的描述，比如对于离散变量，我们通常会用频数表格稍微在需要时查看变量各个层级观测的频数（<code>table()</code>），或者两个变量的交叉表格。还可以通过对离散变量绘制条形图。对于连续变量，我们时不时需要查看某个变量的均值（<code>mean()</code>），标准差（<code>sd()</code>）,分位数（<code>quantile()</code>）之类的。此外还有一些像<code>summary()</code>，<code>str()</code>和<code>describe()</code>（这个函数是’psych’包里的，之前有用过）这样的函数能给出关于一个数据框的总结。以上提到的这些都是一些最基础的探索各个阶段数据（包括模型结果）的方法。但仅仅这些是不够的，这些方法的灵活性不高，输出的信息是固定的。我们可能不想要<code>summary()</code>函数输出的全部信息，而有些我们想要的信息它却没有。比如如果我们想要知道每个类别的客户收入，在线花销等的均值；或者我们想要在每个类别中找到收入最高的人，然后将他们提取出来集合在一起；又或者我们希望有一个新的变量指示购买的渠道（是在线还是实体店），并且将这个变量用于建模，这时就需要对数据进行整形，将在线购买的记录和实体店购买的记录逐行排列而非现在的逐列。这些操作如果仅仅使用初级函数会非常繁琐，且运算效率也不高。R中有一些其它包可以非常高效简洁的完成这些看似复杂的任务。初次接触这些函数的小伙伴会觉得它们不太好学，那是自然，灵活性越强的工具需要学习掌握的时间自然长些，但这就是一个<strong>熟能生巧</strong>的过程。</p>
<div class="figure">
<img src="http://scientistcafe.com/images/Data_Analysis_and_Cleaning.png" />

</div>
<p>本章内容安排如下，在介绍数据整合和整形操作之前，先介绍一个新的可以取代数据框的对象，<code>tibble</code>。我们会介绍如何将传统的数据框转化为<code>tibble</code>对象，以及它们之间的不同。接着我们会介绍一个高效读取数据集的包<code>readr</code>。虽然这个包并不用来进行数据变换操作，但数据读写也是分析的一个必要基础环节。当数据大时，读取数据会成为一个耗时的环节，使用一些高效的数据读写包在数据量大时显著提高效率。此外，和R基础包中相应的读写函数相比，<code>readr</code>包还有一些友好的新特征。之后我们将介绍基础包中用于数据整合的<code>apply()</code>函数，以及更高级的<code>plyr</code>包和它专门针对数据框的优化版<code>dplyr</code>包，后两个包能够进行高效的数据整合操作。最后介绍两个用于数据整形的包：<code>reshape2</code>包和<code>tidyr</code>包。所有这些包都是数据处理的利器，使用频率非常高。大家需要通过实践不断熟悉。</p>
<div id="section-6.1" class="section level2">
<h2><span class="header-section-number">6.1</span> 数据读写</h2>
<div id="tibble" class="section level3">
<h3><span class="header-section-number">6.1.1</span> 取代传统数据框的<code>tibble</code>对象</h3>
<p><code>tibble</code>在原有数据框的基础上做了改进，使得日后进一步处理建模更加容易。R基础包中的一些设计现在已经不那么适用，但是要改变R的底层设计同时保留R代码现有的使用方式非常困难，因此，R社区的创新改进通常都依赖于新的包。这个小节介绍的<code>tibble</code>包就是对基础R中的数据框对象进行改进。</p>
<p>我们还是使用服装消费者数据为例。先载入相应的包和数据：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tibble)
<span class="kw">library</span>(dplyr)
<span class="kw">library</span>(ggplot2)
sim.dat&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)</code></pre></div>
<p>大部分的R包都还在使用传统的数据框，你可以通过<code>tibble</code>包中的<code>as_tibble()</code>函数将其转化成<code>tibble</code>对象：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 创建一个小数据框</span>
df=<span class="kw">data.frame</span>(<span class="dt">x=</span><span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">5</span>),<span class="dt">y=</span><span class="kw">rep</span>(<span class="st">&quot;a&quot;</span>,<span class="dv">5</span>))
<span class="kw">as_tibble</span>(df)</code></pre></div>
<p>和数据框一样，你也可以自己构建<code>tibble</code>对象：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span>:<span class="dv">5</span>, 
  <span class="dt">y =</span> <span class="dv">1</span>, 
  <span class="dt">z =</span> x ^<span class="st"> </span><span class="dv">2</span> +<span class="st"> </span>y
)</code></pre></div>
<p>可见<code>tibble()</code>可以自动将y的值重复向量x的长度。如果你熟悉数据框的话应该知道，<code>data.frame()</code>函数总是将字符变量转化为因子变量（还有其它变量类型自动转化带来的麻烦），而<code>tibble()</code>不会改变输入变量的类型，也不会自行改变变量的名字，甭管这名字是否符合R对变量名的要求（比如必须要用字母开头，不能有空格等）：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tb &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="st">`</span><span class="dt">:)</span><span class="st">`</span> =<span class="st"> &quot;smile&quot;</span>, 
  <span class="st">`</span><span class="dt"> </span><span class="st">`</span> =<span class="st"> &quot;space&quot;</span>,
  <span class="st">`</span><span class="dt">2000</span><span class="st">`</span> =<span class="st"> &quot;number&quot;</span>
)
<span class="kw">print</span>(tb)</code></pre></div>
<p>注意这里你需用单引号将变量名引起来。如果你要在其它包（如<code>ggplot2</code>、<code>dplyr</code>和<code>tidyr</code>）中使用tibble对象中的变量也需要加单引号，比如：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tb=<span class="kw">tibble</span>(
  <span class="st">`</span><span class="dt">:)</span><span class="st">`</span> =<span class="st"> </span><span class="dv">1</span>:<span class="dv">5</span>,
  <span class="st">`</span><span class="dt"> </span><span class="st">`</span> =<span class="st"> </span><span class="dv">1</span>,
  <span class="st">`</span><span class="dt">T_T</span><span class="st">`</span> =<span class="st"> `</span><span class="dt">:)</span><span class="st">`</span> ^<span class="st"> </span><span class="dv">2</span> +<span class="st"> `</span><span class="dt"> </span><span class="st">`</span>
)
<span class="kw">ggplot</span>(tb,<span class="kw">aes</span>(<span class="st">`</span><span class="dt">:)</span><span class="st">`</span>,<span class="st">`</span><span class="dt">T_T</span><span class="st">`</span>))+<span class="kw">geom_point</span>()</code></pre></div>
<p><img src="DS_R_files/figure-html/unnamed-chunk-43-1.png" width="672" /></p>
<div id="tibble" class="section level4">
<h4><span class="header-section-number">6.1.1.1</span> <code>tibble</code>和传统数据框的区别</h4>
<p><code>tibble</code>和传统数据框的不同主要在于<strong>输出显示</strong>和<strong>截取变量</strong>这两方面。</p>
<p><strong>输出显示</strong></p>
<p><code>tibble</code>格式的数据输出显示更友好。它只显示头10行，而且会根据屏幕自动调整输出的列数。此外，在列名后还会显示每列的类型。虽然不是直接涉及数据操作，但在数据分析的过程中我们需要不时查看数据，这些友好的特征给处理大数据带来方便。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">as_tibble</span>(sim.dat))</code></pre></div>
<p>默认设置下，tibble对象会根据控制器窗口的大小调整输出，如果你用普通的数据框将会占满整个控制器，数据量过大时可能无法看到最开始的数据。如果你要查看更多的行和列，可以使用<code>print()</code>函数并且自定义设置，其中<code>width = Inf</code>告诉函数输出所有的列：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里不显示输出</span>
<span class="kw">print</span>(sim.dat,<span class="dt">n =</span> <span class="dv">15</span>, <span class="dt">width =</span> <span class="ot">Inf</span>)</code></pre></div>
<p>还有其它关于输出的设置，想要了解更多信息可以键入下面命令查看帮助文档：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">package?tibble</code></pre></div>
<p><strong>截取变量</strong></p>
<p>从<code>tibble</code>对象中截取某一个变量会用到“$” 和“[[”符号。“[[”能够通过变量的名字或者位置指针来截取，“$”只能通过变量名截取。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 通过变量名截取，不显示输出</span>
<span class="co"># sim.dat$age </span>
<span class="co"># 通过变量名截取</span>
<span class="co"># sim.dat[[&quot;age&quot;]]</span>
<span class="co"># 通过位置截取</span>
<span class="co"># sim.dat[[1]]</span></code></pre></div>
<p>当你通过“$”或“[”操作符从传统数据框中截取一个变量，有时该变量时向量的形式，有时是另外一个数据框的形式。这时常会导致之后的程序运行出现错误（比如你需要进一步进行矩阵运算），这样的错误因为细微反对于新手来说不好查找。而从<code>tibble</code>中截取任何一个变量依旧是个<code>tibble</code>对象。 你也可以使用管道操作符（“%&gt;%”）进行数据截取。关于该操作符，我们会在之后讲到。这里我们先展示如何用管道操作符截取数据。这种情况下需要额外的特殊占位符“.”：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 不显示输出结果</span>
<span class="kw">library</span>(dplyr)
sim.dat%&gt;%.$age
sim.dat%&gt;%.[[<span class="st">&quot;age&quot;</span>]]</code></pre></div>
<p>由于<code>tibble</code>对象比较新，R中很多函数可能不能处理该对象。当你清理了数据之后要对数据建模时可以很容易将<code>tibble</code>对象转成原始数据框格式：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat=<span class="kw">as.data.frame</span>(sim.dat)
<span class="kw">class</span>(sim.dat)</code></pre></div>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
</div>
</div>
<div id="readr" class="section level3">
<h3><span class="header-section-number">6.1.2</span> 高效数据读写：<code>readr</code>包</h3>
<p>大家应该熟悉基础R中的<code>read.csv()</code>、<code>write.csv()</code>等函数。这里给大家介绍一种更加高效的数据读取包<code>readr</code>包。RStudio在2015年推出的<code>readr</code>包可以取代传统的<code>read.csv()</code>和<code>read.table()</code>等函数。使用该包中对应的<code>read_csv()</code>和<code>write_csv()</code>函数读写数据的效率大幅度提高。<code>readr</code>包基于 C++ 的SourceFile，SourceString，SourceRaw的文件API接口，避免了数据的复制和分配，能更加快速读取格式化数据（和传统基础R中的包相比，速度快乐超过10倍）。此外，<code>readr</code>不会将字符串转化成因子变量，能够解析时间观测，不会修改列名。和传统的导入函数相比，个人认为<code>readr</code>的必杀特征就是它提供<strong>进度条</strong>。</p>
<div class="figure">
<img src="http://scientistcafe.com/book/Figure/prograssbar.png" alt="生命的进度条" />
<p class="caption">生命的进度条</p>
</div>
<p>知乎上有这样一条神回复: &gt; 某女问：为什么追了我这么长时间的男生突然不追了？<br />
某男答：你特么倒是给个<strong>进度条</strong>啊！</p>
<p>可见等待并不可怕，没有进度条的等待才是难以忍受的。言归正传，<code>readr</code>包中用于读入数据的函数主要有如下几种：</p>
<ul>
<li><code>read_csv()</code>读入逗号分隔文件</li>
<li><code>read_csv2()</code>a用于读入分号分隔文件</li>
<li><code>read_tsv()</code>读入制表符分隔文件</li>
<li><code>read_delim()</code>读入任意分隔符文件</li>
</ul>
<p>这些函数的使用语法很类似，由于.csv文件是最常用的数据存储形式，<code>read_csv()</code>函数就可以涵盖大部分的数据读入需要了。所以这里我们将着重介绍该函数，由于各个函数使用方式类似，只要学会一种，举一反三，其它函数也就不难了。</p>
<p><code>read_csv()</code>函数的第一个参数是最重要的，也就是你要读的数据集路径：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(readr)
sim.dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv &quot;</span>)</code></pre></div>
<p>用该函数读入的数据集自动是<code>tibble</code>格式的。在运行<code>read_csv()</code>的时候，会自动输出列的基本信息：列名和类型。这是<code>readr</code>包的一个重要特征。你也可以直接在代码中手动输入一些csv格式的文档，这有助于理解<code>readr</code>的工作原理以及向人展示该包的使用。<code>read_csv()</code>通常将数据的第一行作为变量名：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span>
<span class="st">1,2,3</span>
<span class="st">4,5,6&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>有时数据的头几行是关于数据集的说明，这个时候你可以设置<code>skip</code>选项跳过这些行：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;这是个样本数据</span>
<span class="st">          这行只是注释</span>
<span class="st">          x,y,z</span>
<span class="st">          1,2,3&quot;</span>, <span class="dt">skip =</span> <span class="dv">2</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>如果数据没有变量名，那可以设置<code>col_names = FALSE</code>，这样变量将被自动贴上 X1到Xn的标签：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>这里“”表示另起一行。或者你可以指定变量名称：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>, <span class="dt">col_names =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>))
<span class="kw">print</span>(dat)</code></pre></div>
<p>此外，如前所述，对于分号分隔文件可以使用<code>read_csv2()</code>：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv2</span>(<span class="st">&quot;x;y;Z</span><span class="ch">\n</span><span class="st">1;2;3&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>对于制表符分隔文件，可以用<code>read_tsv()</code>：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_tsv</span>(<span class="st">&quot;x</span><span class="ch">\t</span><span class="st">y</span><span class="ch">\t</span><span class="st">z</span><span class="ch">\n</span><span class="st">1</span><span class="ch">\t</span><span class="st">2</span><span class="ch">\t</span><span class="st">3&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>或者可以用<code>read_delim()</code>，然后指定分隔符：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_delim</span>(<span class="st">&quot;x|y|z</span><span class="ch">\n</span><span class="st">1|2|3&quot;</span>, <span class="dt">delim =</span> <span class="st">&quot;|&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>另外一个经常遇到的问题是指定缺失值。比如我在处理市场调查问卷回复的数据时，负责问卷设计和数据收集的人将缺失的回复设置为<code>99</code>，那么你可以通过设置<code>na=&quot;99&quot;</code>告诉函数将取值为99的观测读入为缺失值：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;x,y,z</span><span class="ch">\n</span><span class="st">1,2,99&quot;</span>,<span class="dt">na=</span><span class="st">&quot;99&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>到此为止，几乎涵盖了大部分你可能会用到的数据读取。<code>readr</code>同样有两个储存数据的函数： <code>write_csv()</code>和<code>write_tsv()</code>。它们和之前的<code>write.csv()</code>函数相比有两个优势：</p>
<ol style="list-style-type: decimal">
<li>对字符串总是使用UTF-8编码</li>
<li>将日期和时间用ISO8601格式储存，便于其它软件解析</li>
</ol>
<p>如果你要将.csv格式的数据导出成Excel格式，可以使用<code>write_excel_csv()</code>，该函数会告诉Excel使用UTF-8编码。函数的语法和传统<code>write.csv()</code>几乎一样，如：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_csv</span>(sim.dat, <span class="st">&quot;sim.dat.csv&quot;</span>)</code></pre></div>
<p>对于其它类型的数据，可以使用下面的包：</p>
<ul>
<li><code>Haven</code>：读入SPSS, Stata和SAS数据</li>
<li><code>Readxl</code>：读取excel文档（.xls和.xlsx）</li>
<li><code>DBI</code>：在指定了相应数据库（RMySQL、RSQLite和RPostgreSQL）的情况下，可以直接从数据库中通过SQL读取数据。</li>
</ul>
<p>对于网络数据的读取，可以参考“XML and Web Technologies for Data Sciences with R”<span class="citation">[<a href="#ref-xml2014">14</a>]</span>。关于其它数据的读取有一个非常好的免费使用手册：R data import/export manual（<a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html#Acknowledgements" class="uri">https://cran.r-project.org/doc/manuals/r-release/R-data.html#Acknowledgements</a>）。大家也可以自己尝试下号称数据读写的“瑞士军刀”的 <code>rio</code>包：<a href="https://github.com/leeper/rio" class="uri">https://github.com/leeper/rio</a>。</p>
</div>
</div>
<div id="section-6.2" class="section level2">
<h2><span class="header-section-number">6.2</span> 数据整合</h2>
<div id="baseapply" class="section level3">
<h3><span class="header-section-number">6.2.1</span> base包：apply()</h3>
<p>R基础包中有几个强大的函数，<code>apply()</code>、<code>lapply()</code>和<code>sapply()</code>等。它们做的事情类似，只是对应的对象，或返回对象的格式不同。这些函数对于R的初学者来说可能有些难，但一旦熟悉以后会发现它们非常有效。它们是干什么的？简单来说就是依次对某一对象的某一部分重复应用一个指定的函数。它们的不同在于，<code>apply()</code>将你指定的函数作用于<strong>数据框</strong>对象的行或列，返回一个<strong>向量</strong>。‘lapply()’ 将指定的函数作用于<strong>列表</strong>或者<strong>数据框</strong>对象，返回一个长度相同的<strong>列表</strong>。<code>sapply()</code>更加便捷，且算是对<code>lapply()</code>进行了包装，若<code>sapply()</code>中参数<code>simplify=FALSE</code>，那么其返回的值和<code>lapply()</code>是一样的。若<code>simplify=TRUE</code>，则<code>sapply()</code>的返回值不是一个列表，而是一个矩阵。因为在平常工作中通常处理的都是数据框，所以这里主要介绍函数<code>apply()</code>的用法。大家可能会觉得很抽象，觉得抽象很正常，因为这几兄弟确实不太接地气，我现在用这些函数几乎每次都得去查帮助文档。回到我们的服装消费者数据。如果我想知道样本中所有数值变量的均值和标准差该怎么办？这在建模前检查数据和建模后展示数据时都经常用到。</p>
<p>记得我们之前通过<code>preProcess()</code>函数对数据进行KNN填补时，需要提取数据框中所有的数值变量用到的是<code>lapply()</code>函数。这里不能用<code>apply()</code>函数是因为<code>apply()</code>函数自动将对象转化成矩阵，这样就会丢失每列的类别信息，而<code>lapply()</code>不会对对象进行转化（这样细微的差别需要常用R渐渐熟悉了才会慢慢了解，我也是写书的时候发现这个，方才请教了一位R高人才明白个中缘由：））。我们再次用该函数选取其中数值型的变量：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)
sdat&lt;-sim.dat[,!<span class="kw">lapply</span>(sim.dat,class)==<span class="st">&quot;factor&quot;</span>]</code></pre></div>
<p>现在的数据框<code>sdat</code>中只包括数值型的变量。这样我们就可以用<code>apply()</code>函数对每列求均值和标准差了：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,function(x) <span class="kw">mean</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp  store_trans 
##       38.840   113543.065     1356.851     2120.181        5.350 
## online_trans           Q1           Q2           Q3           Q4 
##       13.546        3.101        1.823        1.992        2.763 
##           Q5           Q6           Q7           Q8           Q9 
##        2.945        2.448        3.434        2.396        3.085 
##          Q10 
##        2.320</code></pre>
<p>这里我们定义了一个函数<code>function(x) mean(na.omit(x))</code>，这个函数很简单，就是对任何向量求均值同时忽略其中的缺失值。<code>MARGIN=2</code>告诉函数逐列应用定义的函数。如果要计算行均值，只要简单的将margin参数设置为1即可。结果可见，平均说来在线购买次数和消费量都要高于实体店购买。对于10个问卷调查，第二个问题（<code>Q2</code>）平均得分最低。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp  store_trans 
##    16.416818 49842.287197  2774.399785  1731.224308     3.695559 
## online_trans           Q1           Q2           Q3           Q4 
##     7.956959     1.450139     1.168348     1.402106     1.155061 
##           Q5           Q6           Q7           Q8           Q9 
##     1.284377     1.438529     1.455941     1.154347     1.118493 
##          Q10 
##     1.136174</code></pre>
<p>让我们再来看看标准差，代码和计算均值几乎是一样的，只是将均值函数<code>mean()</code>换成标准差函数<code>sd()</code>。虽然在线花费的均值高过实体店花费，但是实体店花费的标准差比在线花费高很多，认真看过本章开头的读者应该知道，这是由于个把土豪在实体店买了上万的衣服。还有问卷调查的第二个问题，虽然之前看到的均值很小，但是标准差也很小，这说明了什么？说明总体对该问题的评分都偏低，如果用于客户分组的话该问题可能不具有太高的区分度。关于这点，我们可以在客户分组那个章节以该数据集为例进行核实。虽然这都是一些简单的统计量，但能够使你在建模前了解更多的关于数据的信息，这对于模型选择和结果解释都有无形的帮助。</p>
</div>
<div id="plyrddply" class="section level3">
<h3><span class="header-section-number">6.2.2</span> plyr包：ddply()函数</h3>
<p>之前讲过一个居家旅行必备神器是<code>caret</code>包，希望大家还记得，这个包实在是太强大了，我们之后会反复用到里面的各个函数，但这里不会详细介绍这个包的所有功能，因为具体介绍R中函数的用法不是本书主要目的，而且关于各种包网上有很多文档材料，如果你真的知道你要对数据做什么，找到相应的R包并在网上查看相应帮助资料学会如何使用并不困难（对于有一定经验的R用来说），但很多时候，我们的问题在于即使不知道该如何解决实际问题，本书的重点是给大家展示数据科学家是如何通过这些技术手段解决问题的，R是一个功能强大的工具，但是手段不是目的。回归主题，现在要再讲第二个必备神器，<code>plyr</code>包。同样我不会详细介绍这个包的用法，而是展示如何用这个包中的ddply()函数帮助我们进行数据分析。还是服装消费者的数据（我知道这很没有创意，但太有创意了老换数据集对你们理解模型方法没有什么好处：）），之前我们都没有用到数据框中的最后一列指明消费者类别的变量<code>segment</code>。已经忘记了消费者类别定义的小伙伴们请回到生成数据的那小节，复习下。有客户分组项目经验的人都知道，在通过聚类（在聚类的章节会说到）得到分组以后，下一件事情就是看看每组客户都是些什么样的人，也就是建立各组客户档案。下面我们就来看看各组客户的人口统计学和消费行为档案吧：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(sim.dat,<span class="st">&quot;segment&quot;</span>,summarize, <span class="dt">Age=</span><span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(age)),<span class="dv">0</span>),
      <span class="dt">FemalePct=</span><span class="kw">round</span>(<span class="kw">mean</span>(gender==<span class="st">&quot;Female&quot;</span>),<span class="dv">2</span>),
      <span class="dt">HouseYes=</span><span class="kw">round</span>(<span class="kw">mean</span>(house==<span class="st">&quot;Yes&quot;</span>),<span class="dv">2</span>),
      <span class="dt">store_exp=</span><span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(store_exp),<span class="dt">trim=</span><span class="fl">0.1</span>),<span class="dv">0</span>),
      <span class="dt">online_exp=</span><span class="kw">round</span>(<span class="kw">mean</span>(online_exp),<span class="dv">0</span>),
      <span class="dt">store_trans=</span><span class="kw">round</span>(<span class="kw">mean</span>(store_trans),<span class="dv">1</span>),
      <span class="dt">online_trans=</span><span class="kw">round</span>(<span class="kw">mean</span>(online_trans),<span class="dv">1</span>))</code></pre></div>
<pre><code>##       segment Age FemalePct HouseYes store_exp online_exp store_trans
## 1 Conspicuous  42      0.32     0.86      4990       4898        10.9
## 2       Price  60      0.45     0.94       501        205         6.1
## 3     Quality  35      0.47     0.34       301       2013         2.9
## 4       Style  24      0.81     0.27       200       1962         3.0
##   online_trans
## 1         11.1
## 2          3.0
## 3         16.0
## 4         21.1</code></pre>
<p>这结果信息量太大了，不过并不奇怪。在实际应用中，真实客户分组是未知的并且分析的目标就是找到这样的组。也就是说在实际客户分组的项目中，这是我们希望的到的分析上的最终结果。在对这个结果进行解读之前，我们先看看上面<code>ddply()</code>代码。函数的第一个参数是数据集（<code>sim.dat</code>），其次是告诉函数要按照哪个分类变量进行总结，这里我们只想对不同类别的消费者进行总结，但也可以是多个变量，如你可以将该参数设置成<code>ddply(sim.dat, c(“segment”,”house”), …)</code>，结果读者试着自行脑补下：）。接下来<code>summarize</code>是说我们希望对数据框分组做总结，你可以设置其它功能比如<code>transform</code>（在组内进行数据变换）和<code>subset</code>（在组内进行数据选择）。接下来分别是：</p>
<ul>
<li><p>Age：计算每组的年龄均值</p></li>
<li><p>FemalePct：计算每组女性的比例</p></li>
<li><p>HouseYes：计算每组内有房的人的比例</p></li>
<li><p>store_exp：计算每组实体店消费均值，这里我们用修剪后的（<code>trim=0.1</code>）均值，因为通过之前的数据探索我们知道这个变量观测有些土豪离群点。</p></li>
<li><p>online_exp：计算每组在线消费均值</p></li>
<li><p>store_trans：计算每组实体店消费次数均值</p></li>
<li><p>online_trans：计算每组在线消费次数均值</p></li>
</ul>
<p>了解这些以后，我们看看消费者群体之间有何不同。</p>
<ul>
<li><p>炫耀性消费（Conspicuous）人群年龄平均40岁左右，基本中年土豪，女性大概占了1/3另外2/3是男性（基本是大叔控的目标），土豪在哪里都买的多，在线消费量和实体店消费量都远大于其他人，在线和实体店消费的量和次数都差不多，反正有钱不在乎在哪买，看到好的就买，有钱任性嘛！基本有房（0.86），剩下14%没房的如果不是由于观点坚决不买房的话，那或许是在北上广这样的地方高不成低不就，买房不够消费有余，这也提醒我们如果这些样本是来自不同城市的话，我们可能还需要收集消费者所在城市的信息，城市的生活水平很大程度上影响了消费行为。</p></li>
<li><p>对价格敏感的人（Price）年龄大（60），基本有房（0.94）这和他们的年龄有关，房奴是后来时代发展的产物。这类人在线消费比其他人都少，还是倾向于在实体店消费（平均在线交易次数是3，而实体店消费次数是6），这也是唯一一类在线消费低于实体店消费的。</p></li>
<li><p>注重服装质量的人（Quality）平均年龄居中，可能和炫耀性消费人群没有显著差别，男女比例基本一半一半。明显偏爱在线消费，消费量和土豪比差远了，但位居其次，估计是中产。有房的人不是很多（0.34），这代人很不幸已经进入房奴的时代。</p></li>
<li><p>风格类（Style），这些无疑是年轻人了，平均年龄只有24，大学生或者刚工作不久的白领，绝大多数是女性（0.81），有房的不多（0.27）或者可以说能完全靠啃老的不多：），也是典型的在线一族，在线购买的次数比Quality和Conspicuous的人多但是消费额却没有他们大。</p></li>
</ul>
<p>这里就提醒我们需要计算平均每次购买的花销，这样可以了解各个群体大概都买什么价位的东西。大家看到没有，分析是一个迭代学习的过程，我们在探索数据的过程中可能会发现一些问题，促使我们去检查某部分数据或者计算一些新的变量，使用新的可视化来探索数据。我们接着用<code>ddply()</code>补充计算这两个统计量：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(sim.dat,<span class="st">&quot;segment&quot;</span>,summarize,<span class="dt">avg_online=</span><span class="kw">round</span>(<span class="kw">sum</span>(online_exp)/<span class="kw">sum</span>(online_trans),<span class="dv">2</span>),
      <span class="dt">avg_store=</span><span class="kw">round</span>(<span class="kw">sum</span>(store_exp)/<span class="kw">sum</span>(store_trans),<span class="dv">2</span>))</code></pre></div>
<pre><code>##       segment avg_online avg_store
## 1 Conspicuous     442.27    479.25
## 2       Price      69.28     81.30
## 3     Quality     126.05    105.12
## 4       Style      92.83    121.07</code></pre>
<p>结果显示价格敏感的人群果然买的价位最低，其次是风格类人群，这些人不一定是对价格敏感，但或许钱包不允许他们买太贵的。注重质量的买的东西价格比风格类的高些，但远不及土豪组，物美价廉的东西毕竟少，这些人可能更看重性价比，不会炫耀性消费但也不会买低质廉价的东西。我们在之后客户分组的时候还会进行类似的总结，那时我们会加上关于问卷调查的回复。大家看到了么，短短的几行代码就可以得到这么有信息量的总结。你可能会说这样的总结通过excel的数据透视表（pivot table）也能完成，但是用R代码要快得多，而且这只是其中一部分功能，如果之前说的，你可以设置其它功能比如<code>transform</code>（在组内进行数据变换）和<code>subset</code>（在组内进行数据选择），并且计算的东西也是可以自己定义。</p>
<p>为了方便，我们按照消费者类别比例随机抽取11个样本，选择3个变量（<code>age</code>，<code>store_exp</code>和<code>segment</code>）用于展示（数据框：<code>examp</code>）。这里用于分层抽样的函数在之后介绍建模辅助技术时会讲到，所以这里不做介绍。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(caret)
<span class="kw">set.seed</span>(<span class="dv">2016</span>)
trainIndex&lt;-<span class="kw">createDataPartition</span>(sim.dat$segment,<span class="dt">p=</span><span class="fl">0.01</span>,<span class="dt">list=</span>F,<span class="dt">times=</span><span class="dv">1</span>)
examp&lt;-sim.dat[trainIndex,<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>,<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;segment&quot;</span>)]</code></pre></div>
<p><code>examp</code>数据集只有11行3列。我们先看看<code>transform</code>设置的作用：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(examp,<span class="st">&quot;segment&quot;</span>,transform,<span class="dt">store_pct=</span><span class="kw">round</span>(store_exp/<span class="kw">sum</span>(store_exp),<span class="dv">2</span>))</code></pre></div>
<pre><code>##    age store_exp     segment store_pct
## 1   42 6319.0718 Conspicuous      0.55
## 2   42 5106.4816 Conspicuous      0.45
## 3   55  595.2520       Price      0.42
## 4   64  399.3550       Price      0.28
## 5   64  426.6653       Price      0.30
## 6   39  362.4795     Quality      0.58
## 7   35  260.5065     Quality      0.42
## 8   23  205.6099       Style      0.25
## 9   24  212.3040       Style      0.26
## 10  24  202.1017       Style      0.25
## 11  28  200.1906       Style      0.24</code></pre>
<p>可以看到，设置<code>transform</code>使得函数对数据集按照指定分类变量（<code>segment</code>）在组内进行数据变换，并将变换后得到的新变量添加到原数据集后。再来看看<code>subset</code>设置：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(examp,<span class="st">&quot;segment&quot;</span>,subset,store_exp&gt;<span class="kw">median</span>(store_exp))</code></pre></div>
<pre><code>##   age store_exp     segment
## 1  42 6319.0718 Conspicuous
## 2  55  595.2520       Price
## 3  39  362.4795     Quality
## 4  23  205.6099       Style
## 5  24  212.3040       Style</code></pre>
<p>上面代码可以获取每个消费者类别（<code>segment</code>）中实体店消费（<code>store_exp</code>）大于该类别中位数的样本。</p>
</div>
<div id="dplyr" class="section level3">
<h3><span class="header-section-number">6.2.3</span> dplyr包</h3>
<p><code>dplyr</code>包是<code>plyr</code>包中的<code>ddply()</code>等函数的强化版，专门处理数据框（dataframe）对象，大幅提高了速度, 并且提供了更稳健的与其它数据库对象间的接口。由于分析中绝大多数是处理数据框，这个包尤其好用。这里我对这个包进行比较详细的介绍。接下来会按顺序介绍该包的几块重要功能：</p>
<ol style="list-style-type: decimal">
<li>数据框显示</li>
<li>数据截选（按行／列）</li>
<li>数据总结</li>
<li>生成新变量</li>
<li>合并数据集</li>
</ol>
<div id="section-6.2.3.1" class="section level4">
<h4><span class="header-section-number">6.2.3.1</span> 数据框显示</h4>
<ul>
<li><code>tbl_df()</code>函数: 能将数据转化成<code>tbl</code>类，这样查看起来更加方便，输出会调整适应当前窗口</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里不展示输出</span>
dplyr::<span class="kw">tbl_df</span>(sim.dat)</code></pre></div>
<ul>
<li><code>glimpse()</code>函数：类似之前的<code>tbl_df()</code>函数，只是转了方向。变量由列变成行。输出结果同样可以自动调整以适应窗口。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里不展示输出</span>
dplyr::<span class="kw">glimpse</span>(sim.dat)</code></pre></div>
</div>
<div id="section-6.2.3.2" class="section level4">
<h4><span class="header-section-number">6.2.3.2</span> 数据截选（按行／列）</h4>
<p>先介绍按行截选。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 提取出满足条件的行：收入大于30万的样本</span>
<span class="kw">library</span>(magrittr)
<span class="kw">library</span>(dplyr)
dplyr::<span class="kw">filter</span>(sim.dat, income &gt;<span class="dv">300000</span>) %&gt;%
dplyr::<span class="kw">tbl_df</span>()</code></pre></div>
<p>这里用到了一个可能大家之间没有见过的操作符号<code>%&gt;%</code>，这是管道操作，其意思是将<code>%&gt;%</code>左边的对象传递给右边的函数，作为第一个选项的设置（或剩下唯一一个选项的设置）。比如：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x %&gt;%<span class="st"> </span><span class="kw">f</span>(y) 等同于 <span class="kw">f</span>(x, y)
y %&gt;%<span class="st"> </span><span class="kw">f</span>(x, ., z) 等同于 <span class="kw">f</span>(x, y, z )</code></pre></div>
<p>管道操作来自于<code>magrittr</code>包，它能够极大简化代码，增加代码可读性。尤其对于<code>dplyr</code>包中的函数操作。大家看下面这段代码，能够知道都干了什么么？</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ave_exp &lt;-<span class="st"> </span><span class="kw">filter</span>( 
  <span class="kw">summarise</span>(
    <span class="kw">group_by</span>( 
      <span class="kw">filter</span>(
        sim.dat, 
        !<span class="kw">is.na</span>(income)
      ), 
      segment
    ), 
    <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
    <span class="dt">n =</span> <span class="kw">n</span>()
  ), 
  n &gt;<span class="st"> </span><span class="dv">200</span>
) </code></pre></div>
<p>再看看用管道操作符进行相同操作的代码：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">avg_exp &lt;-<span class="st"> </span>sim.dat %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(income)) %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">group_by</span>(segment) %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">summarise</span>( 
   <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
   <span class="dt">n =</span> <span class="kw">n</span>() ) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n &gt;<span class="st"> </span><span class="dv">200</span>)</code></pre></div>
<p>用<code>%&gt;%</code>的代码是不是简洁清晰的多？我们从上掉下依次读下代码都干了什么：</p>
<ol style="list-style-type: decimal">
<li>选出数据框<code>sim.dat</code>中收入未缺失的观测</li>
<li>按照<code>segment</code>变量对观测分组</li>
<li>对每组数据求在线消费额的平均值，并赋予新的变量<code>ave_online_exp</code></li>
<li>对每组计算观测个数，赋值为<code>n</code></li>
<li>选出结果中观测个数大于200的行</li>
</ol>
<p>上面代码中用到的一些没有讲到的函数马上就会介绍。 <code>distinct()</code>函数可以删除数据框中重复的行。可以说是<code>unique()</code>函数在数据框上的扩展。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## 删除重复的行
## 这里没有重复的行
dplyr::<span class="kw">distinct</span>(sim.dat)</code></pre></div>
<p><code>sample_frac()</code>函数可以随机选取一定比例的行。<code>sample_n()</code>函数可以随机选取一定数目的行。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">sample_frac</span>(sim.dat, <span class="fl">0.5</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) 
dplyr::<span class="kw">sample_n</span>(sim.dat, <span class="dv">10</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) </code></pre></div>
<p><code>slice()</code>可以选取指定位置的行。和<code>sim.dat[10:15,]</code>类似。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 选取sim.dat的10到15行</span>
dplyr::<span class="kw">slice</span>(sim.dat, <span class="dv">10</span>:<span class="dv">15</span>) </code></pre></div>
<p><code>top_n()</code>可以选取某变量取值最高的若干观测。如果有指定组的话，可以对每组选择相应变量取值最高的观测。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 选取收入最高的两个观测</span>
dplyr::<span class="kw">top_n</span>(sim.dat,<span class="dv">2</span>,income)</code></pre></div>
<p>对列变量的选择使用的是<code>select()</code>函数。下面我展示一些代码，并在相应的注释中指出该代码的功能。大家自己运行下看看结果。更多信息，键入<code>?select</code>查阅该函数的帮助文档。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 通过列名选取变量</span>
<span class="co"># 选取 sim.dat数据框中的income，age和store_exp列</span>
dplyr::<span class="kw">select</span>(sim.dat,income,age,store_exp)
<span class="co"># 选取列名中含有某字符串（_）的列</span>
<span class="co"># 该命令将选取store_exp，online_exp，store_trans和online_trans</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">contains</span>(<span class="st">&quot;_&quot;</span>))
<span class="co"># 选取以某字符串（e）结尾的列</span>
<span class="co"># 结果选取了age，income和house</span>
<span class="co"># 类似的starts_with指以某字符串开始的列</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">ends_with</span>(<span class="st">&quot;e&quot;</span>))
<span class="co"># 选取列Q1，Q2，Q3，Q4和Q5</span>
<span class="kw">select</span>(sim.dat, <span class="kw">num_range</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span>:<span class="dv">5</span>)) 
<span class="co"># 选取列名在某字符串中的列</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">one_of</span>(<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;income&quot;</span>)))
<span class="co"># 选取两个列名之间的列，包含头尾两列</span>
dplyr::<span class="kw">select</span>(sim.dat, age:online_exp)
<span class="co"># 选出出了某列（age）以外的其它列</span>
dplyr::<span class="kw">select</span>(sim.dat, -age)</code></pre></div>
</div>
<div id="section-6.2.3.3" class="section level4">
<h4><span class="header-section-number">6.2.3.3</span> 数据总结</h4>
<p>这里的操作类似于<code>apply()</code>和<code>ddply()</code>， 可以对数据框的每一列进行某个函数操作；或者按照某个分类变量将观测分组，然后对每组观测按列进行函数操作。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 对列online_trans取均值，返回的是一个单一值</span>
dplyr::<span class="kw">summarise</span>(sim.dat, <span class="dt">avg_online =</span> <span class="kw">mean</span>(online_trans)) </code></pre></div>
<pre><code>##   avg_online
## 1     13.546</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 对数据框中的每一列应用函数anyNA()</span>
<span class="co"># 这里可以指定一个函数向量，如c(&quot;anyNA&quot;,&quot;is.factor&quot;)</span>
dplyr::<span class="kw">summarise_each</span>(sim.dat, <span class="kw">funs_</span>(<span class="kw">c</span>(<span class="st">&quot;anyNA&quot;</span>)))</code></pre></div>
<pre><code>##     age gender income house store_exp online_exp store_trans online_trans
## 1 FALSE  FALSE   TRUE FALSE     FALSE      FALSE       FALSE        FALSE
##      Q1    Q2    Q3    Q4    Q5    Q6    Q7    Q8    Q9   Q10 segment
## 1 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE   FALSE</code></pre>
<p>若要根据某分类变量对观测进行分组总结，可以使用<code>group_by()</code>函数。比如：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 对每个消费者类别对应变量应用anyNA()函数</span>
sim.dat %&gt;%<span class="st"> </span><span class="kw">group_by</span>(segment) %&gt;%<span class="st"> </span><span class="kw">summarise_each</span>(<span class="kw">funs_</span>(<span class="kw">c</span>(<span class="st">&quot;anyNA&quot;</span>)))</code></pre></div>
<p>你在数据总结操作中赋予各种总结函数，如<code>mean()</code>，<code>sd()</code>等。但注意这里的总结函数是作用于向量，返回单一值。比如函数<code>is.na()</code>，作用于向量，但返回的也是向量，就不可以在此使用。</p>
</div>
<div id="section-6.2.3.4" class="section level4">
<h4><span class="header-section-number">6.2.3.4</span> 生成新变量</h4>
<p><code>dplyr</code>包中的<code>mutate()</code>函数可以进行列计算，然后将结果添加到原数据集上。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">mutate</span>(sim.dat, <span class="dt">total_exp =</span> store_exp +<span class="st"> </span>online_exp)</code></pre></div>
<p>对每列应用窗口函数，它们作用于一个向量然后返回一个向量。回顾刚才介绍<code>dplyr</code>的总结功能时讲到总结函数作用于一个向量返回一个数值。注意理解这两者的不同。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里的min_rank等价于rank(ties.method = &quot;min&quot;)</span>
<span class="co"># mutate_each()对每列应用指定的窗口函数</span>
dplyr::<span class="kw">mutate_each</span>(sim.dat, <span class="kw">funs</span>(min_rank)) </code></pre></div>
<p><code>transmute()</code>函数和<code>mutate()</code>类似，区别在于它只返回新生成的列，删除原始列。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">transmute</span>(sim.dat, <span class="dt">total_exp =</span> store_exp +<span class="st"> </span>online_exp) </code></pre></div>
<p>这里没有显示代码的结果，大家需要自己操作看看结果，这样对理解学习这些函数很有帮助。关于R中的窗口函数，大家可以自己查找相关资料。熟悉这些常见的函数及其功能，可以提高用R做数据变换的效率（不用总查帮助）。这个过程没有什么技巧可言，纯粹是熟能生巧。</p>
</div>
<div id="section-6.2.3.5" class="section level4">
<h4><span class="header-section-number">6.2.3.5</span> 合并数据集</h4>
<p>这里先随机抽取两个小数据集来展示数据集合并。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x&lt;-<span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="dt">ID=</span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>),<span class="dt">x1=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>)))
y&lt;-<span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="dt">ID=</span><span class="kw">c</span>(<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>,<span class="st">&quot;D&quot;</span>),<span class="dt">y1=</span><span class="kw">c</span>(T,T,F)))
x</code></pre></div>
<pre><code>##   ID x1
## 1  A  1
## 2  B  2
## 3  C  3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y</code></pre></div>
<pre><code>##   ID    y1
## 1  B  TRUE
## 2  C  TRUE
## 3  D FALSE</code></pre>
<p>这里数据框<code>x</code>和<code>y</code>都非常简单，由一个<code>ID</code>变量和各自的观测变量组成。下面我们来介绍各种合并操作。</p>
<ul>
<li><code>left_join()</code>从<code>y</code>到<code>x</code>合并数据。结果保留了数据框<code>x</code>的3行。类似大家可以自行尝试<code>right_join()</code>。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">left_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1   y1
## 1  A  1 &lt;NA&gt;
## 2  B  2 TRUE
## 3  C  3 TRUE</code></pre>
<ul>
<li><code>inner_join()</code>返回的是<code>y</code>和<code>x</code>中都可以匹配的观测。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">inner_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1   y1
## 1  B  2 TRUE
## 2  C  3 TRUE</code></pre>
<ul>
<li><code>full_join()</code>返回的是<code>y</code>或者<code>x</code>中含有的观测。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">full_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID   x1    y1
## 1  A    1  &lt;NA&gt;
## 2  B    2  TRUE
## 3  C    3  TRUE
## 4  D &lt;NA&gt; FALSE</code></pre>
<ul>
<li><code>semi_join()</code>对<code>x</code>中的观测进行筛选，找到那些同时在<code>y</code>中<strong>可以匹配</strong>的观测，但并没有将<code>y</code>的变量<code>y1</code>合并进来。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">semi_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1
## 1  B  2
## 2  C  3</code></pre>
<ul>
<li><code>anti_join()</code>同样对<code>x</code>中的观测进行筛选，找到那些在<code>y</code>中<strong>无法匹配</strong>的观测。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anti_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1
## 1  A  1</code></pre>
<p>此外，<code>dplyr</code>包中还有各种针对数据框的交（<code>intersect()</code>）、并（<code>union()</code>）和补（<code>setdiff()</code>）运算，以及将一个数据框按照行或者列添加到另一个数据框上的操作（<code>bind_rows()</code>，<code>bind_cols()</code>）。这里就不一一介绍，大家自己用一个简单的数据框尝试下。</p>
</div>
</div>
</div>
<div id="section-6.3" class="section level2">
<h2><span class="header-section-number">6.3</span> 数据整形</h2>
<div id="reshape2" class="section level3">
<h3><span class="header-section-number">6.3.1</span> <code>reshape2</code>包</h3>
<p>终于到本章末尾了。之前提到过，如果我们希望有一个新的变量指示购买的渠道（是在线还是实体店），并且将这个变量用于建模，这时就需要对数据进行整形（也称作数据整理，或者揉数据），将在线购买的记录和实体店购买的记录逐行排列而非现在的逐列。我们可以用<code>reshape2</code>包中的相关函数实现这些操作。可能有的读者知道有个包叫做<code>reshape</code>，这是初版，后面的<code>reshape2</code>是重写升级版。这个数据整形的过程确实和揉面团有些类似，先将数据通过<code>melt()</code>函数将数据揉开，然后再通过<code>dcast()</code>函数将数据重塑成想要的形状，为了更清晰的展示函数对数据结构的影响，我们选取其中小部分列，和前5行：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(sdat&lt;-sim.dat[<span class="dv">1</span>:<span class="dv">5</span>,<span class="dv">1</span>:<span class="dv">6</span>])</code></pre></div>
<pre><code>##   age gender   income house store_exp online_exp
## 1  57 Female 120963.4   Yes  529.1344   303.5125
## 2  63 Female 122008.1   Yes  478.0058   109.5297
## 3  59   Male 114202.3   Yes  490.8107   279.2496
## 4  60   Male 113616.3   Yes  347.8090   141.6698
## 5  51   Male 124252.6   Yes  379.6259   112.2372</code></pre>
<p>我们截取的子数据框一共5行，6列。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(mdat &lt;-<span class="st"> </span><span class="kw">melt</span>(sdat, <span class="dt">measure.vars=</span><span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>)))</code></pre></div>
<pre><code>##    age gender   income house   variable    value
## 1   57 Female 120963.4   Yes  store_exp 529.1344
## 2   63 Female 122008.1   Yes  store_exp 478.0058
## 3   59   Male 114202.3   Yes  store_exp 490.8107
## 4   60   Male 113616.3   Yes  store_exp 347.8090
## 5   51   Male 124252.6   Yes  store_exp 379.6259
## 6   57 Female 120963.4   Yes online_exp 303.5125
## 7   63 Female 122008.1   Yes online_exp 109.5297
## 8   59   Male 114202.3   Yes online_exp 279.2496
## 9   60   Male 113616.3   Yes online_exp 141.6698
## 10  51   Male 124252.6   Yes online_exp 112.2372</code></pre>
<p>我们将变量<code>store_exp</code>和<code>online_exp</code>揉合在一起，结果产生了新的两列，一列是变量<code>variable</code>，指代是哪个揉合变量，另外一列是取值<code>value</code>，即变量对应的值。我们也称这样逐行排列的方式称为长数据格式。由于这里我们并没有指定除了要揉合的变量外的id变量，于是函数默认将所有剩下的变量都当作id变量。对于这些变量保留原来对应的观测，只是对<code>store_exp</code>和<code>online_exp</code>分别重复一次。所以得到的结果有10行。如果我们要对消费量（value）建立线性模型，并且考虑购买渠道的效应的话就可以利用揉合后的数据：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里为了展示回归需要更多的数据，所以用原数据框的所有行</span>
mdat&lt;-<span class="kw">melt</span>(sim.dat[,<span class="dv">1</span>:<span class="dv">6</span>], <span class="dt">measure.vars=</span><span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>))
fit&lt;-<span class="kw">lm</span>(value~gender+house+income+variable+age,<span class="dt">data=</span>mdat)
<span class="kw">summary</span>(fit)</code></pre></div>
<pre><code>## 
## Call:
## lm(formula = value ~ gender + house + income + variable + age, 
##     data = mdat)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
##  -4208   -821   -275    533  44353 
## 
## Coefficients:
##                      Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)        -9.132e+02  1.560e+02  -5.855 5.76e-09 ***
## genderMale          3.572e+02  1.028e+02   3.475 0.000524 ***
## houseYes           -5.687e+01  1.138e+02  -0.500 0.617275    
## income              2.834e-02  1.079e-03  26.268  &lt; 2e-16 ***
## variableonline_exp  8.296e+02  9.772e+01   8.489  &lt; 2e-16 ***
## age                -2.793e+01  3.356e+00  -8.321  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1974 on 1626 degrees of freedom
##   (368 observations deleted due to missingness)
## Multiple R-squared:  0.348,  Adjusted R-squared:  0.346 
## F-statistic: 173.5 on 5 and 1626 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>这里<code>lm()</code>函数自动将实体店消费<code>store_exp</code>设置成基准水平，只看对应的系数估计表明，在其它条件不变的情况下，在线购买的人比商店购买的人平均消费高出830元，而且购买渠道的效应非常显著。看到这样的结果，分析师需要考虑建议商家提高网上商城的购物体验，采取一些手段改变那些实体店为主的消费者改变消费习惯。当然，当靠一个线性回归系数就作出这样的建议有些仓促，还需要对模型的可靠性进行进一步检查。下一章就会讲到模型选择和评估。</p>
<p>如果我们将<code>house</code>和<code>gender</code>指定为id变量，结果为：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里用所用的数据</span>
<span class="co"># 缺失值填补</span>
demo_imp&lt;-<span class="kw">impute</span>(sim.dat,<span class="dt">method=</span><span class="st">&quot;median/mode&quot;</span>)
mdat &lt;-<span class="st"> </span><span class="kw">melt</span>(demo_imp, <span class="dt">measure.vars=</span><span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>),<span class="dt">id.vars=</span><span class="kw">c</span>(<span class="st">&quot;house&quot;</span>,<span class="st">&quot;gender&quot;</span>))
<span class="kw">head</span>(mdat)</code></pre></div>
<pre><code>##   house gender  variable    value
## 1   Yes Female store_exp 529.1344
## 2   Yes Female store_exp 478.0058
## 3   Yes   Male store_exp 490.8107
## 4   Yes   Male store_exp 347.8090
## 5   Yes   Male store_exp 379.6259
## 6   Yes   Male store_exp 338.3154</code></pre>
<p><code>melt()</code>函数不仅能揉合数据框，还能揉合列表，矩阵，表格等。感兴趣的小伙伴可以自己在网上找相关的介绍，很容易找到案例代码，自己一步一步跟着运行一遍就很清楚了。这里揉合数据是为了建模需要，有的时候是为了进一步重塑数据结构。好比把一个积木房子拆开重新盖一个新的造型。这就要用到该包的第二个重要函数<code>dcast()</code>（这是升级版中的函数，初级版本的<code>reshape</code>包对应的是<code>cast()</code>函数）。比如，如果想知道对于有房和没有房的男性和女性，在线消费和实体店消费的总额分别是多少：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dcast</span>(mdat, house+gender~<span class="st"> </span>variable, sum)</code></pre></div>
<pre><code>##   house gender store_exp online_exp
## 1    No Female  171102.2   583492.4
## 2    No   Male  133130.8   332499.9
## 3   Yes Female  355320.2   500856.9
## 4   Yes   Male  697297.3   703332.0</code></pre>
<p>上面代码中<code>~</code>左边是你用来划分数据框的id变量，这里是<code>house</code>和<code>gender</code>，右边是你计算根据的变量（也必须是分类变量），真正用于计算的数值是你之前揉合过程中生成的<code>value</code>那列值。这两个函数确实不太好理解，大家需要对一个数据框自己实际操作才能真正理解。</p>
</div>
<div id="tidyr" class="section level3">
<h3><span class="header-section-number">6.3.2</span> <code>tidyr</code>包</h3>
<p>R中还有一个能够用于数据整形的包<code>tidyr</code>。下面我们截取一个小数据框(<code>sdat</code>)展示包中一些主要函数的功能。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sdat&lt;-sim.dat[<span class="dv">1</span>:<span class="dv">5</span>,]%&gt;%
<span class="st">  </span>dplyr::<span class="kw">select</span>(age,gender,store_exp,store_trans)
sdat %&gt;%<span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<p>首先是<code>gather()</code>函数。它的作用类似于<code>reshape2</code>中的<code>melt()</code>。下面这条命令的结果和<code>melt(sdat, measure.vars=c(&quot;store_exp&quot;,&quot;store_trans&quot;))</code>是一样的。其中<code>variable</code>和<code>value</code>是自定义的揉合生成的两列新变量的名字。<code>variable</code>列对应原数据中参与揉合的变量名，<code>value</code>列是参与揉合的变量的取值。<code>store_exp,store_trans</code>告诉R对那些变量进行揉合。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msdat&lt;-tidyr::<span class="kw">gather</span>(sdat,<span class="st">&quot;variable&quot;</span>,<span class="st">&quot;value&quot;</span>,store_exp,store_trans)
msdat %&gt;%<span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<p>如果用我们之前讲到的管道操作，上面代码可以等价的写成：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 这里不显示输出结果</span>
sdat%&gt;%<span class="kw">gather</span>(<span class="st">&quot;variable&quot;</span>,<span class="st">&quot;value&quot;</span>,store_exp,store_trans)</code></pre></div>
<p>和<code>gather()</code>相反的是<code>spread()</code>，前者将不同的列堆叠起来，后者将同一列分开。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msdat %&gt;%<span class="st"> </span><span class="kw">spread</span>(variable,value)</code></pre></div>
<pre><code>##   age gender store_exp store_trans
## 1  51   Male  379.6259           4
## 2  57 Female  529.1344           2
## 3  59   Male  490.8107           7
## 4  60   Male  347.8090          10
## 5  63 Female  478.0058           4</code></pre>
<p><code>tidyr</code>包中还有另外两个互补的函数，<code>separate()</code>和<code>unite()</code>。<code>separate()</code>函数可以将不同列分开成为多列。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sepdat&lt;-<span class="st"> </span>msdat %&gt;%<span class="st"> </span><span class="kw">separate</span>(variable,<span class="kw">c</span>(<span class="st">&quot;Source&quot;</span>,<span class="st">&quot;Type&quot;</span>))
sepdat %&gt;%<span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<p>可以看到，原来的变量<code>variable</code>被分成了两部分：<code>Source</code>和<code>Type</code>。你可以通过设置<code>sep=</code>来自定义用于划分字符的正则表达，默认是所有非字母和数字的字符。比如这里的“_”。</p>
<p>与<code>separate()</code>相反的函数是<code>unite()</code>， 它能将不同的列合并在一起。类似于<code>paste()</code>函数的数据框版本。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sepdat %&gt;%<span class="st"> </span><span class="kw">unite</span>(<span class="st">&quot;variable&quot;</span>,Source,Type,<span class="dt">sep=</span><span class="st">&quot;_&quot;</span>)</code></pre></div>
<pre><code>##    age gender    variable    value
## 1   57 Female   store_exp 529.1344
## 2   63 Female   store_exp 478.0058
## 3   59   Male   store_exp 490.8107
## 4   60   Male   store_exp 347.8090
## 5   51   Male   store_exp 379.6259
## 6   57 Female store_trans   2.0000
## 7   63 Female store_trans   4.0000
## 8   59   Male store_trans   7.0000
## 9   60   Male store_trans  10.0000
## 10  51   Male store_trans   4.0000</code></pre>
<p>上面的代码将原先分开的两列又合并回去了，并赋予的和之前一样的列名<code>&quot;variable&quot;</code>。</p>
<p>整形这部分可能是数据处理变换中最复杂的，这种复杂和证明数学定理不同，主要是需要时间熟悉。更像一门手艺，所以大家要发扬手艺人精神，多使用这些函数，把数据当面团一样揉来揉去的，也挺好玩的，不是么？觉得R太难有些犹豫需不需要学习的小伙伴们，<strong>磨刀不误砍柴工</strong>，再一次中国的老古话放在那里闪闪发光的有木有？</p>
</div>
</div>
<div id="-1" class="section level2">
<h2><span class="header-section-number">6.4</span> 本章总结</h2>
<p>本章介绍数操作的方法，以及R中能够进行相应高效数据操作的包。</p>
<ul>
<li><p>在介绍<code>tibble</code>的小节，我们学习了如何将传统数据框转化为<code>tibble</code>格式，这两种格式有什么不同，大家可以根据情况选择更利于之后分析过程的格式。</p></li>
<li><p>在数据读写的部分，我们介绍了一个新的包<code>readr</code>，这个包和基础包中的导入函数相比，在数据量大时效率显著提高，更重要的是它给你数据导入的进度条。此外，我们还介绍了一些处理特殊数据类型的方法，比如时间，介绍正则表达和因子变量的处理。</p></li>
<li><p>整合方法类似于excel中的透视表格，R中有一些功能强大的函数能够有效的进行各种数据整合。我们介绍了<code>base</code>包中的<code>apply()</code>函数，还有更加高级灵活的<code>plyr</code>包中<code>ddply()</code>函数的各种用法。由于实际工作中大部分时间是处理数据框，所以这里我们介绍了<code>plyr</code>包的一个专门针对数据框的强化包<code>dplyr</code>。该包对于数据的整合非常高效。</p></li>
</ul>
<p>－ 对于数据的整形（长型数据和宽型数据的转换），我们举例说明了由于模型需要将数据从宽型转化成长型的情况，并且用<code>reshape2</code>包实现了该过程。此外我们还介绍了另外一个数据整形的包<code>tidyr</code>，该包可以进行数据变量揉合，拆分，合并；还可以进行数据框的各种合并。</p>
<p>这些包的使用需要一些时间学习，实践尤其重要，大家需要多花功夫熟悉这些的操作，这是数据科学家的基本技能。这里说的“熟悉”是指成为第二天性，再应用时不需要占用大脑的工作记忆。</p>

</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-xml2014">
<p>14. Nolan, D., Lang, D.T.: XML and web technologies for data sciences with r. Springer (2014).</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="section-5.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="section-7.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/06-shujuchaozuo.Rmd",
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
