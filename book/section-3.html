<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>数据科学家：R语言</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="This is my first book on data science">
  <meta name="generator" content="bookdown 0.1 and GitBook 2.6.7">

  <meta property="og:title" content="数据科学家：R语言" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is my first book on data science" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="数据科学家：R语言" />
  
  <meta name="twitter:description" content="This is my first book on data science" />
  

<meta name="author" content="林荟">

<meta name="date" content="2016-12-11">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="section-2.html">
<link rel="next" href="section-4.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">数据科学家：R语言</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> 介绍</a></li>
<li class="chapter" data-level="2" data-path="section-2.html"><a href="section-2.html"><i class="fa fa-check"></i><b>2</b> 数据科学</a><ul>
<li class="chapter" data-level="2.1" data-path="section-2.html"><a href="section-2.html#section-2.1"><i class="fa fa-check"></i><b>2.1</b> 什么是数据科学？</a></li>
<li class="chapter" data-level="2.2" data-path="section-2.html"><a href="section-2.html#section-2.2"><i class="fa fa-check"></i><b>2.2</b> 什么是数据科学家？</a></li>
<li class="chapter" data-level="2.3" data-path="section-2.html"><a href="section-2.html#section-2.3"><i class="fa fa-check"></i><b>2.3</b> 数据科学家需要的技能</a></li>
<li class="chapter" data-level="2.4" data-path="section-2.html"><a href="section-2.html#section-2.4"><i class="fa fa-check"></i><b>2.4</b> 数据科学可以解决什么问题？</a><ul>
<li class="chapter" data-level="2.4.1" data-path="section-2.html"><a href="section-2.html#section-2.4.1"><i class="fa fa-check"></i><b>2.4.1</b> 前提要求</a></li>
<li class="chapter" data-level="2.4.2" data-path="section-2.html"><a href="section-2.html#section-2.4.2"><i class="fa fa-check"></i><b>2.4.2</b> 问题种类</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="section-3.html"><a href="section-3.html"><i class="fa fa-check"></i><b>3</b> 数据集模拟和背景介绍</a><ul>
<li class="chapter" data-level="3.1" data-path="section-3.html"><a href="section-3.html#section-3.1"><i class="fa fa-check"></i><b>3.1</b> 服装消费者数据</a></li>
<li class="chapter" data-level="3.2" data-path="section-3.html"><a href="section-3.html#section-3.2"><i class="fa fa-check"></i><b>3.2</b> 航空公司满意度调查</a></li>
<li class="chapter" data-level="3.3" data-path="section-3.html"><a href="section-3.html#section-3.3"><i class="fa fa-check"></i><b>3.3</b> 生猪疫情风险预测数据</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="section-4.html"><a href="section-4.html"><i class="fa fa-check"></i><b>4</b> 数据分析一般流程</a><ul>
<li class="chapter" data-level="4.1" data-path="section-4.html"><a href="section-4.html#section-4.1"><i class="fa fa-check"></i><b>4.1</b> 问题到数据</a></li>
<li class="chapter" data-level="4.2" data-path="section-4.html"><a href="section-4.html#section-4.2"><i class="fa fa-check"></i><b>4.2</b> 数据到信息</a></li>
<li class="chapter" data-level="4.3" data-path="section-4.html"><a href="section-4.html#section-4.3"><i class="fa fa-check"></i><b>4.3</b> 信息到行动</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="section-5.html"><a href="section-5.html"><i class="fa fa-check"></i><b>5</b> 数据预处理</a><ul>
<li class="chapter" data-level="5.1" data-path="section-5.html"><a href="section-5.html#section-5.1"><i class="fa fa-check"></i><b>5.1</b> 介绍</a></li>
<li class="chapter" data-level="5.2" data-path="section-5.html"><a href="section-5.html#section-5.2"><i class="fa fa-check"></i><b>5.2</b> 数据清理</a></li>
<li class="chapter" data-level="5.3" data-path="section-5.html"><a href="section-5.html#section-5.3"><i class="fa fa-check"></i><b>5.3</b> 缺失值填补</a><ul>
<li class="chapter" data-level="5.3.1" data-path="section-5.html"><a href="section-5.html#section-5.3.1"><i class="fa fa-check"></i><b>5.3.1</b> 中位数或众数填补</a></li>
<li class="chapter" data-level="5.3.2" data-path="section-5.html"><a href="section-5.html#k-"><i class="fa fa-check"></i><b>5.3.2</b> K-近邻填补</a></li>
<li class="chapter" data-level="5.3.3" data-path="section-5.html"><a href="section-5.html#section-5.3.3"><i class="fa fa-check"></i><b>5.3.3</b> 袋状树填补</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="section-5.html"><a href="section-5.html#section-5.4"><i class="fa fa-check"></i><b>5.4</b> 中心化和标量化</a></li>
<li class="chapter" data-level="5.5" data-path="section-5.html"><a href="section-5.html#section-5.5"><i class="fa fa-check"></i><b>5.5</b> 有偏分布</a></li>
<li class="chapter" data-level="5.6" data-path="section-5.html"><a href="section-5.html#section-5.6"><i class="fa fa-check"></i><b>5.6</b> 处理离群点</a></li>
<li class="chapter" data-level="5.7" data-path="section-5.html"><a href="section-5.html#section-5.7"><i class="fa fa-check"></i><b>5.7</b> 共线性</a></li>
<li class="chapter" data-level="5.8" data-path="section-5.html"><a href="section-5.html#section-5.8"><i class="fa fa-check"></i><b>5.8</b> 稀疏变量</a></li>
<li class="chapter" data-level="5.9" data-path="section-5.html"><a href="section-5.html#section-5.9"><i class="fa fa-check"></i><b>5.9</b> 编码名义变量</a></li>
<li class="chapter" data-level="5.10" data-path="section-5.html"><a href="section-5.html#section-5.10"><i class="fa fa-check"></i><b>5.10</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="section-6.html"><a href="section-6.html"><i class="fa fa-check"></i><b>6</b> 数据操作</a><ul>
<li class="chapter" data-level="6.1" data-path="section-6.html"><a href="section-6.html#section-6.1"><i class="fa fa-check"></i><b>6.1</b> 数据读写</a><ul>
<li class="chapter" data-level="6.1.1" data-path="section-6.html"><a href="section-6.html#tibble"><i class="fa fa-check"></i><b>6.1.1</b> 取代传统数据框的<code>tibble</code>对象</a></li>
<li class="chapter" data-level="6.1.2" data-path="section-6.html"><a href="section-6.html#readr"><i class="fa fa-check"></i><b>6.1.2</b> 高效数据读写：<code>readr</code>包</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="section-6.html"><a href="section-6.html#section-6.2"><i class="fa fa-check"></i><b>6.2</b> 数据整合</a><ul>
<li class="chapter" data-level="6.2.1" data-path="section-6.html"><a href="section-6.html#baseapply"><i class="fa fa-check"></i><b>6.2.1</b> base包：apply()</a></li>
<li class="chapter" data-level="6.2.2" data-path="section-6.html"><a href="section-6.html#plyrddply"><i class="fa fa-check"></i><b>6.2.2</b> plyr包：ddply()函数</a></li>
<li class="chapter" data-level="6.2.3" data-path="section-6.html"><a href="section-6.html#dplyr"><i class="fa fa-check"></i><b>6.2.3</b> dplyr包</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="section-6.html"><a href="section-6.html#section-6.3"><i class="fa fa-check"></i><b>6.3</b> 数据整形</a><ul>
<li class="chapter" data-level="6.3.1" data-path="section-6.html"><a href="section-6.html#reshape2"><i class="fa fa-check"></i><b>6.3.1</b> <code>reshape2</code>包</a></li>
<li class="chapter" data-level="6.3.2" data-path="section-6.html"><a href="section-6.html#tidyr"><i class="fa fa-check"></i><b>6.3.2</b> <code>tidyr</code>包</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="section-6.html"><a href="section-6.html#-1"><i class="fa fa-check"></i><b>6.4</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="section-7.html"><a href="section-7.html"><i class="fa fa-check"></i><b>7</b> 基础建模技术</a><ul>
<li class="chapter" data-level="7.1" data-path="section-7.html"><a href="section-7.html#section-7.1"><i class="fa fa-check"></i><b>7.1</b> 有监督和无监督</a></li>
<li class="chapter" data-level="7.2" data-path="section-7.html"><a href="section-7.html#section-7.2"><i class="fa fa-check"></i><b>7.2</b> 误差及其来源</a><ul>
<li class="chapter" data-level="7.2.1" data-path="section-7.html"><a href="section-7.html#section-7.2.1"><i class="fa fa-check"></i><b>7.2.1</b> 系统误差和随机误差</a></li>
<li class="chapter" data-level="7.2.2" data-path="section-7.html"><a href="section-7.html#section-7.2.2"><i class="fa fa-check"></i><b>7.2.2</b> 应变量误差</a></li>
<li class="chapter" data-level="7.2.3" data-path="section-7.html"><a href="section-7.html#section-7.2.3"><i class="fa fa-check"></i><b>7.2.3</b> 自变量误差</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="section-7.html"><a href="section-7.html#section-7.3"><i class="fa fa-check"></i><b>7.3</b> 数据划分和再抽样</a><ul>
<li class="chapter" data-level="7.3.1" data-path="section-7.html"><a href="section-7.html#section-7.3.1"><i class="fa fa-check"></i><b>7.3.1</b> 划分训练集和测试集</a></li>
<li class="chapter" data-level="7.3.2" data-path="section-7.html"><a href="section-7.html#section-7.3.2"><i class="fa fa-check"></i><b>7.3.2</b> 重抽样</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="section-7.html"><a href="section-7.html#-2"><i class="fa fa-check"></i><b>7.4</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="section-8.html"><a href="section-8.html"><i class="fa fa-check"></i><b>8</b> 模型评估度量</a><ul>
<li class="chapter" data-level="8.1" data-path="section-8.html"><a href="section-8.html#section-8.1"><i class="fa fa-check"></i><b>8.1</b> 回归模型评估度量</a></li>
<li class="chapter" data-level="8.2" data-path="section-8.html"><a href="section-8.html#section-8.2"><i class="fa fa-check"></i><b>8.2</b> 分类模型评估度量</a><ul>
<li class="chapter" data-level="8.2.1" data-path="section-8.html"><a href="section-8.html#kappa"><i class="fa fa-check"></i><b>8.2.1</b> Kappa统计量</a></li>
<li class="chapter" data-level="8.2.2" data-path="section-8.html"><a href="section-8.html#roc"><i class="fa fa-check"></i><b>8.2.2</b> ROC曲线</a></li>
<li class="chapter" data-level="8.2.3" data-path="section-8.html"><a href="section-8.html#section-8.2.3"><i class="fa fa-check"></i><b>8.2.3</b> 提升图</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="section-8.html"><a href="section-8.html#-3"><i class="fa fa-check"></i><b>8.3</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="section-9.html"><a href="section-9.html"><i class="fa fa-check"></i><b>9</b> 特征工程</a><ul>
<li class="chapter" data-level="9.1" data-path="section-9.html"><a href="section-9.html#section-9.1"><i class="fa fa-check"></i><b>9.1</b> 特征构建</a></li>
<li class="chapter" data-level="9.2" data-path="section-9.html"><a href="section-9.html#section-9.2"><i class="fa fa-check"></i><b>9.2</b> 特征提取</a><ul>
<li class="chapter" data-level="9.2.1" data-path="section-9.html"><a href="section-9.html#section-9.2.1"><i class="fa fa-check"></i><b>9.2.1</b> 初步探索数据</a></li>
<li class="chapter" data-level="9.2.2" data-path="section-9.html"><a href="section-9.html#section-9.2.2"><i class="fa fa-check"></i><b>9.2.2</b> 主成分分析</a></li>
<li class="chapter" data-level="9.2.3" data-path="section-9.html"><a href="section-9.html#section-9.2.3"><i class="fa fa-check"></i><b>9.2.3</b> 探索性因子分析</a></li>
<li class="chapter" data-level="9.2.4" data-path="section-9.html"><a href="section-9.html#section-9.2.4"><i class="fa fa-check"></i><b>9.2.4</b> 高维标度化</a></li>
<li class="chapter" data-level="9.2.5" data-path="section-9.html"><a href="section-9.html#section-9.2.5"><i class="fa fa-check"></i><b>9.2.5</b> 知识扩展</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="section-9.html"><a href="section-9.html#section-9.3"><i class="fa fa-check"></i><b>9.3</b> 特征选择</a><ul>
<li class="chapter" data-level="9.3.1" data-path="section-9.html"><a href="section-9.html#section-9.3.1"><i class="fa fa-check"></i><b>9.3.1</b> 过滤法</a></li>
<li class="chapter" data-level="9.3.2" data-path="section-9.html"><a href="section-9.html#section-9.3.2"><i class="fa fa-check"></i><b>9.3.2</b> 绕封法</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="section-10.html"><a href="section-10.html"><i class="fa fa-check"></i><b>10</b> 线性回归极其衍生</a><ul>
<li class="chapter" data-level="10.1" data-path="section-10.html"><a href="section-10.html#section-10.1"><i class="fa fa-check"></i><b>10.1</b> 普通线性回归</a><ul>
<li class="chapter" data-level="10.1.1" data-path="section-10.html"><a href="section-10.html#section-10.1.1"><i class="fa fa-check"></i><b>10.1.1</b> 最小二乘线性模型</a></li>
<li class="chapter" data-level="10.1.2" data-path="section-10.html"><a href="section-10.html#section-10.1.2"><i class="fa fa-check"></i><b>10.1.2</b> 回归诊断</a></li>
<li class="chapter" data-level="10.1.3" data-path="section-10.html"><a href="section-10.html#section-10.1.3"><i class="fa fa-check"></i><b>10.1.3</b> 离群点，高杠杆点和强影响点</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="section-10.html"><a href="section-10.html#section-10.2"><i class="fa fa-check"></i><b>10.2</b> 收缩方法</a><ul>
<li class="chapter" data-level="10.2.1" data-path="section-10.html"><a href="section-10.html#section-10.2.1"><i class="fa fa-check"></i><b>10.2.1</b> 岭回归</a></li>
<li class="chapter" data-level="10.2.2" data-path="section-10.html"><a href="section-10.html#lasso"><i class="fa fa-check"></i><b>10.2.2</b> Lasso</a></li>
<li class="chapter" data-level="10.2.3" data-path="section-10.html"><a href="section-10.html#section-10.2.3"><i class="fa fa-check"></i><b>10.2.3</b> 弹性网络</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="section-10.html"><a href="section-10.html#lasso"><i class="fa fa-check"></i><b>10.3</b> 知识扩展：Lasso的变量选择功能</a></li>
<li class="chapter" data-level="10.4" data-path="section-10.html"><a href="section-10.html#section-10.4"><i class="fa fa-check"></i><b>10.4</b> 主成分和偏最小二乘回归</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="section-11.html"><a href="section-11.html"><i class="fa fa-check"></i><b>11</b> 广义线性模型压缩方法</a><ul>
<li class="chapter" data-level="11.1" data-path="section-11.html"><a href="section-11.html#glmnet"><i class="fa fa-check"></i><b>11.1</b> 初识<code>glmnet</code></a></li>
<li class="chapter" data-level="11.2" data-path="section-11.html"><a href="section-11.html#section-11.2"><i class="fa fa-check"></i><b>11.2</b> 收缩线性回归</a></li>
<li class="chapter" data-level="11.3" data-path="section-11.html"><a href="section-11.html#section-11.3"><i class="fa fa-check"></i><b>11.3</b> 逻辑回归</a><ul>
<li class="chapter" data-level="11.3.1" data-path="section-11.html"><a href="section-11.html#section-11.3.1"><i class="fa fa-check"></i><b>11.3.1</b> 普通逻辑回归</a></li>
<li class="chapter" data-level="11.3.2" data-path="section-11.html"><a href="section-11.html#section-11.3.2"><i class="fa fa-check"></i><b>11.3.2</b> 收缩逻辑回归</a></li>
<li class="chapter" data-level="11.3.3" data-path="section-10.html"><a href="section-10.html#lasso"><i class="fa fa-check"></i><b>11.3.3</b> 知识扩展：群组lasso逻辑回归</a></li>
</ul></li>
<li class="chapter" data-level="11.4" data-path="section-11.html"><a href="section-11.html#section-11.4"><i class="fa fa-check"></i><b>11.4</b> 收缩多项回归</a></li>
<li class="chapter" data-level="11.5" data-path="section-11.html"><a href="section-11.html#section-11.5"><i class="fa fa-check"></i><b>11.5</b> 泊松收缩回归</a></li>
<li class="chapter" data-level="11.6" data-path="section-11.html"><a href="section-11.html#-4"><i class="fa fa-check"></i><b>11.6</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="section-12.html"><a href="section-12.html"><i class="fa fa-check"></i><b>12</b> 树模型</a><ul>
<li class="chapter" data-level="12.1" data-path="section-12.html"><a href="section-12.html#section-12.1"><i class="fa fa-check"></i><b>12.1</b> 分裂准则</a></li>
<li class="chapter" data-level="12.2" data-path="section-12.html"><a href="section-12.html#section-12.2"><i class="fa fa-check"></i><b>12.2</b> 树的修剪</a></li>
<li class="chapter" data-level="12.3" data-path="section-12.html"><a href="section-12.html#section-12.3"><i class="fa fa-check"></i><b>12.3</b> 回归树和决策树</a><ul>
<li class="chapter" data-level="12.3.1" data-path="section-12.html"><a href="section-12.html#section-12.3.1"><i class="fa fa-check"></i><b>12.3.1</b> 回归树</a></li>
<li class="chapter" data-level="12.3.2" data-path="section-12.html"><a href="section-12.html#section-12.3.2"><i class="fa fa-check"></i><b>12.3.2</b> 决策树</a></li>
</ul></li>
<li class="chapter" data-level="12.4" data-path="section-12.html"><a href="section-12.html#section-12.4"><i class="fa fa-check"></i><b>12.4</b> 装袋树</a></li>
<li class="chapter" data-level="12.5" data-path="section-12.html"><a href="section-12.html#section-12.5"><i class="fa fa-check"></i><b>12.5</b> 随机森林</a></li>
<li class="chapter" data-level="12.6" data-path="section-12.html"><a href="section-12.html#section-12.6"><i class="fa fa-check"></i><b>12.6</b> 助推法</a></li>
<li class="chapter" data-level="12.7" data-path="section-12.html"><a href="section-12.html#section-12.7"><i class="fa fa-check"></i><b>12.7</b> 知识扩展：助推法的可加模型框架</a></li>
<li class="chapter" data-level="12.8" data-path="section-12.html"><a href="section-12.html#section-12.8"><i class="fa fa-check"></i><b>12.8</b> 知识扩展：助推树的数学框架</a><ul>
<li class="chapter" data-level="12.8.1" data-path="section-12.html"><a href="section-12.html#section-12.8.1"><i class="fa fa-check"></i><b>12.8.1</b> 数学表达</a></li>
<li class="chapter" data-level="12.8.2" data-path="section-12.html"><a href="section-12.html#section-12.8.2"><i class="fa fa-check"></i><b>12.8.2</b> 梯度助推数值优化</a></li>
</ul></li>
<li class="chapter" data-level="12.9" data-path="section-12.html"><a href="section-12.html#-5"><i class="fa fa-check"></i><b>12.9</b> 本章总结</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="section-13.html"><a href="section-13.html"><i class="fa fa-check"></i><b>13</b> 深度学习</a><ul>
<li class="chapter" data-level="13.1" data-path="section-6.html"><a href="section-6.html#-1"><i class="fa fa-check"></i><b>13.1</b> 介绍</a></li>
<li class="chapter" data-level="13.2" data-path="section-13.html"><a href="section-13.html#r"><i class="fa fa-check"></i><b>13.2</b> R中深度学习包</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>14</b> References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">数据科学家：R语言</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="section-3" class="section level1">
<h1><span class="header-section-number">第3章</span> 数据集模拟和背景介绍</h1>
<p>之后的章节将通过案例讨论建模的各个方面。在进入正题之前，我先用本章介绍书中使用的数据，包括模拟数据的代码，数据的获取以及数据语境背景。很多R包里有现成的数据，网上也有各种机器学习竞赛的数据，但本书用来展示模型的数据大部分是通过R得到的模拟数据集。其原因我在第<a href="index.html#intro">1</a>章开始已经讲过了。</p>
<div id="section-3.1" class="section level2">
<h2><span class="header-section-number">3.1</span> 服装消费者数据</h2>
<p>我们先模拟一个关于某品牌服装消费者的数据，这个数据会在之后的章节中反复用到。数据中包含N=1000个观测，我们将模拟3类变量（括号内是变量对应的模拟数据框中的列标签名）：</p>
<p>（1）人口统计学变量。</p>
<ul>
<li>年龄（age）</li>
<li>性别（gender）</li>
<li>有房还是租房（house）</li>
</ul>
<p>（2）消费者行为变量。</p>
<ul>
<li>2015年实体店购买该品牌服装花销（store_exp）</li>
<li>2015年在线购买该品牌服装花销（online_exp）</li>
<li>2015年实体店交易次数（store_trans）</li>
<li>2015年在线交易次数（online_trans）</li>
</ul>
<p>（3）客户认知问卷调查。为了进一步了解消费者，商家时常对消费者进行问卷调查，然后对调查结果进行分组，其目标是寻找在产品兴趣，市场参与度或营销反应的重要方面有显著差异的客户群。通过了解组间的不同，市场营销人员可以优化产品定位，进行更加精准的营销。这里我们假设该服装品牌对消费者进行了下面的调查，并模拟该调查问卷的回复。</p>
<p>你是否同意下面的申明？</p>
<table>
<thead>
<tr class="header">
<th>问题</th>
<th align="left">1（非常不同意）</th>
<th align="left">2（有点不同意）</th>
<th align="left">3（中立/不知道）</th>
<th align="left">4（有点同意）</th>
<th align="left">5（非常同意）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>（Q1）：我喜欢买不同品牌的服装，比较它们</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td>（Q2）：我喜欢买同一个品牌的服装</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td>（Q3）：品牌的知名度对我来说非常重要</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td>（Q4）：服装质量对我来说非常重要</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td>（Q5）：我有特定喜欢的风格</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td>（Q6）：我喜欢在实体店购买</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td>（Q7）：我喜欢在网上购买</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td>（Q8）：价格对我来说很重要</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td>（Q9）：我喜欢不同风格的衣服</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td>（Q10）：我喜欢自己挑选服装，不需要周围人的建议</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>我们进一步假设这些根据问卷调查的结果可以将消费者分成4组：价格敏感（Price），炫耀性消费（Conspicuous），质量（Quality），风格（Style）。 （本章我们不会提到如何得到这些分组；我们假设这些已知。我们会在第9章中介绍聚类分析时会更详细的说明。）</p>
<p>你也可以重复下面的代码，自己创建该数据。我们强烈建议读者重复数据模拟的过程，这样能加深对模型方法的理解。如果你对此不感兴趣，也可以从本书网站上直接下载数据：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)</code></pre></div>
<p>获得该数据集后你可以跳过本小节后半部分直接跳到下一节对分析流程的讲解。否则，继续本节。</p>
<p>模拟该数据的过程有些复杂，我们先模拟描述客户的变量。模拟该数据的代码分为3部分：</p>
<ol style="list-style-type: decimal">
<li>定义数据结构：定义变量名，变量类型，消费者分组名，各组大小。</li>
<li>变量分布参数，如各自的均值和方差。</li>
<li>在各组和各个变量上迭代，基于定义和参数设置抽取随机数。</li>
</ol>
<p>通过这种方式组织代码，如果我们要改变部分模拟方式重新抽取数据就比较容易。例如，如果我们想要加一个组，或者改变其中某个人口统计变量的均值，只要稍微改变代码就好。我们也想通过这个结构介绍新的R代码，生成数据的第3个步骤中将用到这些代码。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 设置随机种子，使数据模拟过程可重复</span>
<span class="kw">set.seed</span>(<span class="dv">12345</span>)
<span class="co"># 定义观测数目</span>
ncust&lt;-<span class="dv">1000</span>
<span class="co"># 建立数据框存放模拟观测，初始数据框中只有一列id，即消费者编号</span>
seg_dat&lt;-<span class="kw">data.frame</span>(<span class="dt">id=</span><span class="kw">as.factor</span>(<span class="kw">c</span>(<span class="dv">1</span>:ncust)))
<span class="co"># 指定要生成的变量，并为变量命名</span>
vars&lt;-<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>,<span class="st">&quot;gender&quot;</span>,<span class="st">&quot;income&quot;</span>,<span class="st">&quot;house&quot;</span>,<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>,<span class="st">&quot;store_trans&quot;</span>,<span class="st">&quot;online_trans&quot;</span>)
<span class="co"># 每个变量对应的数据类型</span>
<span class="co"># norm： 正态分布</span>
<span class="co"># binom: 二项分布</span>
<span class="co"># pois： 泊松分布</span>
vartype&lt;-<span class="kw">c</span>(<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;binom&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;binom&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;pois&quot;</span>,<span class="st">&quot;pois&quot;</span>)
<span class="co"># 四个消费者分组的名称</span>
group_name&lt;-<span class="kw">c</span>(<span class="st">&quot;Price&quot;</span>,<span class="st">&quot;Conspicuous&quot;</span>,<span class="st">&quot;Quality&quot;</span>,<span class="st">&quot;Style&quot;</span>)
<span class="co"># 各消费者群组的大小</span>
group_size&lt;-<span class="kw">c</span>(<span class="dv">250</span>,<span class="dv">200</span>,<span class="dv">200</span>,<span class="dv">350</span>)
<span class="co"># group_name和group_size的第一个元素表明，对于“Price”这组消费者，我们将模拟N=250个观测。</span></code></pre></div>
<p>定义好了数据的基本结构之后，我们下一步是定义分布参数，用这些参数来抽取相应数据。 这里我们要 模拟的数据有4个样本类，8个非抽样调查变量，因此我们创建一个4×8的均值矩阵，因为不同类别的 消费者对应不同的分布参数。下面代码用来创建均值矩阵：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 定义均值矩阵</span>
mus &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(
  <span class="co"># 价格敏感（Price）类对应均值</span>
  <span class="dv">60</span>, <span class="fl">0.5</span>, <span class="dv">120000</span>,<span class="fl">0.9</span>, <span class="dv">500</span>,<span class="dv">200</span>,<span class="dv">5</span>,<span class="dv">2</span>,
  <span class="co"># 炫耀性消费（Conspicuous）类对应均值</span>
  <span class="dv">40</span>, <span class="fl">0.7</span>, <span class="dv">200000</span>,<span class="fl">0.9</span>, <span class="dv">5000</span>,<span class="dv">5000</span>,<span class="dv">10</span>,<span class="dv">10</span>,
  <span class="co"># 质量（Quality）类对应均值</span>
  <span class="dv">36</span>, <span class="fl">0.5</span>, <span class="dv">70000</span>, <span class="fl">0.4</span>, <span class="dv">300</span>, <span class="dv">2000</span>,<span class="dv">2</span>,<span class="dv">15</span>,
  <span class="co"># 风格（Style）类对应均值</span>
  <span class="dv">25</span>, <span class="fl">0.2</span>, <span class="dv">90000</span>, <span class="fl">0.2</span>, <span class="dv">200</span>, <span class="dv">2000</span>,<span class="dv">2</span>,<span class="dv">20</span>), <span class="dt">ncol=</span><span class="kw">length</span>(vars), <span class="dt">byrow=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>具体过程是怎样的？ 均值矩阵<code>mus</code>指定，例如，价格敏感（Price）类群体的第一个变量（这里是年龄age）均值为60，炫耀性消费（Conspicuous）类群体的年龄均值为40依次类推。正态分布变量需要指定均值和方差，如年龄（<code>age</code>）， 实体店花销（<code>store_exp</code>）和在线花销（<code>online_exp</code>）。对于二项分布（只有两个可能取值）和泊松分布变量，我们只需要规定均值。其中，性别（<code>gender</code>），有房还是租房（<code>house</code>）是二项数据，生成这样的数据需要指定得到其中某一观测值的概率，比如矩阵<code>mus</code>中。实体店交易次数（<code>store_trans</code>）和线交易次数（<code>online_trans</code>）是泊松变量（频数），泊松分布只有一个参数——分布均值。所以在下面的标准差矩阵<code>sds</code>中，非正态分布变量对应的标准差为缺失值<code>NA</code>。（注意这里我们只是用这些分布为例生成数据，并不意味着这些是最好的拟合变量观测的分布。例如，真实的收入数据更可能是一个有偏的分布而非正态）。</p>
<p>下面我们对正态分布变量创建标准差矩阵：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 每类的标准差 (NA = 标准差无定义)</span>
sds&lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(
  <span class="co"># 价格敏感（Price）类对应均值</span>
  <span class="dv">3</span>,<span class="ot">NA</span>,<span class="dv">8000</span>,<span class="ot">NA</span>,<span class="dv">100</span>,<span class="dv">50</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,
  <span class="co"># 炫耀性消费（Conspicuous）类对应均值</span>
  <span class="dv">5</span>,<span class="ot">NA</span>,<span class="dv">50000</span>,<span class="ot">NA</span>,<span class="dv">1000</span>,<span class="dv">1500</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,
  <span class="co"># 质量（Quality）类对应均值</span>
  <span class="dv">7</span>,<span class="ot">NA</span>,<span class="dv">10000</span>,<span class="ot">NA</span>,<span class="dv">50</span>,<span class="dv">200</span>,<span class="ot">NA</span>,<span class="ot">NA</span>,
  <span class="co"># 风格（Style）类对应均值</span>
  <span class="dv">2</span>,<span class="ot">NA</span>,<span class="dv">5000</span>,<span class="ot">NA</span>,<span class="dv">10</span>,<span class="dv">500</span>,<span class="ot">NA</span>,<span class="ot">NA</span>), <span class="dt">ncol=</span><span class="kw">length</span>(vars), <span class="dt">byrow=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>将这两个矩阵加在一起我们就能够完全定义各个类的分布了。例如，我们来看下每个矩阵的第1行，其代表第1类群体（价格敏感）的分布参数。这些值规定该类群体的年龄（age）均值为60（见第一个矩阵第1行第1列），标准差为3（第二个矩阵第1行第1列）。另外，其中大约有50%的男性（第一个矩阵第1行第2列），年收入（income）均值为120000元，标准差为8000元。将这些设置分开存在不同表格中，将来想要修改十分容易。将数据定义和抽样过程分开是个很好的习惯。下面开始抽取数据：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 抽取非抽样调查数据</span>
sim.dat&lt;-<span class="ot">NULL</span>
<span class="kw">set.seed</span>(<span class="dv">2016</span>)
<span class="co"># 对消费者类别进行循环（i）</span>
 for (i in <span class="kw">seq_along</span>(group_name)){
   <span class="co"># 为了核实代码，展示循环运行过程，我们在循环中添加了这样一行代码</span>
   <span class="co"># 函数运行时会打印出正在抽取的样本类名</span>
   <span class="kw">cat</span> (i, group_name[i],<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="co"># 创建一个空矩阵用于存放该类消费者相关数据</span>
  seg&lt;-<span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="ot">NA</span>,<span class="dt">nrow=</span>group_size[i], <span class="dt">ncol=</span><span class="kw">length</span>(vars)))  
  <span class="co"># 在这个类之内，对不同变量迭代，抽取相应的随机数据</span>
  for (j in <span class="kw">seq_along</span>(vars)){
    <span class="co"># 在每个变量上迭代</span>
    if (vartype[j]==<span class="st">&quot;norm&quot;</span>){
      <span class="co"># 抽取正态分布变量</span>
      seg[,j]&lt;-<span class="kw">rnorm</span>(group_size[i], <span class="dt">mean=</span>mus[i,j], <span class="dt">sd=</span>sds[i,j])
    } else if (vartype[j]==<span class="st">&quot;pois&quot;</span>) {
      <span class="co"># 抽取泊松分布变量</span>
      seg[,j]&lt;-<span class="kw">rpois</span>(group_size[i], <span class="dt">lambda=</span>mus[i,j])
    } else if (vartype[j]==<span class="st">&quot;binom&quot;</span>){
      <span class="co"># 抽取二项分布变量</span>
      seg[,j]&lt;-<span class="kw">rbinom</span>(group_size[i],<span class="dt">size=</span><span class="dv">1</span>,<span class="dt">prob=</span>mus[i,j])
    } else{
      <span class="co"># 如果变量类型不是上述几种，程序停止运行并提示信息</span>
      <span class="kw">stop</span> (<span class="st">&quot;Don&#39;t have type:&quot;</span>,vartype[j])
    }        
  }
  <span class="co"># 将该消费者类的数据依行添加到总数据集</span>
  sim.dat&lt;-<span class="kw">rbind</span>(sim.dat,seg)
 }</code></pre></div>
<p>上面的代码是随机抽样的主要过程，其中<code>cat()</code>函数使得循环运行时会打印出正在抽取的样本类名，最后得到的<code>sim.dat</code>是初始描述客户的变量部分的数据，在对数据进行润色前，提醒大家注意两个关于R的技巧：</p>
<p>第一、在i循环内，我们事先定义一个有着相应行数和列数的没有元素值的数据框<code>seg</code>，之后每迭代一次就将样本赋值到事先定义的<code>seg</code>的特定行。这么做的原因是由于只要R在某个对象上添加东西——如在数据框上增加一行——它都会将原对象拷贝一份。这将使用两倍的内存，减慢运行速度。通过这种方法可以避免对内存的浪费。对这里的小数据可能感觉不出差别，但对于大数据，运行速度会有极大不同。</p>
<p>第二、对循环指针范围的设定用的是<code>seq_along()</code>而非<code>1:length()</code>。这是为了够避免一些常见的错误，如指针向量长度为0或者不经意将向量方向弄反了。</p>
<p>之后我们对描述客户的这部分数据进行完善，添加合适的列标签，将二项（0/1）变量转化为贴有标签的因子变量。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 指定数据框的列名为我们定义的变量名</span>
<span class="kw">names</span>(sim.dat)&lt;-vars
<span class="co"># 加上一个因子列表明每个观测的对应的消费者类别</span>
sim.dat$segment&lt;-<span class="kw">factor</span>(<span class="kw">rep</span>(group_name,<span class="dt">times=</span>group_size))
<span class="co"># 将二项变量转化为贴有标签的因子变量</span>
<span class="co"># Female: 女性</span>
<span class="co"># Male: 男性</span>
sim.dat$gender&lt;-<span class="kw">factor</span>(sim.dat$gender, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;Female&quot;</span>,<span class="st">&quot;Male&quot;</span>))
sim.dat$house&lt;-<span class="kw">factor</span>(sim.dat$house, <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">&quot;No&quot;</span>,<span class="st">&quot;Yes&quot;</span>))
<span class="co"># 假设在线购买和在实体店购买的次数至少为1，所以这里在原随机值上加1</span>
sim.dat$store_trans&lt;-sim.dat$store_trans<span class="dv">+1</span>
sim.dat$online_trans&lt;-sim.dat$online_trans<span class="dv">+1</span>
<span class="co"># 年龄为整数</span>
sim.dat$age&lt;-<span class="kw">floor</span>(sim.dat$age)</code></pre></div>
<p>真实市场营销数据往往没有这么干净，数据缺失，以及错误输入等问题常常发生。我们最后对模拟的数据做一点“破坏”，使其更像真实的数据。我们假设一些人不愿意给出关于收入（<code>income</code>）的信息。我们建立一个逻辑变量<code>idxm</code>，然后将逻辑变量<code>idxm</code>值为真的对应位置消费者收入观测设为缺失值<code>NA</code>（R用<code>NA</code>表示缺失值）。我们假设年龄（age）越大的消费者对应缺失值的概率越大：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 加入缺失值</span>
idxm &lt;-<span class="st"> </span><span class="kw">as.logical</span>(<span class="kw">rbinom</span>(ncust, <span class="dt">size=</span><span class="dv">1</span>, <span class="dt">prob=</span>sim.dat$age/<span class="dv">200</span>))
sim.dat$income[idxm]&lt;-<span class="ot">NA</span></code></pre></div>
<p>真实的数据中可能有错误的输入，或者离群点：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 错误输入，离群点</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
idx&lt;-<span class="kw">sample</span>(<span class="dv">1</span>:ncust,<span class="dv">5</span>)
sim.dat$age[idx[<span class="dv">1</span>]]&lt;-<span class="dv">300</span>
sim.dat$store_exp[idx[<span class="dv">2</span>]]&lt;-<span class="st"> </span>-<span class="dv">500</span>
sim.dat$store_exp[idx[<span class="dv">3</span>:<span class="dv">5</span>]]&lt;-<span class="kw">c</span>(<span class="dv">50000</span>,<span class="dv">30000</span>,<span class="dv">30000</span>)</code></pre></div>
<p>到目前为止我们已经建立了一部分数据，你可以通过<code>summary(sim.dat)</code>检查数据。下面我们接着抽取问卷调查回复数据。我们先通过<code>rnorm()</code>生成正态分布随机数。但从上面的问卷调查表格中可以看到，这是一个1-5分量级的问卷，1代表非常不同意，5代表非常同意。于是接下来我们通过<code>floor()</code>函数将连续值转化成离散整数。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 抽取问卷调查回复</span>
<span class="co"># 问卷问题数目</span>
nq&lt;-<span class="dv">10</span>
<span class="co"># 各类消费者对问卷回复的正态分布均值矩阵</span>
mus2 &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(
  <span class="co"># 价格敏感（Price）类对应均值</span>
 <span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">4</span>,
  <span class="co"># 炫耀性消费（Conspicuous）类对应均值</span>
 <span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,
  <span class="co"># 质量（Quality）类对应均值</span>
 <span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,
  <span class="co"># 风格（Style）类对应均值</span>
 <span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">2</span>), <span class="dt">ncol=</span>nq, <span class="dt">byrow=</span><span class="ot">TRUE</span>)

<span class="co"># 方差假设都是0.2</span>
sd2&lt;-<span class="fl">0.2</span>
sim.dat2&lt;-<span class="ot">NULL</span>
<span class="kw">set.seed</span>(<span class="dv">1000</span>)
<span class="co"># 对消费者类别进行循环（i）</span>
for (i in <span class="kw">seq_along</span>(group_name)){
  <span class="co"># 为了核实代码，展示循环运行过程，我们在循环中添加了这样一行代码</span>
  <span class="co"># 函数运行时会打印出正在抽取的样本类名，这里不再显示输出</span>
  <span class="co"># cat (i, group_name[i],&quot;\n&quot;)</span>
  <span class="co"># 创建一个空矩阵用于存放该类消费者相关数据</span>
  seg&lt;-<span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="ot">NA</span>,<span class="dt">nrow=</span>group_size[i], <span class="dt">ncol=</span>nq))  
  <span class="co"># 在这个类之内，对不同变量迭代，抽取相应的随机数据</span>
  for (j in <span class="dv">1</span>:nq){
    <span class="co"># 抽取正态分布变量</span>
    res&lt;-<span class="kw">rnorm</span>(group_size[i], <span class="dt">mean=</span>mus2[i,j], <span class="dt">sd=</span>sd2)
    <span class="co"># 设置上下限度</span>
    res[res&gt;<span class="dv">5</span>]&lt;-<span class="dv">5</span>
    res[res&lt;<span class="dv">1</span>]&lt;-<span class="dv">1</span>
    <span class="co"># 通过 floor()函数将连续值转化成离散整数。</span>
    seg[,j]&lt;-<span class="kw">floor</span>(res)
  }
  <span class="co"># 将该消费者类的数据添加到总数据集</span>
  sim.dat2&lt;-<span class="kw">rbind</span>(sim.dat2,seg)
}

<span class="co"># 为数据框添加列标签</span>
<span class="kw">names</span>(sim.dat2)&lt;-<span class="kw">paste</span>(<span class="st">&quot;Q&quot;</span>,<span class="dv">1</span>:<span class="dv">10</span>,<span class="dt">sep=</span><span class="st">&quot;&quot;</span>)
<span class="co"># 合并两部分数据</span>
sim.dat&lt;-<span class="kw">cbind</span>(sim.dat,sim.dat2)
<span class="co"># 加上一个因子列表明每个观测的对应的消费者类别</span>
sim.dat$segment&lt;-<span class="kw">factor</span>(<span class="kw">rep</span>(group_name,<span class="dt">times=</span>group_size))</code></pre></div>
<p>至此为止我们得到了需要的数据集。让我们检查一下抽取的数据集：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(sim.dat,<span class="dt">vec.len=</span><span class="dv">3</span>)</code></pre></div>
<pre><code>## &#39;data.frame&#39;:    1000 obs. of  19 variables:
##  $ age         : int  57 63 59 60 51 59 57 57 ...
##  $ gender      : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 1 1 2 2 2 2 2 2 ...
##  $ income      : num  120963 122008 114202 113616 ...
##  $ house       : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 2 2 2 ...
##  $ store_exp   : num  529 478 491 348 ...
##  $ online_exp  : num  304 110 279 142 ...
##  $ store_trans : int  2 4 7 10 4 4 5 11 ...
##  $ online_trans: int  2 2 2 2 4 5 3 5 ...
##  $ Q1          : int  4 4 5 5 4 4 4 5 ...
##  $ Q2          : int  2 1 2 2 1 2 1 2 ...
##  $ Q3          : int  1 1 1 1 1 1 1 1 ...
##  $ Q4          : int  2 2 2 3 3 2 2 3 ...
##  $ Q5          : int  1 1 1 1 1 1 1 1 ...
##  $ Q6          : int  4 4 4 4 4 4 4 4 ...
##  $ Q7          : int  1 1 1 1 1 1 1 1 ...
##  $ Q8          : int  4 4 4 4 4 4 4 4 ...
##  $ Q9          : int  2 1 1 2 2 1 1 2 ...
##  $ Q10         : int  4 4 4 4 4 4 4 4 ...
##  $ segment     : Factor w/ 4 levels &quot;Conspicuous&quot;,..: 2 2 2 2 2 2 2 2 ...</code></pre>
<p>可以看到，服装消费者数据有1000个观测，19个变量。前8个变量是关于样本的人口统计学和购买行为描述。Q1-Q10是关于消费者选择偏好的问卷调查回复，问卷分值量表为1-5分（最常见的市场调查设计）。最后一列是消费者类别，样本观测的模拟是根据消费者类别进行的，因此这些可以当作“真实”的消费者类别。使用随机模拟的一个重要优点就是能够通过这种方式验证模型的效果。而实际生活中的数据样本真正所属类别通常是未知的。我们在之后对聚类和判别分析进行介绍的时候会使用样本类别信息。下面我们会反复用该数据集为例。</p>
</div>
<div id="section-3.2" class="section level2">
<h2><span class="header-section-number">3.2</span> 航空公司满意度调查</h2>
<p>这一小节我们模拟一个航空公司满意度调查数据。数据中包含N=1000个受访者，每个受访者基于最近一次航班体验对3个航空公司进行评分，问卷调查一共15项，每项评分从1-9，分值越大满意度越高。这15个调查项分为4类（括号中为相应数据集中的变量名）：</p>
<ol style="list-style-type: decimal">
<li>购票体验
<ul>
<li>购票容易度（Easy_Reservation）</li>
<li>座椅选择（Preferred_Seats）</li>
<li>航班选择（Flight_Options）</li>
<li>票价（Ticket_Prices）</li>
</ul></li>
<li>机舱设施
<ul>
<li>座椅舒适度（Seat_Comfort）</li>
<li>位置前后空间（Seat_Roominess）</li>
<li>随机行李存放（Overhead_Storage）</li>
<li>机舱清洁（Clean_Aircraft）</li>
</ul></li>
<li>空航服务
<ul>
<li>礼貌（Courtesy）</li>
<li>友善（Friendliness）</li>
<li>能够提供需要的帮助（Helpfulness）</li>
<li>食物饮料服务（Service）</li>
</ul></li>
<li>总体指数
<ul>
<li>总体满意度（Satisfaction）</li>
<li>再次选择次航空公司（Fly_Again）</li>
<li>向朋友推荐此航空公司（Recommend）</li>
</ul></li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 先建立因子载荷矩阵</span>
<span class="co"># 其中前12项符合双因子结构，因为每项对应一个总体因子载荷和某特定因子的载荷</span>
<span class="co"># 比如购票容易度对应总体因子载荷0.33，对因特定购票因子载荷0.58</span>
<span class="co"># 我们可以将结果评分看成是总体因子和特定因子共同作用的结果</span>

loadings &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span> (
  <span class="co"># 购票体验</span>
  .<span class="dv">33</span>, .<span class="dv">58</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># 购票容易度 </span>
  .<span class="dv">35</span>, .<span class="dv">55</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># 座椅选择</span>
  .<span class="dv">30</span>, .<span class="dv">52</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># 航班选择</span>
  .<span class="dv">40</span>, .<span class="dv">50</span>, .<span class="dv">00</span>, .<span class="dv">00</span>,  <span class="co"># 票价</span>
  <span class="co"># 机舱设施</span>
  .<span class="dv">50</span>, .<span class="dv">00</span>, .<span class="dv">55</span>, .<span class="dv">00</span>,  <span class="co"># 座椅舒适度</span>
  .<span class="dv">41</span>, .<span class="dv">00</span>, .<span class="dv">51</span>, .<span class="dv">00</span>,  <span class="co"># 位置前后空间</span>
  .<span class="dv">45</span>, .<span class="dv">00</span>, .<span class="dv">57</span>, .<span class="dv">00</span>,  <span class="co"># 随机行李存放</span>
  .<span class="dv">32</span>, .<span class="dv">00</span>, .<span class="dv">54</span>, .<span class="dv">00</span>,  <span class="co"># 机舱清洁</span>
  <span class="co"># 空航服务</span>
  .<span class="dv">35</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">50</span>,  <span class="co"># 礼貌</span>
  .<span class="dv">38</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">57</span>,  <span class="co"># 友善</span>
  .<span class="dv">60</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">50</span>,  <span class="co"># 能够提供需要的帮助</span>
  .<span class="dv">52</span>, .<span class="dv">00</span>, .<span class="dv">00</span>, .<span class="dv">58</span>,  <span class="co"># 食物饮料服务</span>
  <span class="co"># 总体指数  </span>
  .<span class="dv">43</span>, .<span class="dv">10</span>, .<span class="dv">30</span>, .<span class="dv">30</span>,  <span class="co"># 总体满意度</span>
  .<span class="dv">35</span>, .<span class="dv">50</span>, .<span class="dv">40</span>, .<span class="dv">20</span>,  <span class="co"># 再次选择次航空公司</span>
  .<span class="dv">25</span>, .<span class="dv">50</span>, .<span class="dv">50</span>, .<span class="dv">20</span>), <span class="co"># 向朋友推荐此航空公司</span>
  <span class="dt">nrow=</span><span class="dv">15</span>,<span class="dt">ncol=</span><span class="dv">4</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>)
  
<span class="co"># 将载荷矩阵乘以它的转秩，然后将对角线元素设置为1得到相关矩阵</span>
cor_matrix&lt;-loadings %*%<span class="st"> </span><span class="kw">t</span>(loadings)
<span class="co"># Diagonal set to ones.</span>
<span class="kw">diag</span>(cor_matrix)&lt;-<span class="dv">1</span>

<span class="co"># 我们通过mvtnorm包模拟有特定相关矩阵的数据集</span>
<span class="kw">library</span>(mvtnorm)
<span class="co"># 设置3个航空公司对应的评分均值向量</span>
mu1=<span class="kw">c</span>(<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">6</span>, <span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">6</span>,<span class="dv">7</span>, <span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>, <span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">6</span>)
mu2=<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>, <span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>, <span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>)
mu3=<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>, <span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>)

<span class="co">#设置随机种子</span>
<span class="kw">set.seed</span>(<span class="dv">123456</span>) 
<span class="co"># 受访者ID</span>
resp.id &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">1000</span> 

<span class="kw">library</span>(MASS) 
rating1 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="kw">length</span>(resp.id),
                     <span class="dt">mu=</span>mu1,
                     <span class="dt">Sigma=</span>cor_matrix)
rating2 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="kw">length</span>(resp.id),
                   <span class="dt">mu=</span>mu2,
                   <span class="dt">Sigma=</span>cor_matrix)
rating3 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="kw">length</span>(resp.id),
                   <span class="dt">mu=</span>mu3,
                   <span class="dt">Sigma=</span>cor_matrix)


<span class="co"># 将分值限定在1到9之间</span>
rating1[rating1&gt;<span class="dv">9</span>]&lt;-<span class="dv">9</span>
rating1[rating1&lt;<span class="dv">1</span>]&lt;-<span class="dv">1</span>
rating2[rating2&gt;<span class="dv">9</span>]&lt;-<span class="dv">9</span>
rating2[rating2&lt;<span class="dv">1</span>]&lt;-<span class="dv">1</span>
rating3[rating3&gt;<span class="dv">9</span>]&lt;-<span class="dv">9</span>
rating3[rating3&lt;<span class="dv">1</span>]&lt;-<span class="dv">1</span>

<span class="co"># 将分值转化为整数</span>
rating1&lt;-<span class="kw">data.frame</span>(<span class="kw">round</span>(rating1,<span class="dv">0</span>))
rating2&lt;-<span class="kw">data.frame</span>(<span class="kw">round</span>(rating2,<span class="dv">0</span>))
rating3&lt;-<span class="kw">data.frame</span>(<span class="kw">round</span>(rating3,<span class="dv">0</span>))
rating1$ID&lt;-resp.id
rating2$ID&lt;-resp.id
rating3$ID&lt;-resp.id
rating1$Airline&lt;-<span class="kw">rep</span>(<span class="st">&quot;AirlineCo.1&quot;</span>,<span class="kw">length</span>(resp.id))
rating2$Airline&lt;-<span class="kw">rep</span>(<span class="st">&quot;AirlineCo.2&quot;</span>,<span class="kw">length</span>(resp.id))
rating3$Airline&lt;-<span class="kw">rep</span>(<span class="st">&quot;AirlineCo.3&quot;</span>,<span class="kw">length</span>(resp.id))
rating&lt;-<span class="kw">rbind</span>(rating1,rating2,rating3)

<span class="co"># 为数据集的各列命名</span>
<span class="kw">names</span>(rating)&lt;-<span class="kw">c</span>(
  <span class="st">&quot;Easy_Reservation&quot;</span>,
  <span class="st">&quot;Preferred_Seats&quot;</span>,
  <span class="st">&quot;Flight_Options&quot;</span>,
  <span class="st">&quot;Ticket_Prices&quot;</span>,
  <span class="st">&quot;Seat_Comfort&quot;</span>,
  <span class="st">&quot;Seat_Roominess&quot;</span>,
  <span class="st">&quot;Overhead_Storage&quot;</span>,
  <span class="st">&quot;Clean_Aircraft&quot;</span>,
  <span class="st">&quot;Courtesy&quot;</span>,
  <span class="st">&quot;Friendliness&quot;</span>,
  <span class="st">&quot;Helpfulness&quot;</span>,
  <span class="st">&quot;Service&quot;</span>,
  <span class="st">&quot;Satisfaction&quot;</span>,
  <span class="st">&quot;Fly_Again&quot;</span>,
  <span class="st">&quot;Recommend&quot;</span>,
  <span class="st">&quot;ID&quot;</span>,
  <span class="st">&quot;Airline&quot;</span>)</code></pre></div>
<p>让我们检查一下抽取的数据集：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(rating,<span class="dt">vec.len=</span><span class="dv">3</span>)</code></pre></div>
<pre><code>## &#39;data.frame&#39;:    3000 obs. of  17 variables:
##  $ Easy_Reservation: int  6 5 6 5 4 5 6 4 ...
##  $ Preferred_Seats : int  5 7 6 6 5 6 6 6 ...
##  $ Flight_Options  : int  4 7 5 5 3 4 6 3 ...
##  $ Ticket_Prices   : int  5 6 6 5 6 5 5 5 ...
##  $ Seat_Comfort    : int  5 6 7 7 6 6 6 4 ...
##  $ Seat_Roominess  : int  7 8 6 8 7 8 6 5 ...
##  $ Overhead_Storage: int  5 5 7 6 5 4 4 4 ...
##  $ Clean_Aircraft  : int  7 6 7 7 7 7 6 4 ...
##  $ Courtesy        : int  5 6 6 4 2 5 5 4 ...
##  $ Friendliness    : int  4 6 6 6 3 4 5 5 ...
##  $ Helpfulness     : int  6 5 6 4 4 5 5 4 ...
##  $ Service         : int  6 5 6 5 3 5 5 5 ...
##  $ Satisfaction    : int  6 7 7 5 4 6 5 5 ...
##  $ Fly_Again       : int  6 6 6 7 4 5 3 4 ...
##  $ Recommend       : int  3 6 5 5 4 5 6 5 ...
##  $ ID              : int  1 2 3 4 5 6 7 8 ...
##  $ Airline         : Factor w/ 3 levels &quot;AirlineCo.1&quot;,..: 1 1 1 1 1 1 1 1 ...</code></pre>
</div>
<div id="section-3.3" class="section level2">
<h2><span class="header-section-number">3.3</span> 生猪疫情风险预测数据</h2>
<p>本小节中我们将模拟一个生猪疫情数据。假设研究人员对800个养猪场进行和某生猪疫情有关的问卷调查，问卷由120个问题组成。每个问题有3个可能选项。目的是根据问卷调查回复得到每个养猪场在未来爆发疫情的概率。每个养猪场在问卷问题的3个可选项中等概率选择。第<span class="math inline">\(i\)</span>个养猪场对应的疫情爆发概率服从<span class="math inline">\(Bernoulli(1,p_{i})\)</span>分布。其中</p>
<p><span class="math display">\[ln(\frac{p_{i}}{1-p_{i}})=\beta_{0}+\sum_{g=1}^{G}\mathbf{x_{i,g}^{T}}\beta_{g}\]</span></p>
<p><span class="math inline">\(\beta_{0}\)</span>是截距项，<span class="math inline">\(\mathbf{x_{i,g}}\)</span>是第<span class="math inline">\(i\)</span>观测对应第<span class="math inline">\(g\)</span>个问题的回复。这里将问题回复转化为0/1虚拟变量，因为每个问题有3个可能选项，所以<span class="math inline">\(\mathbf{x_{i,g}}\)</span>是一个取值为0/1的含有三个元素的向量。<span class="math inline">\(\mathbf{\beta_{g}}\)</span>是对应的参数。</p>
<p>我们在这里考虑3类问题。第1类（问题1到问题40）问题中有两个选项对应变量有预测能力。第2类（问题41到问题80）问题中只有一个选项对结果有预测能力。第3类（问题81到问题120）对结果预测没有帮助，也就是我们希望能够去除的变量。模拟数据的参数设置如下：</p>
<p><span class="math display">\[\mathbf{\beta^{T}}=\left(\underset{question\ 1}{\frac{40}{3},\underbrace{1,0,-1}},...,\underset{question\ 40}{\underbrace{1,0,-1}},\underset{question\ 41}{\underbrace{1,0,0}},...,\underset{question\ 80}{\underbrace{1,0,0}},\underset{question\ 81}{\underbrace{0,0,0}},...,\underset{question\ 120}{\underbrace{0,0,0}}\right)*\gamma\]</span></p>
<p>这里我们通过设置5个<span class="math inline">\(\gamma\)</span>值（<span class="math inline">\(\gamma \in \{0.1,0.25,0.5,1,2\}\)</span> ）模拟了5种参数情况下的数据。 <span class="math inline">\(\gamma\)</span>越大，参数值越大，也就意味着有效问题对结果的预测性越强。对于每个参数设定模拟了20个数据集，之后我们会以这些数据为例展示不同模型变量选择的效果。模拟多个数据集是为了研究一些估值的稳定性。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># sim1_da1.csv  模拟的第一个数据集</span>
<span class="co"># similar sim1_da2 and sim1_da3</span>
<span class="co"># sim1.csv  simulated data, the first simulation</span>
<span class="co"># dummy.sim1.csv dummy variables for the first simulated data with all the baseline in</span>
<span class="co">#code for simulation</span>

<span class="co"># setwd(dirname(file.choose()))</span>
<span class="co"># library(grplasso)</span>

nf&lt;-<span class="dv">800</span>
for (j in <span class="dv">1</span>:<span class="dv">20</span>){
<span class="kw">set.seed</span>(<span class="dv">19870</span>+j)
x&lt;-<span class="kw">c</span>(<span class="st">&#39;A&#39;</span>,<span class="st">&#39;B&#39;</span>,<span class="st">&#39;C&#39;</span>)
sim.da1&lt;-<span class="ot">NULL</span>
for (i in <span class="dv">1</span>:nf){
<span class="co"># sample(x, 120, replace=TRUE)-&gt;sam</span>
sim.da1&lt;-<span class="kw">rbind</span>(sim.da1,<span class="kw">sample</span>(x, <span class="dv">120</span>, <span class="dt">replace=</span><span class="ot">TRUE</span>))
}

<span class="kw">data.frame</span>(sim.da1)-&gt;sim.da1
<span class="kw">paste</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span>:<span class="dv">120</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)-&gt;col
<span class="kw">paste</span>(<span class="st">&quot;Farm&quot;</span>, <span class="dv">1</span>:nf, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)-&gt;row
<span class="kw">colnames</span>(sim.da1)&lt;-col
<span class="kw">rownames</span>(sim.da1)&lt;-row

<span class="co"># 用nnet包中的class.ind()函数将问题回复编码为名义变量</span>
<span class="kw">library</span>(nnet)
dummy.sim1&lt;-<span class="ot">NULL</span>
for (k in <span class="dv">1</span>:<span class="kw">ncol</span>(sim.da1)) {
tmp=<span class="kw">class.ind</span>(sim.da1[,k])
<span class="kw">colnames</span>(tmp)=<span class="kw">paste</span>(col[k],<span class="kw">colnames</span>(tmp))
dummy.sim1=<span class="kw">cbind</span>(dummy.sim1,tmp)
}
<span class="kw">data.frame</span>(dummy.sim1)-&gt;dummy.sim1

<span class="co"># 每个问题对应的3个名义变量中有重复信息</span>
<span class="co"># 将C选项设置为基线回复</span>
<span class="co"># 删除基线名义变量</span>

base.idx&lt;-<span class="dv">3</span>*<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">120</span>)
dummy1&lt;-dummy.sim1[,-base.idx]

<span class="co"># 对每个r设置依次抽取相应的因变量</span>
<span class="co"># 每次只对一个r值抽取，将其余代码注释掉</span>
<span class="co"># 得到r=0.1 时每个农场对应的连接函数值</span>
<span class="kw">c</span>(<span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>/<span class="dv">10</span>,<span class="dv">0</span>,-<span class="dv">1</span>/<span class="dv">10</span>),<span class="dv">40</span>),<span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>/<span class="dv">10</span>,<span class="dv">0</span>,<span class="dv">0</span>),<span class="dv">40</span>),<span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>),<span class="dv">40</span>))-&gt;s1
<span class="kw">as.matrix</span>(dummy.sim1)%*%s1<span class="dv">-40</span>/<span class="dv">3</span>/<span class="dv">10</span>-&gt;link1

<span class="co"># r=0.25 </span>
<span class="co"># c(rep(c(1/4,0,-1/4),40),rep(c(1/4,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
<span class="co"># as.matrix(dummy.sim1)%*%s1-40/3/4-&gt;link1</span>

<span class="co"># r=0.5 </span>
<span class="co"># c(rep(c(1/2,0,-1/2),40),rep(c(1/2,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
<span class="co"># as.matrix(dummy.sim1)%*%s1-40/3/2-&gt;link1</span>

<span class="co"># r=1</span>
<span class="co"># c(rep(c(1,0,-1),40),rep(c(1,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
<span class="co"># as.matrix(dummy.sim1)%*%s1-40/3-&gt;link1</span>

<span class="co"># r=2</span>
<span class="co"># c(rep(c(2,0,-2),40),rep(c(2,0,0),40),rep(c(0,0,0),40))-&gt;s1</span>
<span class="co"># as.matrix(dummy.sim1)%*%s1-40/3/0.5-&gt;link1</span>


<span class="co"># 在连接函数的基础上计算每个农场对应的爆发概率</span>
<span class="kw">exp</span>(link1)/(<span class="kw">exp</span>(link1)+<span class="dv">1</span>)-&gt;hp1

<span class="co"># 基于爆发概率hp1，抽取相应的因变量res</span>
res&lt;-<span class="kw">rep</span>(<span class="dv">9</span>,nf)
for (i in <span class="dv">1</span>:nf){
<span class="kw">sample</span>( <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>),<span class="dv">1</span>,<span class="dt">prob=</span><span class="kw">c</span>(hp1[i],<span class="dv">1</span>-hp1[i]))-&gt;res[i]
}

<span class="co"># 这里将数据存成3个不同的版本，只是为了之后不同模型使用方便</span>
<span class="co"># 3个数据集都含有所有120个问题的回复，但彼此稍微有不同</span>

<span class="co"># da1 含有因变量，但没有名义变量所属问题的信息</span>
<span class="co"># da2 没有因变量，但最后一行包括的名义变量所属的问题</span>
<span class="co"># da3 没有因变量，没有名义变量所属问题的信息</span>

dummy1$y&lt;-res
da1&lt;-dummy1
y&lt;-da1$y
ind&lt;-<span class="ot">NULL</span>
for (i in <span class="dv">1</span>:<span class="dv">120</span>){
<span class="kw">c</span>(ind,<span class="kw">rep</span>(i,<span class="dv">2</span>))-&gt;ind
}

da2&lt;-<span class="kw">rbind</span>(da1[,<span class="dv">1</span>:<span class="dv">240</span>],ind)
da3&lt;-da1[,<span class="dv">1</span>:<span class="dv">240</span>]

<span class="co"># 将数据集储存起来</span>
<span class="kw">write.csv</span>(da1,<span class="kw">paste</span>(<span class="st">&#39;sim&#39;</span>,j,<span class="st">&#39;_da&#39;</span>,<span class="dv">1</span>,<span class="st">&#39;.csv&#39;</span>,<span class="dt">sep=</span><span class="st">&#39;&#39;</span>),<span class="dt">row.names=</span>F)
<span class="kw">write.csv</span>(da2,<span class="kw">paste</span>(<span class="st">&#39;sim&#39;</span>,j,<span class="st">&#39;_da&#39;</span>,<span class="dv">2</span>,<span class="st">&#39;.csv&#39;</span>,<span class="dt">sep=</span><span class="st">&#39;&#39;</span>),<span class="dt">row.names=</span>F)
<span class="kw">write.csv</span>(da3,<span class="kw">paste</span>(<span class="st">&#39;sim&#39;</span>,j,<span class="st">&#39;_da&#39;</span>,<span class="dv">3</span>,<span class="st">&#39;.csv&#39;</span>,<span class="dt">sep=</span><span class="st">&#39;&#39;</span>),<span class="dt">row.names=</span>F)
<span class="kw">write.csv</span>(sim.da1,<span class="kw">paste</span>(<span class="st">&#39;sim&#39;</span>,j,<span class="st">&#39;.csv&#39;</span>,<span class="dt">sep=</span><span class="st">&#39;&#39;</span>),<span class="dt">row.names=</span>F)
<span class="kw">write.csv</span>(dummy.sim1,<span class="kw">paste</span>(<span class="st">&#39;dummy.sim&#39;</span>,j,<span class="st">&#39;.csv&#39;</span>,<span class="dt">sep=</span><span class="st">&#39;&#39;</span>),<span class="dt">row.names=</span>F)
}</code></pre></div>
<p>要理解这里数据模拟的代码，读者需要了解逻辑回归和分组lasso的理论知识，这超出了本书的范围。这里的代码仅供大家参考。可以重复上面的代码生成相应的数据集。因为这里生成的数据量较大，在网上只有<span class="math inline">\(\gamma=2\)</span>对应的一次模拟的数据集。我们看下得到的数据集：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
disease_dat&lt;-readr::<span class="kw">read_csv</span>(<span class="st">&quot;/Users/happyrabbit/Documents/GitHub/DataScientistR/Data/sim1_da1.csv&quot;</span>)
<span class="co"># 这里只截取最后的7列</span>
<span class="kw">head</span>(<span class="kw">subset</span>(disease_dat,<span class="dt">select=</span><span class="kw">c</span>( <span class="st">&quot;Q118.A&quot;</span>,<span class="st">&quot;Q118.B&quot;</span>,<span class="st">&quot;Q119.A&quot;</span>,<span class="st">&quot;Q119.B&quot;</span>,<span class="st">&quot;Q120.A&quot;</span>,<span class="st">&quot;Q120.B&quot;</span>,<span class="st">&quot;y&quot;</span>))) </code></pre></div>
<p>其中最后一列<code>y</code>代表相应农场疫情爆发情况，<code>y=1</code>代表从问卷调查之后5年内有疫情爆发。剩余的列表示农场问卷调查结果，如<code>Q120.A=1</code>对应问卷调查中第120个问题选择A的农场，类似的<code>Q120.B=1</code>对应第120个问题中选择B的农场，我们将选项C作为基准选项。之后我会用这个数据集展示一些相关的模型。</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="section-2.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="section-4.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/03-shujuji.Rmd",
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
