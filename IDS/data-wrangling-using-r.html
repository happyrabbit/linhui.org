<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Introduction to Data Science</title>
  <meta name="description" content="Introduction to Data Science">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="Introduction to Data Science" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://scientistcafe.com/IDS/" />
  
  <meta property="og:description" content="Introduction to Data Science" />
  <meta name="github-repo" content="happyrabbit/IntroDataScience" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Introduction to Data Science" />
  
  <meta name="twitter:description" content="Introduction to Data Science" />
  

<meta name="author" content="Hui Lin and Ming Li">


<meta name="date" content="2018-01-23">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="data-wrangling.html">
<link rel="next" href="model-tuning-strategy.html">
<script src="libs/jquery/jquery.min.js"></script>
<link href="libs/gitbook/css/style.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="http://scientistcafe.com">Homepage</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a><ul>
<li class="chapter" data-level="" data-path="goal-of-the-book.html"><a href="goal-of-the-book.html"><i class="fa fa-check"></i>Goal of the Book</a></li>
<li class="chapter" data-level="" data-path="who-this-book-is-for.html"><a href="who-this-book-is-for.html"><i class="fa fa-check"></i>Who This Book Is For</a></li>
<li class="chapter" data-level="" data-path="what-this-book-covers.html"><a href="what-this-book-covers.html"><i class="fa fa-check"></i>What This Book Covers</a></li>
<li class="chapter" data-level="" data-path="conventions.html"><a href="conventions.html"><i class="fa fa-check"></i>Conventions</a></li>
<li class="chapter" data-level="" data-path="acknowledgements.html"><a href="acknowledgements.html"><i class="fa fa-check"></i>Acknowledgements</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="about-the-authors.html"><a href="about-the-authors.html"><i class="fa fa-check"></i>About the Authors</a></li>
<li class="chapter" data-level="1" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="what-is-data-science.html"><a href="what-is-data-science.html"><i class="fa fa-check"></i><b>1.1</b> What is data science?</a></li>
<li class="chapter" data-level="1.2" data-path="what-kind-of-questions-can-data-science-solve.html"><a href="what-kind-of-questions-can-data-science-solve.html"><i class="fa fa-check"></i><b>1.2</b> What kind of questions can data science solve?</a><ul>
<li class="chapter" data-level="1.2.1" data-path="what-kind-of-questions-can-data-science-solve.html"><a href="what-kind-of-questions-can-data-science-solve.html#prerequisites"><i class="fa fa-check"></i><b>1.2.1</b> Prerequisites</a></li>
<li class="chapter" data-level="1.2.2" data-path="what-kind-of-questions-can-data-science-solve.html"><a href="what-kind-of-questions-can-data-science-solve.html#problem-type"><i class="fa fa-check"></i><b>1.2.2</b> Problem type</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="data-scientist-skill-set.html"><a href="data-scientist-skill-set.html"><i class="fa fa-check"></i><b>1.3</b> Data Scientist Skill Set</a></li>
<li class="chapter" data-level="1.4" data-path="types-of-learning.html"><a href="types-of-learning.html"><i class="fa fa-check"></i><b>1.4</b> Types of Learning</a></li>
<li class="chapter" data-level="1.5" data-path="types-of-algorithm.html"><a href="types-of-algorithm.html"><i class="fa fa-check"></i><b>1.5</b> Types of Algorithm</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction-to-the-data.html"><a href="introduction-to-the-data.html"><i class="fa fa-check"></i><b>2</b> Introduction to the data</a><ul>
<li class="chapter" data-level="2.1" data-path="customer-data-for-clothing-company.html"><a href="customer-data-for-clothing-company.html"><i class="fa fa-check"></i><b>2.1</b> Customer Data for Clothing Company</a></li>
<li class="chapter" data-level="2.2" data-path="customer-satisfaction-survey-data-from-airline-company.html"><a href="customer-satisfaction-survey-data-from-airline-company.html"><i class="fa fa-check"></i><b>2.2</b> Customer Satisfaction Survey Data from Airline Company</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="data-pre-processing.html"><a href="data-pre-processing.html"><i class="fa fa-check"></i><b>3</b> Data Pre-processing</a><ul>
<li class="chapter" data-level="3.1" data-path="data-cleaning.html"><a href="data-cleaning.html"><i class="fa fa-check"></i><b>3.1</b> Data Cleaning</a></li>
<li class="chapter" data-level="3.2" data-path="missing-values.html"><a href="missing-values.html"><i class="fa fa-check"></i><b>3.2</b> Missing Values</a><ul>
<li class="chapter" data-level="3.2.1" data-path="missing-values.html"><a href="missing-values.html#impute-missing-values-with-medianmode"><i class="fa fa-check"></i><b>3.2.1</b> Impute missing values with median/mode</a></li>
<li class="chapter" data-level="3.2.2" data-path="missing-values.html"><a href="missing-values.html#k-nearest-neighbors"><i class="fa fa-check"></i><b>3.2.2</b> K-nearest neighbors</a></li>
<li class="chapter" data-level="3.2.3" data-path="missing-values.html"><a href="missing-values.html#bagging-tree"><i class="fa fa-check"></i><b>3.2.3</b> Bagging Tree</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="centering-and-scaling.html"><a href="centering-and-scaling.html"><i class="fa fa-check"></i><b>3.3</b> Centering and Scaling</a></li>
<li class="chapter" data-level="3.4" data-path="resolve-skewness.html"><a href="resolve-skewness.html"><i class="fa fa-check"></i><b>3.4</b> Resolve Skewness</a></li>
<li class="chapter" data-level="3.5" data-path="resolve-outliers.html"><a href="resolve-outliers.html"><i class="fa fa-check"></i><b>3.5</b> Resolve Outliers</a></li>
<li class="chapter" data-level="3.6" data-path="collinearity.html"><a href="collinearity.html"><i class="fa fa-check"></i><b>3.6</b> Collinearity</a></li>
<li class="chapter" data-level="3.7" data-path="sparse-variables.html"><a href="sparse-variables.html"><i class="fa fa-check"></i><b>3.7</b> Sparse Variables</a></li>
<li class="chapter" data-level="3.8" data-path="re-encode-dummy-variables.html"><a href="re-encode-dummy-variables.html"><i class="fa fa-check"></i><b>3.8</b> Re-encode Dummy Variables</a></li>
<li class="chapter" data-level="3.9" data-path="python-computing.html"><a href="python-computing.html"><i class="fa fa-check"></i><b>3.9</b> Python Computing</a><ul>
<li class="chapter" data-level="3.9.1" data-path="python-computing.html"><a href="python-computing.html#data-cleaning-1"><i class="fa fa-check"></i><b>3.9.1</b> Data Cleaning</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="data-wrangling.html"><a href="data-wrangling.html"><i class="fa fa-check"></i><b>4</b> Data Wrangling</a><ul>
<li class="chapter" data-level="4.1" data-path="data-wrangling-using-r.html"><a href="data-wrangling-using-r.html"><i class="fa fa-check"></i><b>4.1</b> Data Wrangling Using R</a><ul>
<li class="chapter" data-level="4.1.1" data-path="data-wrangling-using-r.html"><a href="data-wrangling-using-r.html#read-and-write-data"><i class="fa fa-check"></i><b>4.1.1</b> Read and write data</a></li>
<li class="chapter" data-level="4.1.2" data-path="data-wrangling-using-r.html"><a href="data-wrangling-using-r.html#summarize-data"><i class="fa fa-check"></i><b>4.1.2</b> Summarize data</a></li>
<li class="chapter" data-level="4.1.3" data-path="data-wrangling-using-r.html"><a href="data-wrangling-using-r.html#dplyr-package"><i class="fa fa-check"></i><b>4.1.3</b> <code>dplyr</code> package</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="model-tuning-strategy.html"><a href="model-tuning-strategy.html"><i class="fa fa-check"></i><b>5</b> Model Tuning Strategy</a><ul>
<li class="chapter" data-level="5.1" data-path="systematic-error-and-random-error.html"><a href="systematic-error-and-random-error.html"><i class="fa fa-check"></i><b>5.1</b> Systematic Error and Random Error</a><ul>
<li class="chapter" data-level="5.1.1" data-path="systematic-error-and-random-error.html"><a href="systematic-error-and-random-error.html#measurement-error-in-the-response"><i class="fa fa-check"></i><b>5.1.1</b> Measurement Error in the Response</a></li>
<li class="chapter" data-level="5.1.2" data-path="systematic-error-and-random-error.html"><a href="systematic-error-and-random-error.html#measurement-error-in-the-independent-variables"><i class="fa fa-check"></i><b>5.1.2</b> Measurement Error in the Independent Variables</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="data-splitting-and-resampling.html"><a href="data-splitting-and-resampling.html"><i class="fa fa-check"></i><b>5.2</b> Data Splitting and Resampling</a><ul>
<li class="chapter" data-level="5.2.1" data-path="data-splitting-and-resampling.html"><a href="data-splitting-and-resampling.html#data-splitting"><i class="fa fa-check"></i><b>5.2.1</b> Data Splitting</a></li>
<li class="chapter" data-level="5.2.2" data-path="data-splitting-and-resampling.html"><a href="data-splitting-and-resampling.html#resampling"><i class="fa fa-check"></i><b>5.2.2</b> Resampling</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="measuring-performance.html"><a href="measuring-performance.html"><i class="fa fa-check"></i><b>6</b> Measuring Performance</a></li>
<li class="chapter" data-level="7" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>7</b> References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Introduction to Data Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="data-wrangling-using-r" class="section level2">
<h2><span class="header-section-number">4.1</span> Data Wrangling Using R</h2>
<div id="read-and-write-data" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Read and write data</h3>
<div id="readr" class="section level4">
<h4><span class="header-section-number">4.1.1.1</span> <code>readr</code></h4>
<p>You must be familiar with <code>read.csv()</code>, <code>read.table()</code> and <code>write.csv()</code> in base R. Here we will introduce a more efficient package from RStudio in 2015 for reading and writing data: <code>readr</code> package. The corresponding functions are <code>read_csv()</code>, <code>read_table()</code> and <code>write_csv()</code>. The commands look quite similar, but <code>readr</code> is different in the following respects:</p>
<ol style="list-style-type: decimal">
<li><p>It is 10x faster. The trick is that <code>readr</code> uses C++ to process the data quickly.</p></li>
<li><p>It doesn’t change the column names. The names can start with a number and “<code>.</code>” will not be substituted to “<code>_</code>”. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(readr)
<span class="kw">read_csv</span>(<span class="st">&quot;2015,2016,2017</span>
<span class="st">1,2,3</span>
<span class="st">4,5,6&quot;</span>)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   `2015` `2016` `2017`
##    &lt;int&gt;  &lt;int&gt;  &lt;int&gt;
## 1      1      2      3
## 2      4      5      6</code></pre></li>
<li><p><code>readr</code> functions do not convert strings to factors by default, are able to parse dates and times and can automatically determine the data types in each column.</p></li>
<li><p>The killing character, in my opinion, is that <code>readr</code> provides <strong>progress bar</strong>. What makes you feel worse than waiting is not knowing how long you have to wait.</p></li>
</ol>
<div class="figure">
<img src="images/prograssbar.png" />

</div>
<p>The major functions of readr is to turn flat files into data frames:</p>
<ul>
<li><code>read_csv()</code>: reads comma delimited files</li>
<li><code>read_csv2()</code>: reads semicolon separated files (common in countries where <code>,</code> is used as the decimal place)</li>
<li><code>read_tsv()</code>: reads tab delimited files</li>
<li><code>read_delim()</code>: reads in files with any delimiter</li>
<li><code>read_fwf()</code>: reads fixed width files. You can specify fields either by their widths with <code>fwf_widths()</code> or their position with <code>fwf_positions()</code><br />
</li>
<li><code>read_table()</code>: reads a common variation of fixed width files where columns are separated by white space</li>
<li><code>read_log()</code>: reads Apache style log files</li>
</ul>
<p>The good thing is that those functions have similar syntax. Once you learn one, the others become easy. Here we will focus on <code>read_csv()</code>.</p>
<p>The most important information for <code>read_csv()</code> is the path to your data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(readr)
sim.dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv &quot;</span>)
<span class="kw">head</span>(sim.dat)</code></pre></div>
<pre><code>## # A tibble: 6 x 19
##     age gender income house store_exp online_exp
##   &lt;int&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1    57 Female 120963   Yes     529.1      303.5
## 2    63 Female 122008   Yes     478.0      109.5
## 3    59   Male 114202   Yes     490.8      279.2
## 4    60   Male 113616   Yes     347.8      141.7
## 5    51   Male 124253   Yes     379.6      112.2
## 6    59   Male 107661   Yes     338.3      195.7
## # ... with 13 more variables: store_trans &lt;int&gt;,
## #   online_trans &lt;int&gt;, Q1 &lt;int&gt;, Q2 &lt;int&gt;, Q3 &lt;int&gt;,
## #   Q4 &lt;int&gt;, Q5 &lt;int&gt;, Q6 &lt;int&gt;, Q7 &lt;int&gt;, Q8 &lt;int&gt;,
## #   Q9 &lt;int&gt;, Q10 &lt;int&gt;, segment &lt;chr&gt;</code></pre>
<p>The function reads the file to R as a <code>tibble</code>. You can consider <code>tibble</code> as next iteration of the data frame. They are different with data frame for the following aspects:</p>
<ul>
<li>It never changes an input’s type (i.e., no more <code>stringsAsFactors = FALSE</code>!)</li>
<li>It never adjusts the names of variables</li>
<li>It has a refined print method that shows only the first 10 rows and all the columns that fit on the screen. You can also control the default print behavior by setting options.</li>
</ul>
<p>Refer to <a href="http://r4ds.had.co.nz/tibbles.html" class="uri">http://r4ds.had.co.nz/tibbles.html</a> for more information about ‘tibble’.</p>
<p>When you run <code>read_csv()</code> it prints out a column specification that gives the name and type of each column. To better understanding how <code>readr</code> works, it is helpful to type in some baby data set and check the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;2015,2016,2017</span>
<span class="st">100,200,300</span>
<span class="st">canola,soybean,corn&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##   `2015`  `2016` `2017`
##    &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;
## 1    100     200    300
## 2 canola soybean   corn</code></pre>
<p>You can also add comments on the top and tell R to skip those lines:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;# I will never let you know that</span>
<span class="st">          # my favorite food is carrot</span>
<span class="st">          Date,Food,Mood</span>
<span class="st">          Monday,carrot,happy</span>
<span class="st">          Tuesday,carrot,happy</span>
<span class="st">          Wednesday,carrot,happy</span>
<span class="st">          Thursday,carrot,happy</span>
<span class="st">          Friday,carrot,happy</span>
<span class="st">          Saturday,carrot,extremely happy</span>
<span class="st">          Sunday,carrot,extremely happy&quot;</span>, <span class="dt">skip =</span> <span class="dv">2</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 7 x 3
##        Date   Food            Mood
##       &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;
## 1    Monday carrot           happy
## 2   Tuesday carrot           happy
## 3 Wednesday carrot           happy
## 4  Thursday carrot           happy
## 5    Friday carrot           happy
## 6  Saturday carrot extremely happy
## 7    Sunday carrot extremely happy</code></pre>
<p>If you don’t have column names, set <code>col_names = FALSE</code> then R will assign names “<code>X1</code>”,“<code>X2</code>”… to the columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;Saturday,carrot,extremely happy</span>
<span class="st">          Sunday,carrot,extremely happy&quot;</span>, <span class="dt">col_names=</span><span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##         X1     X2              X3
##      &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;
## 1 Saturday carrot extremely happy
## 2   Sunday carrot extremely happy</code></pre>
<p>You can also pass <code>col_names</code> a character vector which will be used as the column names. Try to replace <code>col_names=FALSE</code> with <code>col_names=c(&quot;Date&quot;,&quot;Food&quot;,&quot;Mood&quot;)</code> and see what happen.</p>
<p>As mentioned before, you can use <code>read_csv2()</code> to read semicolon separated files:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv2</span>(<span class="st">&quot;Saturday; carrot; extremely happy </span><span class="ch">\n</span><span class="st"> Sunday; carrot; extremely happy&quot;</span>, <span class="dt">col_names=</span><span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 2 x 3
##         X1     X2              X3
##      &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;
## 1 Saturday carrot extremely happy
## 2   Sunday carrot extremely happy</code></pre>
<p>Here “<code>\n</code>” is a convenient shortcut for adding a new line.</p>
<p>You can use <code>read_tsv()</code> to read tab delimited files：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_tsv</span>(<span class="st">&quot;every</span><span class="ch">\t</span><span class="st">man</span><span class="ch">\t</span><span class="st">is</span><span class="ch">\t</span><span class="st">a</span><span class="ch">\t</span><span class="st">poet</span><span class="ch">\t</span><span class="st">when</span><span class="ch">\t</span><span class="st">he</span><span class="ch">\t</span><span class="st">is</span><span class="ch">\t</span><span class="st">in</span><span class="ch">\t</span><span class="st">love</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 1 x 10
##      X1    X2    X3    X4    X5    X6    X7    X8
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 every   man    is     a  poet  when    he    is
## # ... with 2 more variables: X9 &lt;chr&gt;, X10 &lt;chr&gt;</code></pre>
<p>Or more generally, you can use <code>read_delim()</code> and assign separating character：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_delim</span>(<span class="st">&quot;THE|UNBEARABLE|RANDOMNESS|OF|LIFE</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">delim =</span> <span class="st">&quot;|&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 1 x 5
##      X1         X2         X3    X4    X5
##   &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1   THE UNBEARABLE RANDOMNESS    OF  LIFE</code></pre>
<p>Another situation you will often run into is the missing value. In marketing survey, people like to use “99” to represent missing. You can tell R to set all observation with value “99” as missing when you read the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;Q1,Q2,Q3</span>
<span class="st">               5, 4,99&quot;</span>,<span class="dt">na=</span><span class="st">&quot;99&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<pre><code>## # A tibble: 1 x 3
##      Q1    Q2    Q3
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;
## 1     5     4  &lt;NA&gt;</code></pre>
<p>For writing data back to disk, you can use <code>write_csv()</code> and <code>write_tsv()</code>. The following two characters of the two functions increase the chances of the output file being read back in correctly:</p>
<ul>
<li>Encode strings in UTF-8</li>
<li>Save dates and date-times in ISO8601 format so they are easily parsed elsewhere</li>
</ul>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_csv</span>(sim.dat, <span class="st">&quot;sim_dat.csv&quot;</span>)</code></pre></div>
<p>For other data types, you can use the following packages:</p>
<ul>
<li><code>Haven</code>: SPSS, Stata and SAS data</li>
<li><code>Readxl</code> and <code>xlsx</code>: excel data(.xls and .xlsx)</li>
<li><code>DBI</code>: given data base, such as RMySQL, RSQLite and RPostgreSQL, read data directly from the database using SQL</li>
</ul>
<p>Some other useful materials:</p>
<ul>
<li>For getting data from the internet, you can refer to the book “XML and Web Technologies for Data Sciences with R”.<br />
</li>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html#Acknowledgements">R data import/export manual</a></li>
<li><code>rio</code> package：<a href="https://github.com/leeper/rio" class="uri">https://github.com/leeper/rio</a></li>
</ul>
</div>
<div id="data.table-enhanced-data.frame" class="section level4">
<h4><span class="header-section-number">4.1.1.2</span> <code>data.table</code>— enhanced <code>data.frame</code></h4>
<p>What is <code>data.table</code>? It is an R package that provides an enhanced version of <code>data.frame</code>. The most used object in R is <code>data frame</code>. Before we move on, let’s briefly review some basic characters and manipulations of data.frame:</p>
<ul>
<li>It is a set of rows and columns.</li>
<li>Each row is of the same length and data type</li>
<li>Every column is of the same length but can be of differing data types</li>
<li>It has characteristics of both a matrix and a list</li>
<li>It uses <code>[]</code> to subset data</li>
</ul>
<p>We will use the clothes customer data to illustrate. There are two dimensions in <code>[]</code>. The first one indicates the row and second one indicates column. It uses a comma to separate them.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># read data</span>
sim.dat&lt;-readr::<span class="kw">read_csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)
<span class="co"># subset the first two rows</span>
sim.dat[<span class="dv">1</span>:<span class="dv">2</span>,]</code></pre></div>
<pre><code>## # A tibble: 2 x 19
##     age gender income house store_exp online_exp
##   &lt;int&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1    57 Female 120963   Yes     529.1      303.5
## 2    63 Female 122008   Yes     478.0      109.5
## # ... with 13 more variables: store_trans &lt;int&gt;,
## #   online_trans &lt;int&gt;, Q1 &lt;int&gt;, Q2 &lt;int&gt;, Q3 &lt;int&gt;,
## #   Q4 &lt;int&gt;, Q5 &lt;int&gt;, Q6 &lt;int&gt;, Q7 &lt;int&gt;, Q8 &lt;int&gt;,
## #   Q9 &lt;int&gt;, Q10 &lt;int&gt;, segment &lt;chr&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># subset the first two rows and column 3 and 5</span>
sim.dat[<span class="dv">1</span>:<span class="dv">2</span>,<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">5</span>)]</code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   income store_exp
##    &lt;dbl&gt;     &lt;dbl&gt;
## 1 120963     529.1
## 2 122008     478.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get all rows with age&gt;70</span>
sim.dat[sim.dat$age&gt;<span class="dv">70</span>,]</code></pre></div>
<pre><code>## # A tibble: 1 x 19
##     age gender income house store_exp online_exp
##   &lt;int&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1   300   Male 208017   Yes      5077       6053
## # ... with 13 more variables: store_trans &lt;int&gt;,
## #   online_trans &lt;int&gt;, Q1 &lt;int&gt;, Q2 &lt;int&gt;, Q3 &lt;int&gt;,
## #   Q4 &lt;int&gt;, Q5 &lt;int&gt;, Q6 &lt;int&gt;, Q7 &lt;int&gt;, Q8 &lt;int&gt;,
## #   Q9 &lt;int&gt;, Q10 &lt;int&gt;, segment &lt;chr&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get rows with age&gt; 60 and gender is Male</span>
<span class="co"># select column 3 and 4</span>
sim.dat[sim.dat$age&gt;<span class="dv">68</span> &amp;<span class="st"> </span>sim.dat$gender ==<span class="st"> &quot;Male&quot;</span>, <span class="dv">3</span>:<span class="dv">4</span>]</code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   income house
##    &lt;dbl&gt; &lt;chr&gt;
## 1 119552    No
## 2 208017   Yes</code></pre>
<p>Remember that there are usually different ways to conduct the same manipulation. For example, the following code presents three ways to calculate an average number of online transactions for male and female:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tapply</span>(sim.dat$online_trans, sim.dat$gender, mean )</code></pre></div>
<pre><code>## Female   Male 
##  15.38  11.26</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">aggregate</span>(online_trans ~<span class="st"> </span>gender, <span class="dt">data =</span> sim.dat, mean)</code></pre></div>
<pre><code>##   gender online_trans
## 1 Female        15.38
## 2   Male        11.26</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
sim.dat%&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(gender)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">Avg_online_trans=</span><span class="kw">mean</span>(online_trans))</code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   gender Avg_online_trans
##    &lt;chr&gt;            &lt;dbl&gt;
## 1 Female            15.38
## 2   Male            11.26</code></pre>
<p>There is no gold standard to choose a specific function to manipulate data. The goal is to solve the real problem, not the tool itself. So just use whatever tool that is convenient for you.</p>
<p>The way to use <code>[]</code> is straightforward. But the manipulations are limited. If you need more complicated data reshaping or aggregation, there are other packages to use such as <code>dplyr</code>, <code>reshape2</code>, <code>tidyr</code> etc. But the usage of those packages are not as straightforward as <code>[]</code>. You often need to change functions. Keeping related operations together, such as subset, group, update, join etc, will allow for:</p>
<ul>
<li>concise, consistent and readable syntax irrespective of the set of operations you would like to perform to achieve your end goal</li>
<li>performing data manipulation fluidly without the cognitive burden of having to change among different functions</li>
<li>by knowing precisely the data required for each operation, you can automatically optimize operations effectively</li>
</ul>
<p><code>data.table</code> is the package for that. If you are not familiar with other data manipulating packages and are interested in reducing programming time tremendously, then this package is for you.</p>
<p>Other than extending the function of <code>[]</code>, <code>data.table</code> has the following advantages:</p>
<p>Offers fast import, subset, grouping, update, and joins for large data files It is easy to turn data frame to data table Can behave just like a data frame</p>
<p>You need to install and load the package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># If you haven&#39;t install it, use the code to instal</span>
<span class="co"># install.packages(&quot;data.table&quot;)</span>
<span class="co"># load packagw</span>
<span class="kw">library</span>(data.table)</code></pre></div>
<p>Use <code>data.table()</code> to covert the existing data frame <code>sim.dat</code> to data table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt &lt;-<span class="st"> </span><span class="kw">data.table</span>(sim.dat)
<span class="kw">class</span>(dt)</code></pre></div>
<pre><code>## [1] &quot;data.table&quot; &quot;data.frame&quot;</code></pre>
<p>Calculate mean for counts of online transactions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[, <span class="kw">mean</span>(online_trans)]</code></pre></div>
<pre><code>## [1] 13.55</code></pre>
<p>You can’t do the same thing using data frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat[,<span class="kw">mean</span>(online_trans)]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">Error in mean(online_trans) : object &#39;online_trans&#39; not found</code></pre></div>
<p>If you want to calculate mean by group as before, set “<code>by =</code>” argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>gender]</code></pre></div>
<pre><code>##    gender    V1
## 1: Female 15.38
## 2:   Male 11.26</code></pre>
<p>You can group by more than one variables. For example, group by “<code>gender</code>” and “<code>house</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<pre><code>##    gender house     V1
## 1: Female   Yes 11.312
## 2:   Male   Yes  8.772
## 3: Female    No 19.146
## 4:   Male    No 16.486</code></pre>
<p>Assign column names for aggregated variables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<pre><code>##    gender house    avg
## 1: Female   Yes 11.312
## 2:   Male   Yes  8.772
## 3: Female    No 19.146
## 4:   Male    No 16.486</code></pre>
<p><code>data.table</code> can accomplish all operations that <code>aggregate()</code> and <code>tapply()</code>can do for data frame.</p>
<ul>
<li>General setting of <code>data.table</code></li>
</ul>
<p>Different from data frame, there are three arguments for data table:</p>
<center>
<img src="images/datable1.png" />
</center>
<p>It is analogous to SQL. You don’t have to know SQL to learn data table. But experience with SQL will help you understand data table. In SQL, you select column <code>j</code> (use command <code>SELECT</code>) for row <code>i</code> (using command <code>WHERE</code>). <code>GROUP BY</code> in SQL will assign the variable to group the observations.</p>
<center>
<img src="images/rSQL.png" />
</center>
<p>Let’s review our previous code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>gender]</code></pre></div>
<pre><code>##    gender    V1
## 1: Female 15.38
## 2:   Male 11.26</code></pre>
<p>The code above is equal to the following SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span>  gender, <span class="fu">avg</span>(online_trans) <span class="kw">FROM</span> sim.dat <span class="kw">GROUP</span> <span class="kw">BY</span> gender</code></pre></div>
<p>R code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<pre><code>##    gender house    avg
## 1: Female   Yes 11.312
## 2:   Male   Yes  8.772
## 3: Female    No 19.146
## 4:   Male    No 16.486</code></pre>
<p>is equal to SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> gender, house, <span class="fu">avg</span>(online_trans) <span class="kw">AS</span> <span class="fu">avg</span> <span class="kw">FROM</span> sim.dat <span class="kw">GROUP</span> <span class="kw">BY</span> gender, house</code></pre></div>
<p>R code：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ age &lt;<span class="st"> </span><span class="dv">40</span>, .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<pre><code>##    gender house   avg
## 1:   Male   Yes 14.46
## 2: Female   Yes 18.14
## 3:   Male    No 18.24
## 4: Female    No 20.10</code></pre>
<p>is equal to SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> gender, house, <span class="fu">avg</span>(online_trans) <span class="kw">AS</span> <span class="fu">avg</span> <span class="kw">FROM</span> sim.dat <span class="kw">WHERE</span> age &lt; <span class="dv">40</span> <span class="kw">GROUP</span> <span class="kw">BY</span> gender, house</code></pre></div>
<p>You can see the analogy between <code>data.table</code> and <code>SQL</code>. Now let’s focus on operations in data table.</p>
<ul>
<li>select row</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select rows with age&lt;20 and income &gt; 80000</span>
dt[age &lt;<span class="st"> </span><span class="dv">20</span> &amp;<span class="st"> </span>income &gt;<span class="st"> </span><span class="dv">80000</span>]</code></pre></div>
<pre><code>##    age gender income house store_exp online_exp
## 1:  19 Female  83535    No     227.7       1491
## 2:  18 Female  89416   Yes     209.5       1926
## 3:  19 Female  92813    No     186.7       1042
##    store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
## 1:           1           22  2  1  1  2  4  1  4  2  4
## 2:           3           28  2  1  1  1  4  1  4  2  4
## 3:           2           18  3  1  1  2  4  1  4  3  4
##    Q10 segment
## 1:   1   Style
## 2:   1   Style
## 3:   1   Style</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select the first two rows</span>
dt[<span class="dv">1</span>:<span class="dv">2</span>]</code></pre></div>
<pre><code>##    age gender income house store_exp online_exp
## 1:  57 Female 120963   Yes     529.1      303.5
## 2:  63 Female 122008   Yes     478.0      109.5
##    store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
## 1:           2            2  4  2  1  2  1  4  1  4  2
## 2:           4            2  4  1  1  2  1  4  1  4  1
##    Q10 segment
## 1:   4   Price
## 2:   4   Price</code></pre>
<ul>
<li>select column</li>
</ul>
<p>Selecting columns in <code>data.table</code> don’t need <code>$</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select column “age” but return it as a vector</span>
<span class="co"># the argument for row is empty so the result will return all observations</span>
ans &lt;-<span class="st"> </span>dt[, age]
<span class="kw">head</span>(ans)</code></pre></div>
<pre><code>## [1] 57 63 59 60 51 59</code></pre>
<p>To return <code>data.table</code> object, put column names in <code>list()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Select age and online_exp columns and return as a data.table instead</span>
ans &lt;-<span class="st"> </span>dt[, <span class="kw">list</span>(age, online_exp)]
<span class="kw">head</span>(ans)</code></pre></div>
<pre><code>##    age online_exp
## 1:  57      303.5
## 2:  63      109.5
## 3:  59      279.2
## 4:  60      141.7
## 5:  51      112.2
## 6:  59      195.7</code></pre>
<p>Or you can also put column names in <code>.()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>dt[, .(age, online_exp)]
<span class="co"># head(ans)</span></code></pre></div>
<p>To select all columns from “<code>age</code>” to “<code>income</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>dt[, age:income, with =<span class="st"> </span><span class="ot">FALSE</span>]
<span class="kw">head</span>(ans,<span class="dv">2</span>)</code></pre></div>
<pre><code>##    age gender income
## 1:  57 Female 120963
## 2:  63 Female 122008</code></pre>
<p>Delete columns using <code>-</code> or <code>!</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># delete columns from  age to online_exp</span>
ans &lt;-<span class="st"> </span>dt[, -(age:online_exp), with =<span class="st"> </span><span class="ot">FALSE</span>]
ans &lt;-<span class="st"> </span>dt[, !(age:online_exp), with =<span class="st"> </span><span class="ot">FALSE</span>]</code></pre></div>
<ul>
<li>tabulation</li>
</ul>
<p>In data table. <code>.N</code> means to count。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># row count</span>
dt[, .N] </code></pre></div>
<pre><code>## [1] 1000</code></pre>
<p>If you assign the group variable, then it will count by groups:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># counts by gender</span>
dt[, .N, by=<span class="st"> </span>gender]  </code></pre></div>
<pre><code>##    gender   N
## 1: Female 554
## 2:   Male 446</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># for those younger than 30, count by gender</span>
 dt[age &lt;<span class="st"> </span><span class="dv">30</span>, .(<span class="dt">count=</span>.N), by=<span class="st"> </span>gender] </code></pre></div>
<pre><code>##    gender count
## 1: Female   292
## 2:   Male    86</code></pre>
<p>Order table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get records with the highest 5 online expense:</span>
<span class="kw">head</span>(dt[<span class="kw">order</span>(-online_exp)],<span class="dv">5</span>) </code></pre></div>
<pre><code>##    age gender income house store_exp online_exp
## 1:  40 Female 217600    No      7024       9479
## 2:  41 Female     NA   Yes      3787       8638
## 3:  36   Male 228550   Yes      3280       8221
## 4:  31 Female 159508   Yes      5177       8006
## 5:  43 Female 190407   Yes      4695       7876
##    store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
## 1:          10            6  1  4  5  4  3  4  4  1  4
## 2:          14           10  1  4  4  4  4  4  4  1  4
## 3:           8           12  1  4  5  4  4  4  4  1  4
## 4:          11           13  1  4  4  4  4  4  4  1  4
## 5:           6           11  1  4  5  4  4  4  4  1  4
##    Q10     segment
## 1:   2 Conspicuous
## 2:   2 Conspicuous
## 3:   1 Conspicuous
## 4:   2 Conspicuous
## 5:   2 Conspicuous</code></pre>
<p>Since data table keep some characters of data frame, they share some operations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[<span class="kw">order</span>(-online_exp)][<span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<pre><code>##    age gender income house store_exp online_exp
## 1:  40 Female 217600    No      7024       9479
## 2:  41 Female     NA   Yes      3787       8638
## 3:  36   Male 228550   Yes      3280       8221
## 4:  31 Female 159508   Yes      5177       8006
## 5:  43 Female 190407   Yes      4695       7876
##    store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
## 1:          10            6  1  4  5  4  3  4  4  1  4
## 2:          14           10  1  4  4  4  4  4  4  1  4
## 3:           8           12  1  4  5  4  4  4  4  1  4
## 4:          11           13  1  4  4  4  4  4  4  1  4
## 5:           6           11  1  4  5  4  4  4  4  1  4
##    Q10     segment
## 1:   2 Conspicuous
## 2:   2 Conspicuous
## 3:   1 Conspicuous
## 4:   2 Conspicuous
## 5:   2 Conspicuous</code></pre>
<p>You can also order the table by more than one variable. The following code will order the table by <code>gender</code>, then order within <code>gender</code> by <code>online_exp</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[<span class="kw">order</span>(gender, -online_exp)][<span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<pre><code>##    age gender income house store_exp online_exp
## 1:  40 Female 217600    No      7024       9479
## 2:  41 Female     NA   Yes      3787       8638
## 3:  31 Female 159508   Yes      5177       8006
## 4:  43 Female 190407   Yes      4695       7876
## 5:  50 Female 263858   Yes      5814       7449
##    store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
## 1:          10            6  1  4  5  4  3  4  4  1  4
## 2:          14           10  1  4  4  4  4  4  4  1  4
## 3:          11           13  1  4  4  4  4  4  4  1  4
## 4:           6           11  1  4  5  4  4  4  4  1  4
## 5:          11           11  1  4  5  4  4  4  4  1  4
##    Q10     segment
## 1:   2 Conspicuous
## 2:   2 Conspicuous
## 3:   2 Conspicuous
## 4:   2 Conspicuous
## 5:   1 Conspicuous</code></pre>
<ul>
<li>Use <code>fread()</code> to import dat</li>
</ul>
<p>Other than <code>read.csv</code> in base R, we have introduced ‘read_csv’ in ‘readr’. <code>read_csv</code> is much faster and will provide progress bar which makes user feel much better (at least make me feel better). <code>fread()</code> in <code>data.table</code> further increase the efficiency of reading data. The following are three examples of reading the same data file <code>topic.csv</code>. The file includes text data scraped from an agriculture forum with 209670 rows and 6 columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/topic.csv&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">  user  system elapsed 
  4.313   0.027   4.340</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-readr::<span class="kw">read_csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/topic.csv&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">   user  system elapsed 
  0.267   0.008   0.274 </code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-data.table::<span class="kw">fread</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/topic.csv&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">   user  system elapsed 
  0.217   0.005   0.221 </code></pre></div>
<p>It is clear that <code>read_csv()</code> is much faster than <code>read.csv()</code>. <code>fread()</code> is a little faster than <code>read_csv()</code>. As the size increasing, the difference will become for significant. Note that <code>fread()</code> will read file as <code>data.table</code> by default.</p>
</div>
</div>
<div id="summarize-data" class="section level3">
<h3><span class="header-section-number">4.1.2</span> Summarize data</h3>
<div id="apply-lapply-and-sapply-in-base-r" class="section level4">
<h4><span class="header-section-number">4.1.2.1</span> <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code> in base R</h4>
<p>There are some powerful functions to summarize data in base R, such as <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code>. They do the same basic things and are all from “apply” family: apply functions over parts of data. They differ in two important respects:</p>
<ol style="list-style-type: decimal">
<li>the type of object they apply to</li>
<li>the type of result they will return</li>
</ol>
<p>When do we use <code>apply()</code>? When we want to apply a function to margins of an array or matrix. That means our data need to be structured. The operations can be very flexible. It returns a vector or array or list of values obtained by applying a function to margins of an array or matrix.</p>
<p>For example you can compute row and column sums for a matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## simulate a matrix
x &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">x1 =</span><span class="dv">1</span>:<span class="dv">8</span>, <span class="dt">x2 =</span> <span class="kw">c</span>(<span class="dv">4</span>:<span class="dv">1</span>, <span class="dv">2</span>:<span class="dv">5</span>))
<span class="kw">dimnames</span>(x)[[<span class="dv">1</span>]] &lt;-<span class="st"> </span>letters[<span class="dv">1</span>:<span class="dv">8</span>]
<span class="kw">apply</span>(x, <span class="dv">2</span>, mean)</code></pre></div>
<pre><code>##  x1  x2 
## 4.5 3.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">col.sums &lt;-<span class="st"> </span><span class="kw">apply</span>(x, <span class="dv">2</span>, sum)
row.sums &lt;-<span class="st"> </span><span class="kw">apply</span>(x, <span class="dv">1</span>, sum)</code></pre></div>
<p>You can also apply other functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ma &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">6</span>:<span class="dv">8</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)
ma</code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    3    1    7
## [2,]    2    4    6    8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(ma, <span class="dv">1</span>, table)  <span class="co">#--&gt; a list of length 2</span></code></pre></div>
<pre><code>## [[1]]
## 
## 1 3 7 
## 2 1 1 
## 
## [[2]]
## 
## 2 4 6 8 
## 1 1 1 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(ma, <span class="dv">1</span>, stats::quantile) <span class="co"># 5 x n matrix with rownames</span></code></pre></div>
<pre><code>##      [,1] [,2]
## 0%      1  2.0
## 25%     1  3.5
## 50%     2  5.0
## 75%     4  6.5
## 100%    7  8.0</code></pre>
<p>Results can have different lengths for each call. This is a trickier example. What will you get?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Example with different lengths for each call
z &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">24</span>, <span class="dt">dim =</span> <span class="dv">2</span>:<span class="dv">4</span>)
zseq &lt;-<span class="st"> </span><span class="kw">apply</span>(z, <span class="dv">1</span>:<span class="dv">2</span>, function(x) <span class="kw">seq_len</span>(<span class="kw">max</span>(x)))
zseq         ## a 2 x 3 matrix
<span class="kw">typeof</span>(zseq) ## list
<span class="kw">dim</span>(zseq) ## 2 3
zseq[<span class="dv">1</span>,]
<span class="kw">apply</span>(z, <span class="dv">3</span>, function(x) <span class="kw">seq_len</span>(<span class="kw">max</span>(x)))</code></pre></div>
<ul>
<li><code>lapply()</code> applies a function over a list, data.frame or vector and returns a list of the same length.</li>
<li><code>sapply()</code> is a user-friendly version and wrapper of <code>lapply()</code>. By default it returns a vector, matrix or if <code>simplify = &quot;array&quot;</code>, an array if appropriate. <code>apply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> is the same as <code>lapply(x, f)</code>. If <code>simplify=TRUE</code>, then it will return a <code>data.frame</code> instead of <code>list</code>.</li>
</ul>
<p>Let’s use some data with context to help you better understand the functions.</p>
<ul>
<li>Get the mean and standard deviation of all numerical variables in the dataset.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Read data</span>
sim.dat&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)
<span class="co"># Get numerical variables</span>
sdat&lt;-sim.dat[,!<span class="kw">lapply</span>(sim.dat,class)==<span class="st">&quot;factor&quot;</span>]
## Try the following code with apply() function
## apply(sim.dat,2,class)
## What is the problem?</code></pre></div>
<p>The data frame <code>sdat</code> only includes numeric columns. Now we can go head and use <code>apply()</code> to get mean and standard deviation for each column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,function(x) <span class="kw">mean</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp 
##    3.884e+01    1.135e+05    1.357e+03    2.120e+03 
##  store_trans online_trans           Q1           Q2 
##    5.350e+00    1.355e+01    3.101e+00    1.823e+00 
##           Q3           Q4           Q5           Q6 
##    1.992e+00    2.763e+00    2.945e+00    2.448e+00 
##           Q7           Q8           Q9          Q10 
##    3.434e+00    2.396e+00    3.085e+00    2.320e+00</code></pre>
<p>Here we defined a function using <code>function(x) mean(na.omit(x))</code>. It is a very simple function. It tells R to ignore the missing value when calculating the mean. <code>MARGIN=2</code> tells R to apply the function to each column. It is not hard to guess what <code>MARGIN=1</code> mean. The result show that the average online expense is much higher than store expense. You can also compare the average scores across different questions. The command to calculate standard deviation is very similar. The only difference is to change <code>mean()</code> to <code>sd()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp 
##       16.417    49842.287     2774.400     1731.224 
##  store_trans online_trans           Q1           Q2 
##        3.696        7.957        1.450        1.168 
##           Q3           Q4           Q5           Q6 
##        1.402        1.155        1.284        1.439 
##           Q7           Q8           Q9          Q10 
##        1.456        1.154        1.118        1.136</code></pre>
<p>Even the average online expense is higher than store expense, the standard deviation for store expense is much higher than online expense which indicates there is very likely some big/small purchase in store. We can check it quickly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(sdat$store_exp)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    -500     205     329    1360     597   50000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(sdat$online_exp)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##      69     420    1940    2120    2440    9480</code></pre>
<p>There are some odd values in store expense. The minimum value is -500 which is a wrong imputation which indicates that you should preprocess data before analyzing it. Checking those simple statistics will help you better understand your data. It then gives you some idea how to preprocess and analyze them. How about using <code>lapply()</code> and <code>sapply()</code>?</p>
<p>Run the following code and compare the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lapply</span>(sdat, function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))
<span class="kw">sapply</span>(sdat, function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))
<span class="kw">sapply</span>(sdat, function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)), <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</code></pre></div>
</div>
</div>
<div id="dplyr-package" class="section level3">
<h3><span class="header-section-number">4.1.3</span> <code>dplyr</code> package</h3>
<p><code>dplyr</code> provides a flexible grammar of data manipulation focusing on tools for working with data frames (hence the <code>d</code> in the name). It is faster and more friendly:</p>
<ul>
<li>It identifies the most important data manipulations and make they easy to use from R</li>
<li>It performs faster for in-memory data by writing key pieces in C++ using <code>Rcpp</code></li>
<li>The interface is the same for data frame, data table or database.</li>
</ul>
<p>We will illustrate the following functions in order:</p>
<ol style="list-style-type: decimal">
<li>Display</li>
<li>Subset</li>
<li>Summarize</li>
<li>Create new variable</li>
<li>Merge</li>
</ol>
<p><strong>Display</strong></p>
<ul>
<li><code>tbl_df()</code>: Convert the data to <code>tibble</code> which offers better checking and printing capabilities than traditional data frames. It will adjust output width according to fit the current window.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="kw">tbl_df</span>(sim.dat)</code></pre></div>
<ul>
<li><code>glimpse()</code>: This is like a transposed version of <code>tbl_df()</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glimpse</span>(sim.dat)</code></pre></div>
<p><strong>Subset</strong></p>
<p>Get rows with <code>income</code> more than 300000:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)
<span class="kw">filter</span>(sim.dat, income &gt;<span class="dv">300000</span>) %&gt;%
<span class="st">  </span><span class="kw">tbl_df</span>()</code></pre></div>
<pre><code>## # A tibble: 4 x 19
##     age gender income  house store_exp online_exp
##   &lt;int&gt; &lt;fctr&gt;  &lt;dbl&gt; &lt;fctr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1    40   Male 301398    Yes      4840       3618
## 2    33   Male 319704    Yes      5998       4396
## 3    41   Male 317476    Yes      3030       4180
## 4    37 Female 315697    Yes      6549       4284
## # ... with 13 more variables: store_trans &lt;int&gt;,
## #   online_trans &lt;int&gt;, Q1 &lt;int&gt;, Q2 &lt;int&gt;, Q3 &lt;int&gt;,
## #   Q4 &lt;int&gt;, Q5 &lt;int&gt;, Q6 &lt;int&gt;, Q7 &lt;int&gt;, Q8 &lt;int&gt;,
## #   Q9 &lt;int&gt;, Q10 &lt;int&gt;, segment &lt;fctr&gt;</code></pre>
<p>Here we meet a new operator <code>%&gt;%</code>. It is called “Pipe operator” which pipes a value forward into an expression or function call. What you get in the left operation will be the first argument or the only argument in the right operation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x %&gt;%<span class="st"> </span><span class="kw">f</span>(y) =<span class="st"> </span><span class="kw">f</span>(x, y)
y %&gt;%<span class="st"> </span><span class="kw">f</span>(x, ., z) =<span class="st"> </span><span class="kw">f</span>(x, y, z )</code></pre></div>
<p>It is an operator from <code>magrittr</code> which can be really beneficial. Look at the following code. Can you tell me what it does?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ave_exp &lt;-<span class="st"> </span><span class="kw">filter</span>( 
  <span class="kw">summarise</span>(
    <span class="kw">group_by</span>( 
      <span class="kw">filter</span>(
        sim.dat, 
        !<span class="kw">is.na</span>(income)
      ), 
      segment
    ), 
    <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
    <span class="dt">n =</span> <span class="kw">n</span>()
  ), 
  n &gt;<span class="st"> </span><span class="dv">200</span>
) </code></pre></div>
<p>Now look at the identical code using “<code>%&gt;%</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ave_exp &lt;-<span class="st"> </span>sim.dat %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(income)) %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">group_by</span>(segment) %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">summarise</span>( 
   <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
   <span class="dt">n =</span> <span class="kw">n</span>() ) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n &gt;<span class="st"> </span><span class="dv">200</span>)</code></pre></div>
<p>Isn’t it much more straightforward now? Let’s read it:</p>
<ol style="list-style-type: decimal">
<li>Delete observations from <code>sim.dat</code> with missing income values</li>
<li>Group the data from step 1 by variable <code>segment</code></li>
<li>Calculate mean of online expense for each segment and save the result as a new variable named <code>ave_online_exp</code></li>
<li>Calculate the size of each segment and saved it as a new variable named <code>n</code></li>
<li>Get segments with size larger than 200</li>
</ol>
<p>You can use <code>distinct()</code> to delete duplicated rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">distinct</span>(sim.dat)</code></pre></div>
<p><code>sample_frac()</code> will randomly select some rows with a specified percentage. <code>sample_n()</code> can randomly select rows with a specified number.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">sample_frac</span>(sim.dat, <span class="fl">0.5</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) 
dplyr::<span class="kw">sample_n</span>(sim.dat, <span class="dv">10</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) </code></pre></div>
<p><code>slice()</code> will select rows by position:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">slice</span>(sim.dat, <span class="dv">10</span>:<span class="dv">15</span>) </code></pre></div>
<p>It is equivalent to <code>sim.dat[10:15,]</code>.</p>
<p><code>top_n()</code> will select the order top n entries:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">top_n</span>(sim.dat,<span class="dv">2</span>,income)</code></pre></div>
<p>If you want to select columns instead of rows, you can use <code>select()</code>. The following are some sample codes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select by column name</span>
dplyr::<span class="kw">select</span>(sim.dat,income,age,store_exp)

<span class="co"># select columns whose name contains a character string</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">contains</span>(<span class="st">&quot;_&quot;</span>))

<span class="co"># select columns whose name ends with a character string</span>
<span class="co"># similar there is &quot;starts_with&quot;</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">ends_with</span>(<span class="st">&quot;e&quot;</span>))

<span class="co"># select columns Q1,Q2,Q3,Q4 and Q5</span>
<span class="kw">select</span>(sim.dat, <span class="kw">num_range</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span>:<span class="dv">5</span>)) 

<span class="co"># select columns whose names are in a group of names</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">one_of</span>(<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;income&quot;</span>)))

<span class="co"># select columns between age and online_exp</span>
dplyr::<span class="kw">select</span>(sim.dat, age:online_exp)

<span class="co"># select all columns except for age</span>
dplyr::<span class="kw">select</span>(sim.dat, -age)</code></pre></div>
<p><strong>Summarize</strong></p>
<p>A standard marketing problem is customer segmentation. It usually starts with designing survey and collecting data. Then run a cluster analysis on the data to get customer segments. Once we have different segments, the next is to understand how each group of customer look like by summarizing some key metrics. For example, we can do the following data aggregation for different segments of clothes customers.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat%&gt;%
<span class="st">  </span><span class="kw">group_by</span>(segment)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">Age=</span><span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(age)),<span class="dv">0</span>),
      <span class="dt">FemalePct=</span><span class="kw">round</span>(<span class="kw">mean</span>(gender==<span class="st">&quot;Female&quot;</span>),<span class="dv">2</span>),
      <span class="dt">HouseYes=</span><span class="kw">round</span>(<span class="kw">mean</span>(house==<span class="st">&quot;Yes&quot;</span>),<span class="dv">2</span>),
      <span class="dt">store_exp=</span><span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(store_exp),<span class="dt">trim=</span><span class="fl">0.1</span>),<span class="dv">0</span>),
      <span class="dt">online_exp=</span><span class="kw">round</span>(<span class="kw">mean</span>(online_exp),<span class="dv">0</span>),
      <span class="dt">store_trans=</span><span class="kw">round</span>(<span class="kw">mean</span>(store_trans),<span class="dv">1</span>),
      <span class="dt">online_trans=</span><span class="kw">round</span>(<span class="kw">mean</span>(online_trans),<span class="dv">1</span>))</code></pre></div>
<pre><code>## # A tibble: 4 x 8
##       segment   Age FemalePct HouseYes store_exp
##        &lt;fctr&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
## 1 Conspicuous    42      0.32     0.86      4990
## 2       Price    60      0.45     0.94       501
## 3     Quality    35      0.47     0.34       301
## 4       Style    24      0.81     0.27       200
## # ... with 3 more variables: online_exp &lt;dbl&gt;,
## #   store_trans &lt;dbl&gt;, online_trans &lt;dbl&gt;</code></pre>
<p>Now, let’s peel the onion in order.</p>
<p>The first line <code>sim.dat</code> is easy. It is the data you want to work on. The second line <code>group_by(segment)</code> tells R that in the following steps you want to summarise by variable <code>segment</code>. Here we only summarize data by one categorical variable, but you can group by multiple variables, such as <code>group_by(segment, house)</code>. The third argument <code>summarise</code> tells R the manipulation(s) to do. Then list the exact actions inside <code>summarise()</code> . For example, <code>Age=round(mean(na.omit(age)),0)</code> tell R the following things:</p>
<ol style="list-style-type: decimal">
<li>Calculate the mean of column <code>age</code> ignoring missing value for each customer segment</li>
<li>Round the result to the specified number of decimal places</li>
<li>Store the result in a new variable named <code>Age</code></li>
</ol>
<p>The rest of the command above is similar. In the end, we calculate the following for each segment:</p>
<ol style="list-style-type: decimal">
<li><code>Age</code>: average age for each segment</li>
<li><code>FemalePct</code>: percentage for each segment</li>
<li><code>HouseYes</code>: percentage of people who own a house</li>
<li><code>stroe_exp</code>: average expense in store</li>
<li><code>online_exp</code>: average expense online</li>
<li><code>store_trans</code>: average times of transactions in the store</li>
<li><code>online_trans</code>: average times of online transactions</li>
</ol>
<p>There is a lot of information you can extract from those simple averages.</p>
<ul>
<li><p>Conspicuous: average age is about 40. It is a group of middle-age wealthy people. 1/3 of them are female, and 2/3 are male. They buy regardless the price. Almost all of them own house (0.86). It makes us wonder what is wrong with the rest 14%?</p></li>
<li><p>Price: They are older people with average age 60. Nearly all of them own a house(0.94). They are less likely to purchase online (store_trans=6 while online_trans=3). It is the only group that is less likely to buy online.</p></li>
<li><p>Quality: The average age is 35. They are not way different with Conspicuous regarding age. But they spend much less. The percentages of male and female are similar. They prefer online shopping. More than half of them don’t own a house (0.66).</p></li>
<li><p>Style: They are young people with average age 24. The majority of them are female (0.81). Most of them don’t own a house (0.73). They are very likely to be digital natives and prefer online shopping.</p></li>
</ul>
<p>You may notice that Style group purchase more frequently online (<code>online_trans</code>) but the expense (<code>online_exp</code>) is not higher. It makes us wonder what is the average expense each time, so you have a better idea about the price range of the group.</p>
<p>The analytical process is aggregated instead of independent steps. The current step will shed new light on what to do next. Sometimes you need to go back to fix something in the previous steps. Let’s check average one-time online and instore purchase amounts:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat%&gt;%
<span class="kw">group_by</span>(segment)%&gt;%
<span class="kw">summarise</span>(<span class="dt">avg_online=</span><span class="kw">round</span>(<span class="kw">sum</span>(online_exp)/<span class="kw">sum</span>(online_trans),<span class="dv">2</span>),
    <span class="dt">avg_store=</span><span class="kw">round</span>(<span class="kw">sum</span>(store_exp)/<span class="kw">sum</span>(store_trans),<span class="dv">2</span>))</code></pre></div>
<pre><code>## # A tibble: 4 x 3
##       segment avg_online avg_store
##        &lt;fctr&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1 Conspicuous     442.27     479.2
## 2       Price      69.28      81.3
## 3     Quality     126.05     105.1
## 4       Style      92.83     121.1</code></pre>
<p>Price group has the lowest averaged one-time purchase. The Conspicuous group will pay the highest price. When we build customer profile in real life, we will also need to look at the survey summarization. You may be surprised how much information simple data manipulations can provide.</p>
<p>Another comman task is to check which column has missing values. It requires the program to look at each column in the data. In this case you can use <code>summarise_all</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># apply function anyNA() to each column</span>
<span class="co"># you can also assign a function vector such as: c(&quot;anyNA&quot;,&quot;is.factor&quot;)</span>
dplyr::<span class="kw">summarise_all</span>(sim.dat, <span class="kw">funs_</span>(<span class="kw">c</span>(<span class="st">&quot;anyNA&quot;</span>)))</code></pre></div>
<pre><code>##     age gender income house store_exp online_exp
## 1 FALSE  FALSE   TRUE FALSE     FALSE      FALSE
##   store_trans online_trans    Q1    Q2    Q3    Q4
## 1       FALSE        FALSE FALSE FALSE FALSE FALSE
##      Q5    Q6    Q7    Q8    Q9   Q10 segment
## 1 FALSE FALSE FALSE FALSE FALSE FALSE   FALSE</code></pre>
<p>The above code returns a vector indicating if there is any value missing in each column.</p>
<p><strong>Create new variable</strong></p>
<p>There are often situations where you need to create new variables. For example, adding online and store expense to get total expense. In this case, you will apply <strong>window function</strong> to the columns and return a column with the same length. <code>mutate()</code> can do it for you and append one or more new columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">mutate</span>(sim.dat, <span class="dt">total_exp =</span> store_exp +<span class="st"> </span>online_exp)</code></pre></div>
<pre><code>##      age gender income house store_exp online_exp
## 1     57 Female 120963   Yes     529.1     303.51
## 2     63 Female 122008   Yes     478.0     109.53
## 3     59   Male 114202   Yes     490.8     279.25
## 4     60   Male 113616   Yes     347.8     141.67
## 5     51   Male 124253   Yes     379.6     112.24
## 6     59   Male 107661   Yes     338.3     195.69
## 7     57   Male 120483   Yes     482.5     284.54
## 8     57   Male 110542   Yes     340.7     135.26
## 9     61 Female 132061   Yes     608.2     142.55
## 10    60   Male 105049   Yes     470.3     163.47
## 11    58   Male 107197   Yes     366.6     170.13
## 12    59   Male     NA   Yes     674.9     310.27
## 13    64   Male 119020   Yes     613.9     160.85
## 14    57 Female     NA   Yes     737.0     224.53
## 15    64   Male 114539   Yes     402.5     241.83
## 16    61 Female     NA   Yes     615.1     238.10
## 17    57 Female 133078   Yes     429.4     262.66
## 18    63   Male 115709   Yes     552.6     187.52
## 19    57 Female 113211    No     540.3     254.58
## 20    57 Female 129774    No     384.3     311.03
## 21    58   Male     NA   Yes     372.4     296.83
## 22    58   Male 124357   Yes     535.5     205.54
## 23    59 Female 123117   Yes     481.3     157.29
## 24    61 Female     NA   Yes     546.2     161.23
## 25    60 Female     NA   Yes     411.1     123.78
## 26    56   Male     NA   Yes     492.7     128.02
## 27    58   Male 127887   Yes     519.3     142.63
## 28    64   Male 115925   Yes     627.7     240.98
## 29    63 Female     NA   Yes     511.1     203.49
## 30    56 Female 112621   Yes     699.3     223.44
## 31    57   Male     NA   Yes     530.6     217.92
## 32    59 Female 121773   Yes     532.1     176.88
## 33    63   Male 126903   Yes     601.6     257.84
## 34    55   Male 128254   Yes     595.3     248.06
## 35    60 Female     NA   Yes     403.6     236.96
## 36    64 Female     NA   Yes     611.7     102.24
## 37    57 Female 118170   Yes     482.7     183.36
## 38    57 Female 119148   Yes     412.9     246.87
## 39    58   Male 125844   Yes     473.8     261.67
## 40    55   Male 128194   Yes     595.7     156.93
## 41    59 Female     NA   Yes     548.3     186.50
## 42    61   Male     NA   Yes     597.2     209.68
## 43    59 Female 122338   Yes     455.3     205.16
## 44    58 Female 114519   Yes     493.5     271.67
## 45    62   Male 123459   Yes     561.7     209.23
## 46    59   Male 125626   Yes     518.2     261.31
## 47    56   Male 100583   Yes     633.0     195.95
## 48    66   Male     NA   Yes     510.3     198.46
## 49    62 Female 128606   Yes     499.7     244.05
## 50    54   Male 114337   Yes     518.0     217.25
##      store_trans online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
## 1              2            2  4  2  1  2  1  4  1  4
## 2              4            2  4  1  1  2  1  4  1  4
## 3              7            2  5  2  1  2  1  4  1  4
## 4             10            2  5  2  1  3  1  4  1  4
## 5              4            4  4  1  1  3  1  4  1  4
## 6              4            5  4  2  1  2  1  4  1  4
## 7              5            3  4  1  1  2  1  4  1  4
## 8             11            5  5  2  1  3  1  4  1  4
## 9              6            1  4  1  1  2  1  4  1  4
## 10            12            1  4  2  1  3  1  4  1  4
## 11             5            4  4  1  1  3  1  4  1  4
## 12             6            2  4  1  1  3  1  4  1  4
## 13             7            4  5  1  1  3  1  4  1  4
## 14             7            3  4  2  1  3  1  4  1  4
## 15             5            5  4  2  1  2  1  4  1  4
## 16             5            1  5  2  1  2  1  4  1  4
## 17             5            3  5  2  1  2  1  4  1  4
## 18             5            2  5  2  1  3  1  4  1  4
## 19             7            2  4  2  1  3  1  4  1  4
## 20             4            2  5  2  1  2  1  4  1  5
## 21            11            2  5  1  1  3  1  4  1  4
## 22             7            3  4  2  1  2  1  4  1  4
## 23             6            1  5  2  1  2  1  4  1  4
## 24             8            3  5  1  1  2  1  4  1  4
## 25            11            3  4  1  1  3  1  4  1  4
## 26             7            1  5  1  1  3  1  4  1  4
## 27             6            2  4  1  1  3  1  4  1  4
## 28             4            4  5  1  1  2  1  4  1  4
## 29             4            3  5  1  1  2  1  4  1  4
## 30             9            2  5  2  1  2  1  4  1  4
## 31             4            2  4  2  1  3  1  4  1  4
## 32             2            3  5  2  1  2  1  4  1  4
## 33             6            4  4  1  1  3  1  4  1  4
## 34             8            3  4  1  1  2  1  4  1  4
## 35             9            4  4  2  1  3  1  4  1  4
## 36             6            4  5  2  1  2  1  4  1  4
## 37             6            2  4  2  1  3  1  4  1  4
## 38             6            5  5  1  1  3  1  4  1  4
## 39             5            4  4  2  1  2  1  4  1  4
## 40             6            2  4  1  1  2  1  4  1  4
## 41             2            3  4  1  1  3  1  4  1  4
## 42             5            1  5  1  1  3  1  4  1  4
## 43             9            4  5  1  1  2  1  4  1  3
## 44             4            5  4  1  1  3  1  4  1  4
## 45             9            1  4  1  1  3  1  4  1  4
## 46             8            2  5  1  1  3  1  4  1  4
## 47            11            3  5  1  1  3  1  4  1  4
## 48             9            4  5  2  1  3  1  4  1  4
## 49             5            2  4  1  1  2  1  4  1  4
## 50             6            2  4  1  1  2  1  4  1  4
##      Q9 Q10     segment total_exp
## 1     2   4       Price     832.6
## 2     1   4       Price     587.5
## 3     1   4       Price     770.1
## 4     2   4       Price     489.5
## 5     2   4       Price     491.9
## 6     1   4       Price     534.0
## 7     1   4       Price     767.1
## 8     2   4       Price     476.0
## 9     1   4       Price     750.8
## 10    1   4       Price     633.8
## 11    2   4       Price     536.8
## 12    1   4       Price     985.1
## 13    2   4       Price     774.8
## 14    1   4       Price     961.6
## 15    1   4       Price     644.3
## 16    1   4       Price     853.2
## 17    1   4       Price     692.1
## 18    2   4       Price     740.1
## 19    2   4       Price     794.9
## 20    2   4       Price     695.4
## 21    1   4       Price     669.2
## 22    2   4       Price     741.0
## 23    1   4       Price     638.5
## 24    2   4       Price     707.4
## 25    1   4       Price     534.9
## 26    2   4       Price     620.7
## 27    2   4       Price     661.9
## 28    2   4       Price     868.7
## 29    1   4       Price     714.5
## 30    2   4       Price     922.8
## 31    1   4       Price     748.5
## 32    1   4       Price     709.0
## 33    2   4       Price     859.5
## 34    2   4       Price     843.3
## 35    1   4       Price     640.6
## 36    1   4       Price     713.9
## 37    1   4       Price     666.0
## 38    1   4       Price     659.8
## 39    2   4       Price     735.4
## 40    2   4       Price     752.6
## 41    1   4       Price     734.8
## 42    2   4       Price     806.9
## 43    2   4       Price     660.5
## 44    1   4       Price     765.2
## 45    1   4       Price     771.0
## 46    1   4       Price     779.5
## 47    2   4       Price     829.0
## 48    1   4       Price     708.7
## 49    2   4       Price     743.7
## 50    2   4       Price     735.3
##  [ reached getOption(&quot;max.print&quot;) -- omitted 950 rows ]</code></pre>
<p>The above code sums up two columns and appends the result (<code>total_exp</code>) to <code>sim.dat</code>. Another similar function is <code>transmute()</code>. The difference is that <code>transmute()</code> will delete the original columns and only keep the new ones.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">transmute</span>(sim.dat, <span class="dt">total_exp =</span> store_exp +<span class="st"> </span>online_exp) </code></pre></div>

</div>
</div>
<!-- </div> -->
            </section>

          </div>
        </div>
      </div>
<a href="data-wrangling.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="model-tuning-strategy.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook/js/app.min.js"></script>
<script src="libs/gitbook/js/lunr.js"></script>
<script src="libs/gitbook/js/plugin-search.js"></script>
<script src="libs/gitbook/js/plugin-sharing.js"></script>
<script src="libs/gitbook/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook/js/plugin-bookdown.js"></script>
<script src="libs/gitbook/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/happyrabbit/IntroDataScience/05-DataWrangling.Rmd",
"text": "Edit"
},
"download": ["IDS.pdf", "IDS.epub", "IDS.mobi"],
"toc": {
"collapse": "none"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
