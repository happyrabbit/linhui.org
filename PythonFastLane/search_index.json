[
["index.html", "Python速成指南 第1章 版权声明", " Python速成指南 简单、快速、享受Python编程 作者：Norm Matloff（University of California, Davis） 译者：林荟 (DuPont Pioneer) 10 November 2016 第1章 版权声明 本书由Norm Matloff所著，作者授权林荟翻译。本作品采用知识共享署名-非商业性使用-禁止演绎3.0 美国许可协议进行许可。本书版权由Norm Matloff所有，但允许将内容用于教学，使用请注明作者和以上许可信息。本书作者尽力减少书中的错误，但不保证内容为完全无误。 "],
["section-2.html", "第2章 作者介绍", " 第2章 作者介绍 Norman Matloff 著名计算机科学家兼统计学家，美国加州大学戴维斯分校计算机科学系教授，曾是该校统计专业的创建者之一，并担任过统计学教授。他曾经在硅谷从事数据库软件开发，为公司（如Kaiser Permanente Health Plan）提供统计咨询。 Matloff教授生于洛杉矶，在洛杉矶东部和圣盖博谷长大。他从加州大学洛杉矶分校获得数学博士，方向是概率统计。他在统计和计算机期刊上发表了大量论文。当前的研究兴趣在并行处理，统计计算和回归方法。 Matloff还曾是11.3 IFIP工作小组的成员，这是一个专注于数据库软件安全的国际委员会，由联合国教科文组织的领导下成立。他是加州大学戴维斯分校统计学院的创建者之一，并且参与了该校计算机科学院的创立。他曾获得校园杰出教学奖和杰出公共服务奖。 Matloff著有两本教科书，撰写了许多关于计算机的网络教程，如Linux操作系统和Python编程。他和Peter Salzman博士共同著有“The Art of Debugging with GDB, DDD, and Eclipse”。Matloff的书《R语言编程艺术》出版于2011年。他的《数据科学并行计算》发表于2014年。同时他还是多本开源教科书的作者，包括“From Algorithms to Z-Scores: Probabilistic and Statistical Modeling in Computer Science (http://heather.cs.ucdavis.edu/probstatbook)”和“Programming on Parallel Machines (http://heather.cs.ucdavis.edu/˜matloff/ParProcBook.pdf)”。 "],
["section-3.html", "第3章 前言 3.1 为什么用Python? 3.2 如何使用该教程", " 第3章 前言 恭喜你！ 我敢打赌，你以为我恭喜你是因为你已经开始决定学习世界上最优雅、强大的编程语言之一。当然，这是值得祝贺的，但我恭喜你的真正原因是，由于你居然在阅读一本书的前言，这说明你明显属于那稀少的小部分读者群体——有思想，有眼光，有创意：）！ 我在前言中将会介绍什么是Python，我想要在这本书里讲什么，以及如何使用这本书。 什么是脚本语言（Scripting Languages）？ C和C++之类的语言可以在非常细节的层级编程，因此执行的速度快（尤其是C）。但在大部分应用中，速度并不是主要的问题——你为嘛要费尽心在写邮件的时候快那3微秒？因此，在许多情况下，人们都倾向于使用更高层级的语言。例如，对于文本操作应用，C/C++的基础单元是字符。然而对于Python和Perl这样的语言，基础单元是文本行和每行中的词。在C/C++中你能够对行和每个词进行操作，但你要花更多的努力去完成这些操作。因此，使用脚本语言在这个方面能够节省时间并且提高编程体验。 脚本语言这个词从来没有正式的定义，但下面是其典型特征： 对变量类型的使用比较随意。如，整数，浮点或者字符串变量之间区别很小。函数可以返回非数值结果，如阵列（array）。非数值变量也可以作为循环指针等。 许多该语言固有的高层级操作，如字符串连接，推/托栈（stack push/pop）。 直译语言，不需要像编译语言那样经过编译器现行编译为机器码。 3.1 为什么用Python? 第一个流行的脚本语言是Perl。这门语言至今仍在广泛使用， 但当前蓬勃发展的是Python和类似于Python的语言Ruby。许多人，包括我，都无疑倾向于使用Python而非Perl，因为前者更加简洁优美。Python在Google的程序员中非常受欢迎。Python的支持者通常叫做Python粉（pythonistas），他们声称所有程序编写都该使用Python，因为它是那么简洁，使编程如此愉悦。他们认为Python比C或者C++都好[脚注：再次声明，当运行速度对你而言是个大问题的时候除外]。个人认为C++被夸大了，它的各组分之间的兼容性不是很好；Java更好，但是其强类型的本质在我看来挺讨厌的，有碍于清晰的编程。我很高兴看到Eric Raymond，开源运动的杰出倡导者，对C++、Java和Python也表达过和我类似的观点。 3.2 如何使用该教程 背景要求 所有人，即使是那些只有很少编程经验的人，对1.6小节之前的内容应该不会觉得太困难。 从1.10小节开始的内容对于有面向对象的程序设计（OOP）经验（如C++或者Java）的人来说应该不难。如果你没有相关的经验，也可以阅读这些章节，但可能需要花更多的时间，这部分读者可以专注例子而非专业术语。 在一些地方可能出现Linux语境，因此有一些Linux的知识会很有帮助，但并不是必须的。Python不仅仅只能用于Linux，也可用于Windows和Macintosh（这里大部分Linux的语句同样适用于Mac）。 讲解方式 我的讲解方法和大部分Python的书籍和网络教程不同。通常的方法是从一开始就事无巨细的覆盖每一个细节，不管具体的语境。例如，通常的方法是先告诉你Python中整数的所有可能的形式，变量名所有的形式，类似的，列出许多不同的启动Python的方式。 在本书中我尽量避免这些。再次说明，本书的目的是让读者能够快速掌握Python的基础知识。读者应该能够直接根据需要进入一些特殊的主题。因此，假如你想知道Python的变量名中是否能够含有下划线”_”，本书不是一个正确的选择。如果你想快速学习Python，希望这本书是一个正确的选择。 什么时候读本书，读哪部分 我建议读者先读1.6小节之前的部分，然后自己尝试使用Python。先尝试Python的交互模式（1.1.5小节），然后试着写 一些短小的程序。可以是全新的程序，或者仅仅是在下面展示的例子基础上进行修改（脚注2：你可以从http://heather.cs.ucdavis.edu/˜matloff/Python/PLN下载本书.txt的原文件，这样你就不用自己键入这些代码。你可以将这些文件进行备份，只储存需要的代码行。但如果你自己键入这些案例代码，务必确保和书中一模一样，尤其是缩进。这很重要，关于这点我在之后会介绍。）。 这将让你更具体的感知Python。如果你使用Python的主要目的是编写短小的代码而不会用到Python程序包，那么到此为止的知识可能就够了。但大部分读者可能需要更进一步，学习基本的Python面向对象的程序设计功能以及Python模块/包。这种情况下，你应该接着阅读1.16小节。 本书剩下的部分是关于不同的话题，如文件和目录，网络等等。 不要忘了阅读调试代码的章节！阅读的越早越好，越勤越好。 个人偏见 编程是个人的，有创意的活动，因此每个人都有自己的观点和偏好。（好吧，对那些强迫性的坚信任何在编程课上学习到的东西的那些人是例外。但再次说明，这样的人不会读此前言。）以下是关于本书的笔者个人偏见： 我并不认为全局变量是不好的。 GUI很好，但是它们很花时间。我是一个讲究实际效率的人，因此如果一门程序语言用文本的形式就可以执行，我觉得就够了。 在某种程度上我喜欢面向对象的范式，尤其是Python这样的。然而我相信这有时妨碍了我，让我花大量额外功夫但只获得非常微小的收益。因此我只是适当的使用。 更新的未必是更好的。抱歉，本书不适用Python3。我并不反对新版本，只是并没有看到它有什么更好的地方。不管怎样，Python 3并未广泛使用。 抽象化并不是进步的标志。这和我上面的最后两点相关。我喜欢Python是因为它强大的同时简单优美，并不强调一些华丽的装饰。 "],
["section-4.html", "第4章 第一章 4.1 介绍", " 第4章 第一章 4.1 介绍 让我们立刻开始编程吧. 4.1.1 5分钟的入门案例 4.1.1.1 案例代码 下面是一个简单、快速的例子。假设我希望得到下面方程的值： \\[g(x)=\\frac{x}{1-x^2}\\] 对于所有\\(x=0.0, 0.1, \\dots, 0.9\\)。我能够通过下面的代码进行该计算： for i in range(10): x = 0.1*i print x print x/(1-x*x) 你可以将这段代码存入一个文件中，比如fme.py。然后通过在命令行提示符下键入下面代码执行[译者注：你要到文件所在的目录下键入该命令]： python fme.py 执行结果大概如下： 0.0 0.0 0.1 0.10101010101 0.2 0.208333333333 0.3 0.32967032967 0.4 0.47619047619 0.5 0.666666666667 0.6 0.9375 0.7 1.37254901961 0.8 2.22222222222 0.9 4.73684210526 4.1.1.2 Python列表（Lists） 上面的代码是怎么工作的？首先，Python的 range()函数是一个使用列表的例子，即，Python阵列，虽然不是那么明显。【脚注1：这里我大致将其称为“阵列”，但如你们之后会见到的，这里的阵列定义比C/C++中的宽松许多。换句话说，获取真正的阵列速度快得多。在 C/C++中，阵列X中的第i个元素就是从第一个元素向后数i次，这样我们可以马上得到该元素。但对于Python却不可能，因此后者速度更慢。Python中的NumPy包提供了真正的阵列操作。】列表绝对是Python的基础，因此大家要对讲到列表的地方特别注意。不要仅仅关注其字面的意思，而是要将其当成Python中的“列表”。 Python中的range()函数返回一列连续的整数，在当前例子中是[0,1,2,3,4,5,6,7,8,9]。注意这是Python对列表的正式表达方式——方括号中通过逗号分隔的一系列对象（它们不一定只能是数字，也可以是各种其它对象）。 4.1.1.3 循环（Loops） 因此上面的语句和下面的等价： for i in [0,1,2,3,4,5,6,7,8,9]: 不难猜测，这会导致10次迭代，i的取值从0开始，然后1……代码： for i in [2,3,6]: 对应3次迭代，i取值为2,、3和6。 Python也有while语句（但没有until语句）。和C/C++一样，其也有break声明，用来提早结束循环。例如： x = 5 while 1: x += 1 if x == 8: print x break 类似的，continue声明也很有用，它告诉Python跳过当前循环中的剩下部分。例如，尝试执行下面代码： sum = 0 for i in [5,12,13]: if i 结果是输出12+13的值，也就是25。 pass语句告诉Python什么也不要做。 4.1.1.4 Python代码块定义 现在让我们着眼于上面for语句末尾的那个貌似无辜的冒号“:”，该符号定义了一个Python代码块的开始。和C/C++甚至Perl语言不同，它们使用“{}”来定义代码块，Python使用冒号和每行的缩进组合来定义代码块。我将用冒号来和Python解释器对话: Hi，Python解释器，你最近好吗？我只想告诉你，这个冒号之后下一行将开始一个代码块。我已经将之后的几行向右缩进，用这种方式告诉你这些代码属于一个代码块。 我选择使用3格缩进，但空格的数目并不重要，你只需要保证一个代码块中的每一行缩进的空格数目一致即可。例如下面代码（脚注2：这里g()是我之前定义的一个函数，这里并没有展示）： for i in range(10): print 0.1*i print g(0.1*i) Python解释器将报错，告诉我出现语法错误（脚注3：记住这个报错信息。Python新手常常遇到这个报错）。在一个代码块中，只有在其中有子代码块的时候，Python才允许你进一步向右缩进。如： for i in range(10): if i%2 == 1: print 0.1*i print g(0.1*i) 这里我只打印出i是奇数的情况；“%”符号表示“mod”操作，即余数，这和C/C++中类似。再一次注意句子末尾的“:”。两个print语句所在行和之前的if行相比进一步向右缩进了。 还有一件事需要再次强调，和C/C++/Perl不同，Python语句中没有用到分号“;”。新的一行意味着新的声明。如果你的命令行很长，可以使用“/”符号告诉Python下一行是上一行语句的继续，如： x = y + \\ z 大部分的C操作符在Python中也能使用，包括关系运算符，如“==”。0x代表十六进制，以及FORTRAN中的“**”代表乘方。 同样，“if”语句能够和“else”语句配对，你可以将“else if”简写成“elif”。 >> def f(x): ... if x > 0: return 1 ... else: return 0 ... >>> f(2) 1 >>> f(-1) 0 布尔操作是and、or和not。除了总是使用的True和False以外，也可以用非零和零分别表示真和假。取值为“None”被当做“False”。 之后你会看到更多的例子。 顺便说下，注意类似这样的Python语句：print a or b or c。在这个语句中，如果第一项a是真（非零），那么将会输出a的值而忽略剩下的b和c，这是Python的惯用法则。 4.1.1.5 Python也提供交互模式 Python的一个非常棒的功能是交互模式。通常情况下不会用到这些，但如果你想很快尝试一些新功能的话，可以使用它的交互模型观察这些功能如何工作。任何时候，只要你不确定某方法是不是行得通，记住这句箴言：“在你存疑时动手试试看！”，交互模式为此提供了极大的便利。在这个教程中我们也会经常用交互模式来快速展示Python的某项功能。和我们之前展示的批量执行代码不同，我们可以键入代码并且在交互模式下运行： % python >>> for i in range(10): ... x = 0.1*i ... print x ... print x/(1-x*x) ... 0.0 0.0 0.1 0.10101010101 0.2 0.208333333333 0.3 0.32967032967 0.4 0.47619047619 0.5 0.666666666667 0.6 0.9375 0.7 1.37254901961 0.8 2.22222222222 0.9 4.73684210526 >>> 先打开Python，然后你会看到“&gt;&gt;&gt;”这个交互式提示符。然后在该提示符后逐行键入命令。每个代码块的行中都有一个特殊的提示符“…”。当我在代码末尾键入空白行时，Python解释器就知道你的代码已经结束了，然后就会执行这些代码。【脚注4：这里交互模式让我们只执行单个Python声明或者表达。在当前例子中，我们执行单个“for”声明。交互模型的意图不是让我们键入所有的代码。从技术的角度，我们可以用“if 1:”开始代码块，是的整个程序变成一个巨大的if声明。当然，在Python中这样键入比较长的程序总归是不方便的。】 当我们在交互模式下的时候，你可以通过箭头键调出之前的历史代码，这样可以节省一些键入的时间。 要退出Python交互模式，只需要键入ctrl-d【译者注：这对linux有效，不适用于windows】。 自动输出 ：通过交互模式，如果你引用或者创建某个对象，甚至是一个表达，只要你没有将其指定给一个变量，控制器就会自动输出该对象结果（不需要特别的打印语句）。例如： >>> for i in range(4): ... 3*i ... 0 3 6 9 再次申明，这种情况适用于对部分对象，但是不包括一些表达，例如： >>> open(’x’) 这里代码表示打开x文件，从而产生一个文件对象。由于我们并没有将打开的文件制定给一个新的对象，比如f，以便之后使用该对象。也就是说我们没有键入这样的代码： f = open(’x’) Python会输出相关信息。但在这里，即使我们将其指定给一个对象，Python也会输出相关信息： >>> f = open(’x’) >>> f 4.1.1.6 Python的计算功能 你可能会将Python当做一个快速计算器使用（我常常这样）。例如，我想知道价格$88.88提高5 5% 后会是多少： % python >>> 1.05*88.88 93.323999999999998 我们还可以很快的转化10进制和16进制的数： >>> 0x12 18 >>> hex(18) ’0x12’ 如果需要使用数学函数，得导入Python的数学包。这和使用C/C++类似，其中我们通过#include起始的行调入需要的包，而且在使用时需要指出相关的包名。 我们需要在某个程序包的语境下使用相关函数，这里我们需要用到math包。比如使用函数sqrt()和sin() 的时候需要在前面用包名math作为前缀【脚注：省去前缀的方法之后会介绍】： >>> import math >>> math.sqrt(88) 9.3808315196468595 >>> math.sin(2.5) 0.59847214410395655 4.1.2 1.2 10分钟的入门案例 4.1.2.1 案例代码 下面的代码将读入一个文本文件，文件的名字在命令行中。然后打印出文件中的行数和字数： # reads in the text file whose name is specified on the command line, # and reports the number of lines and words import sys def checkline(): global l global wordcount w = l.split() wordcount += len(w) wordcount = 0 f = open(sys.argv[1]) flines = f.readlines() linecount = len(flines) for l in flines: checkline() print linecount, wordcount 假设我们将上面的代码存在一个名为tme.py的文件中。此外还有一个文本文件x，其内容如下： This is an example of a text file. 这里有5行，其中2行是空行。如果我们执行下面的代码可以得到结果： python tme.py x 5 8 表面上看，这里代码看上去像是C/C++程序：先是一个import声明，和#include声明类似（注意编译时对应的链接）；接下来是对一个函数的定义；再往后是主程序。这是阅读这段代码的很好的方式，但是记住，Python解释器会按顺序执行所有东西，从头开始。例如在执行import声明的时，可能顺带执行了一些代码，如果导入的模块（module）中含有一些除了函数以外的独立代码。我们在之后会进一步介绍这个。执行def声明不会导致执行实质性的程序，但是会执行定义函数这一操作。 下面是一些该代码中出现的之前没有讲到的特征： 使用命令行参数（command-line arguments） 文件操作机制（manipulation mechanisms） 更多关于列表（lists）的操作 定义函数 导入程序包 变量作用域 我会在接下来的几个小节中讨论这些特征。 4.1.2.2 命令行参数 首先让我们解释下sys.argv。Python中有一个名为sys的模块（或者包），其中含有一个叫做argv的变量，它是一个Python列表，可以和C/C++中的argv进行类比【脚注6：不需要为argc寻找类比。作为一门面向对象的语言，Python将列表（lists）视为对象（objects）。列表的长度包含在该对象内。因此如果我们要知道argv中的元素个数，可以使用len(argv)。】该列表中的第0个元素是脚本名字，这里是tme.py，依次类推，就和C/C++中一样。在当前例子中，我们在x文件上运行代码，sys.argv[1]就是字符’x’（在Python中，字符串通常用单引号引起来）。由于Python不会自动导入sys模块，所以需要用import命令导入。 对于C/C++和Python，这些命令行本身当然也是字符串。如果你想用这些字符串表示数字，可以通过atoi()对它们进行转化。在Python中，我们可以使用int()。如果想转化为浮点型，在Python中可以使用float()【脚注7：在C/C++中，如果可以的话，我们能使用atof()或者sscanf()进行转化】。 4.1.2.3 文件操作简介( open()函数和C/C++中的类似。代码行： f = open(sys.argv[1]) 创建了一个file类别的对象，并且将其指定给f。 将readlines()函数作用于file类别对象会返回一个列表（记得，“列表”是正式的Python术语），其中含有该文件中的每一行。每一行都是一个字符串，该字符串是列表的一个对象。由于这里的文件的内容有5行，readlines()返回的结果是一个含有5个元素的列表： ['','This is an','example of a','text file',''] 4.1.2.4 缺乏声明 Python中的变量无须特别声明。当赋值操作执行时就自动创建了一个变量。例如，在上面的tme.py代码中，执行下面声明后就创建了变量flines： flines = f.readlines() 顺便说一下，还没有赋值的变量，比如上面的wordcount，其值默认为None。 4.1.2.5 局部变量和全局变量 Python并没有C/C++那样严格意义上的全局变量。，全局变量在所有作用域都可访问。我们将在之后的1.14.6【add section reference】小节中进一步讨论。当前让我们假设源文件只含有一个.py文件；这种情况下，Python确实有类似C/C++的全局变量（虽然依旧有很大的不同）。 Python试着通过变量在代码中的位置来判断其作用范围。如果函数包含任何赋值语句，那么该变量默认是局部的，除非我们刻意使用关键词global。因此，在checkline()代码中，Python会假设l和wordcount对于checkline()来说都是局部的，如果我们没有特别指出其是全局变量的话。 使用全局变量简化了代码，个人认为对全局变量矫揉造作的批评是没有根据的（见http://heather.cs.ucdavis.edu/˜matloff/globals.html）。事实上，在重要的多线程（threads）编程中，是强制使用全局变量的。 但是你可能希望至少将所有的全局变量集结成一个组，如我在这里所做的。见附录1.24。 4.1.2.6 若干内置函数 函数len()返回的是一个列表中元素的个数。在上述tme.py的例子中，我们通过其来找到文件中的内容行，因为readlines()会返回一个列表，其中每个元素对应文件中的每行内容。 split()方法是string类【脚注8：类别函数被称为方法（methods）】。该方法会将一个字符串分成一列单词的列表【脚注9：默认设置是使用空格作为分割符，但也可以使用其它符号和字符串分割。】。因此，如在checkline()中，当l是’ This is an’时，列表w就是[’This’,’is’,’an’]。（在这里第一行是空行，相应的w就是一个空列表[]。） 4.1.3 变量/取值的类型 在典型的脚本语言中，C/C++意义上的int或者float类型变量在Python中并没有声明。 但是，Python解释器具有追踪所有对象的内在功能。因此Python变量没有类型，但是它们的取值有类别。换句话说，变量X可能在某个地方被当成整数使用，在另外一个地方又被当成类别使用。 Python的类别含有下面概念：标量，序列（列表或者元组）和字典（关联数组，将在第1.6小节讨论），类别，函数等等。 4.1.4 字符串和数值 与Perl不同， Python确实能够区分数字和字符串。函数eval()和str()可以在这两者之间相互转化。如： >>> 2 + ’1.5’ Traceback (most recent call last): File \"\", line 1, in ? TypeError: unsupported operand type(s) for +: ’int’ and ’str’ >>> 2 + eval(’1.5’) 3.5 >>> str(2 + eval(’1.5’)) ’3.5’ "]
]
