<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Python速成指南</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="This is my first book on data science">
  <meta name="generator" content="bookdown 0.1 and GitBook 2.6.7">

  <meta property="og:title" content="Python速成指南" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is my first book on data science" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Python速成指南" />
  
  <meta name="twitter:description" content="This is my first book on data science" />
  


<meta name="date" content="2016-11-10">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="section-3.html">


<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Python速成指南</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> 版权声明</a></li>
<li class="chapter" data-level="2" data-path="section-2.html"><a href="section-2.html"><i class="fa fa-check"></i><b>2</b> 作者介绍</a></li>
<li class="chapter" data-level="3" data-path="section-3.html"><a href="section-3.html"><i class="fa fa-check"></i><b>3</b> 前言</a><ul>
<li class="chapter" data-level="3.1" data-path="section-3.html"><a href="section-3.html#python"><i class="fa fa-check"></i><b>3.1</b> 为什么用Python?</a></li>
<li class="chapter" data-level="3.2" data-path="section-3.html"><a href="section-3.html#section-3.2"><i class="fa fa-check"></i><b>3.2</b> 如何使用该教程</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="section-4.html"><a href="section-4.html"><i class="fa fa-check"></i><b>4</b> 第一章</a><ul>
<li class="chapter" data-level="4.1" data-path="section-4.html"><a href="section-4.html#section-4.1"><i class="fa fa-check"></i><b>4.1</b> 介绍</a><ul>
<li class="chapter" data-level="4.1.1" data-path="section-4.html"><a href="section-4.html#section-4.1.1"><i class="fa fa-check"></i><b>4.1.1</b> 5分钟的入门案例</a></li>
<li class="chapter" data-level="4.1.2" data-path="section-4.html"><a href="section-4.html#-1"><i class="fa fa-check"></i><b>4.1.2</b> 1.2 10分钟的入门案例</a></li>
<li class="chapter" data-level="4.1.3" data-path="section-4.html"><a href="section-4.html#section-4.1.3"><i class="fa fa-check"></i><b>4.1.3</b> 变量/取值的类型</a></li>
<li class="chapter" data-level="4.1.4" data-path="section-4.html"><a href="section-4.html#section-4.1.4"><i class="fa fa-check"></i><b>4.1.4</b> 字符串和数值</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Python速成指南</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="section-4" class="section level1">
<h1><span class="header-section-number">第4章</span> 第一章</h1>
<div id="section-4.1" class="section level2">
<h2><span class="header-section-number">4.1</span> 介绍</h2>
<p>让我们立刻开始编程吧.</p>
<div id="section-4.1.1" class="section level3">
<h3><span class="header-section-number">4.1.1</span> 5分钟的入门案例</h3>
<div id="section-4.1.1.1" class="section level4">
<h4><span class="header-section-number">4.1.1.1</span> 案例代码</h4>
<p>下面是一个简单、快速的例子。假设我希望得到下面方程的值：</p>
<p><span class="math display">\[g(x)=\frac{x}{1-x^2}\]</span></p>
<p>对于所有<span class="math inline">\(x=0.0, 0.1, \dots, 0.9\)</span>。我能够通过下面的代码进行该计算：</p>
<pre>
for i in range(10):
    x = 0.1*i
    print x
print x/(1-x*x)
</pre>
<p>你可以将这段代码存入一个文件中，比如fme.py。然后通过在命令行提示符下键入下面代码执行[译者注：你要到文件所在的目录下键入该命令]：</p>
<p>python fme.py</p>
<p>执行结果大概如下：</p>
<pre>
0.0
0.0
0.1
0.10101010101
0.2
0.208333333333
0.3
0.32967032967
0.4
0.47619047619
0.5
0.666666666667
0.6
0.9375
0.7
1.37254901961
0.8
2.22222222222
0.9
4.73684210526
</pre>
</div>
<div id="pythonlists" class="section level4">
<h4><span class="header-section-number">4.1.1.2</span> Python列表（Lists）</h4>
<p>上面的代码是怎么工作的？首先，Python的 <code>range()</code>函数是一个使用列表的例子，即，Python阵列，虽然不是那么明显。【脚注1：这里我大致将其称为“阵列”，但如你们之后会见到的，这里的阵列定义比C/C++中的宽松许多。换句话说，获取真正的阵列速度快得多。在 C/C++中，阵列X中的第i个元素就是从第一个元素向后数i次，这样我们可以马上得到该元素。但对于Python却不可能，因此后者速度更慢。Python中的<code>NumPy</code>包提供了真正的阵列操作。】列表绝对是Python的基础，因此大家要对讲到列表的地方特别注意。不要仅仅关注其字面的意思，而是要将其当成Python中的“<strong>列表</strong>”。 Python中的<code>range()</code>函数返回一列连续的整数，在当前例子中是<code>[0,1,2,3,4,5,6,7,8,9]</code>。注意这是Python对列表的正式表达方式——方括号中通过逗号分隔的一系列对象（它们不一定只能是数字，也可以是各种其它对象）。</p>
</div>
<div id="loops" class="section level4">
<h4><span class="header-section-number">4.1.1.3</span> 循环（Loops）</h4>
<p>因此上面的语句和下面的等价：</p>
<pre>
for i in [0,1,2,3,4,5,6,7,8,9]:
</pre>
<p>不难猜测，这会导致10次迭代，i的取值从0开始，然后1……代码：</p>
<pre>
for i in [2,3,6]:
</pre>
<p>对应3次迭代，i取值为2,、3和6。</p>
<p>Python也有while语句（但没有until语句）。和C/C++一样，其也有break声明，用来提早结束循环。例如：</p>
<pre>
x = 5
while 1:
    x += 1
    if x == 8:
        print x
        break
</pre>
<p>类似的，continue声明也很有用，它告诉Python跳过当前循环中的剩下部分。例如，尝试执行下面代码：</p>
<pre>
sum = 0
for i in [5,12,13]:
    if i < 10: continue
    sum += i
print sum
</pre>
<p>结果是输出12+13的值，也就是25。 pass语句告诉Python什么也不要做。</p>
</div>
<div id="python" class="section level4">
<h4><span class="header-section-number">4.1.1.4</span> Python代码块定义</h4>
<p>现在让我们着眼于上面<code>for</code>语句末尾的那个貌似无辜的冒号“:”，该符号定义了一个Python代码块的开始。和C/C++甚至Perl语言不同，它们使用“{}”来定义代码块，Python使用冒号和每行的缩进组合来定义代码块。我将用冒号来和Python解释器对话:</p>
<blockquote>
<p>Hi，Python解释器，你最近好吗？我只想告诉你，这个冒号之后下一行将开始一个代码块。我已经将之后的几行向右缩进，用这种方式告诉你这些代码属于一个代码块。</p>
</blockquote>
<p>我选择使用3格缩进，但空格的数目并不重要，你只需要保证一个代码块中的每一行缩进的空格数目一致即可。例如下面代码（脚注2：这里g()是我之前定义的一个函数，这里并没有展示）：</p>
<pre>
for i in range(10):
    print 0.1*i
       print g(0.1*i)
</pre>
Python解释器将报错，告诉我出现语法错误（脚注3：记住这个报错信息。Python新手常常遇到这个报错）。在一个代码块中，只有在其中有子代码块的时候，Python才允许你进一步向右缩进。如：
<pre>
for i in range(10):
    if i%2 == 1:
        print 0.1*i
        print g(0.1*i)
</pre>
<p>这里我只打印出i是奇数的情况；“%”符号表示“mod”操作，即余数，这和C/C++中类似。再一次注意句子末尾的“:”。两个<code>print</code>语句所在行和之前的<code>if</code>行相比进一步向右缩进了。</p>
<p>还有一件事需要再次强调，和C/C++/Perl不同，Python语句中没有用到分号“;”。新的一行意味着新的声明。如果你的命令行很长，可以使用“/”符号告诉Python下一行是上一行语句的继续，如：</p>
<pre>
x = y + \
       z
</pre>
<p>大部分的C操作符在Python中也能使用，包括关系运算符，如“==”。<strong>0x</strong>代表十六进制，以及FORTRAN中的“**”代表乘方。</p>
同样，“if”语句能够和“else”语句配对，你可以将“else if”简写成“elif”。
<pre>
>> def f(x):
... if x > 0: return 1
... else: return 0
...
>>> f(2)
1
>>> f(-1)
0
</pre>
<p>布尔操作是and、or和not。除了总是使用的True和False以外，也可以用非零和零分别表示真和假。取值为“None”被当做“False”。</p>
<p>之后你会看到更多的例子。</p>
<p>顺便说下，注意类似这样的Python语句：<strong>print a or b or c</strong>。在这个语句中，如果第一项a是真（非零），那么将会输出a的值而忽略剩下的b和c，这是Python的惯用法则。</p>
</div>
<div id="python" class="section level4">
<h4><span class="header-section-number">4.1.1.5</span> Python也提供交互模式</h4>
<p>Python的一个非常棒的功能是交互模式。通常情况下不会用到这些，但如果你想很快尝试一些新功能的话，可以使用它的交互模型观察这些功能如何工作。任何时候，只要你不确定某方法是不是行得通，记住这句箴言：“在你存疑时动手试试看！”，交互模式为此提供了极大的便利。在这个教程中我们也会经常用交互模式来快速展示Python的某项功能。和我们之前展示的批量执行代码不同，我们可以键入代码并且在交互模式下运行：</p>
<pre>
% python
>>> for i in range(10):
... x = 0.1*i
... print x
... print x/(1-x*x)
...
0.0
0.0
0.1
0.10101010101
0.2
0.208333333333
0.3
0.32967032967
0.4
0.47619047619
0.5
0.666666666667
0.6
0.9375
0.7
1.37254901961
0.8
2.22222222222
0.9
4.73684210526
>>>
</pre>
<p>先打开Python，然后你会看到“&gt;&gt;&gt;”这个交互式提示符。然后在该提示符后逐行键入命令。每个代码块的行中都有一个特殊的提示符“…”。当我在代码末尾键入空白行时，Python解释器就知道你的代码已经结束了，然后就会执行这些代码。【脚注4：这里交互模式让我们只执行单个Python声明或者表达。在当前例子中，我们执行单个“for”声明。交互模型的意图不是让我们键入所有的代码。从技术的角度，我们可以用“if 1:”开始代码块，是的整个程序变成一个巨大的if声明。当然，在Python中这样键入比较长的程序总归是不方便的。】</p>
<p>当我们在交互模式下的时候，你可以通过箭头键调出之前的历史代码，这样可以节省一些键入的时间。</p>
<p>要退出Python交互模式，只需要键入ctrl-d【译者注：这对linux有效，不适用于windows】。</p>
<p><strong>自动输出</strong> ：通过交互模式，如果你引用或者创建某个对象，甚至是一个表达，只要你没有将其指定给一个变量，控制器就会自动输出该对象结果（不需要特别的打印语句）。例如：</p>
<pre>
>>> for i in range(4):
...       3*i
...
0
3
6
9
</pre>
<p>再次申明，这种情况适用于对部分对象，但是不包括一些表达，例如：</p>
<pre>
>>> open(’x’)
<open file ’x’, mode ’r’ at 0xb7eaf3c8>
</pre>
<p>这里代码表示打开x文件，从而产生一个文件对象。由于我们并没有将打开的文件制定给一个新的对象，比如f，以便之后使用该对象。也就是说我们没有键入这样的代码：</p>
<pre>
f = open(’x’)
</pre>
<p>Python会输出相关信息。但在这里，即使我们将其指定给一个对象，Python也会输出相关信息：</p>
<pre>
>>> f = open(’x’)
>>> f
<open file ’x’, mode ’r’ at 0xb7f2a3c8>
</pre>
</div>
<div id="python" class="section level4">
<h4><span class="header-section-number">4.1.1.6</span> Python的计算功能</h4>
<p>你可能会将Python当做一个快速计算器使用（我常常这样）。例如，我想知道价格$88.88提高5 5% 后会是多少：</p>
<pre>
% python
>>> 1.05*88.88
93.323999999999998
</pre>
<p>我们还可以很快的转化10进制和16进制的数：</p>
<pre>
>>> 0x12
18
>>> hex(18)
’0x12’
</pre>
<p>如果需要使用数学函数，得导入Python的数学包。这和使用C/C++类似，其中我们通过#include起始的行调入需要的包，而且在使用时需要指出相关的包名。</p>
<p>我们需要在某个程序包的语境下使用相关函数，这里我们需要用到math包。比如使用函数<code>sqrt()</code>和<code>sin()</code> 的时候需要在前面用包名math作为前缀【脚注：省去前缀的方法之后会介绍】：</p>
<pre>
>>> import math
>>> math.sqrt(88)
9.3808315196468595
>>> math.sin(2.5)
0.59847214410395655
</pre>
</div>
</div>
<div id="-1" class="section level3">
<h3><span class="header-section-number">4.1.2</span> 1.2 10分钟的入门案例</h3>
<div id="-1" class="section level4">
<h4><span class="header-section-number">4.1.2.1</span> 案例代码</h4>
<p>下面的代码将读入一个文本文件，文件的名字在命令行中。然后打印出文件中的行数和字数：</p>
<pre>
# reads in the text file whose name is specified on the command line,
# and reports the number of lines and words

import sys

def checkline():
    global l
    global wordcount
    w = l.split()
    wordcount += len(w)
    
wordcount = 0
f = open(sys.argv[1])
flines = f.readlines()
linecount = len(flines)
for l in flines:
    checkline()
print linecount, wordcount
</pre>
<p>假设我们将上面的代码存在一个名为<code>tme.py</code>的文件中。此外还有一个文本文件x，其内容如下：</p>
<pre>

This is an
example of a
text file.

</pre>
<p>这里有5行，其中2行是空行。如果我们执行下面的代码可以得到结果：</p>
<pre>
python tme.py x
5 8
</pre>
<p>表面上看，这里代码看上去像是C/C++程序：先是一个<strong>import</strong>声明，和<strong>#include</strong>声明类似（注意编译时对应的链接）；接下来是对一个函数的定义；再往后是主程序。这是阅读这段代码的很好的方式，但是记住，Python解释器会按顺序执行所有东西，从头开始。例如在执行<strong>import</strong>声明的时，可能顺带执行了一些代码，如果导入的模块（module）中含有一些除了函数以外的独立代码。我们在之后会进一步介绍这个。执行<strong>def</strong>声明不会导致执行实质性的程序，但是会执行定义函数这一操作。 下面是一些该代码中出现的之前没有讲到的特征：</p>
<ul>
<li>使用命令行参数（command-line arguments）</li>
<li>文件操作机制（manipulation mechanisms）</li>
<li>更多关于列表（lists）的操作</li>
<li>定义函数</li>
<li>导入程序包</li>
<li>变量作用域</li>
</ul>
<p>我会在接下来的几个小节中讨论这些特征。</p>
</div>
<div id="section-4.1.2.2" class="section level4">
<h4><span class="header-section-number">4.1.2.2</span> 命令行参数</h4>
<p>首先让我们解释下<strong>sys.argv</strong>。Python中有一个名为<strong>sys</strong>的模块（或者包），其中含有一个叫做<strong>argv</strong>的变量，它是一个Python列表，可以和C/C++中的<strong>argv</strong>进行类比【脚注6：不需要为<strong>argc</strong>寻找类比。作为一门面向对象的语言，Python将列表（lists）视为对象（objects）。列表的长度包含在该对象内。因此如果我们要知道<strong>argv</strong>中的元素个数，可以使用<strong>len(argv)</strong>。】该列表中的第0个元素是脚本名字，这里是<strong>tme.py</strong>，依次类推，就和C/C++中一样。在当前例子中，我们在x文件上运行代码，<strong>sys.argv[1]</strong>就是字符’x’（在Python中，字符串通常用单引号引起来）。由于Python不会自动导入<strong>sys</strong>模块，所以需要用<strong>import</strong>命令导入。 对于C/C++和Python，这些命令行本身当然也是字符串。如果你想用这些字符串表示数字，可以通过<strong>atoi()</strong>对它们进行转化。在Python中，我们可以使用<strong>int()</strong>。如果想转化为浮点型，在Python中可以使用<strong>float()</strong>【脚注7：在C/C++中，如果可以的话，我们能使用<strong>atof()</strong>或者<strong>sscanf()</strong>进行转化】。</p>
</div>
<div id="section-4.1.2.3" class="section level4">
<h4><span class="header-section-number">4.1.2.3</span> 文件操作简介(</h4>
<p><strong>open()</strong>函数和C/C++中的类似。代码行：</p>
<pre>
f = open(sys.argv[1])
</pre>
<p>创建了一个<strong>file</strong>类别的对象，并且将其指定给f。</p>
<p>将<strong>readlines()</strong>函数作用于<strong>file</strong>类别对象会返回一个列表（记得，“列表”是正式的Python术语），其中含有该文件中的每一行。每一行都是一个字符串，该字符串是列表的一个对象。由于这里的文件的内容有5行，<strong>readlines()</strong>返回的结果是一个含有5个元素的列表：</p>
<pre>
['','This is an','example of a','text file','']
</pre>
</div>
<div id="section-4.1.2.4" class="section level4">
<h4><span class="header-section-number">4.1.2.4</span> 缺乏声明</h4>
<p>Python中的变量无须特别声明。当赋值操作执行时就自动创建了一个变量。例如，在上面的<strong>tme.py</strong>代码中，执行下面声明后就创建了变量<strong>flines</strong>：</p>
<pre>
flines = f.readlines()
</pre>
<p>顺便说一下，还没有赋值的变量，比如上面的<strong>wordcount</strong>，其值默认为<strong>None</strong>。</p>
</div>
<div id="section-4.1.2.5" class="section level4">
<h4><span class="header-section-number">4.1.2.5</span> 局部变量和全局变量</h4>
<p>Python并没有C/C++那样严格意义上的全局变量。，全局变量在所有作用域都可访问。我们将在之后的1.14.6【add section reference】小节中进一步讨论。当前让我们假设源文件只含有一个.py文件；这种情况下，Python确实有类似C/C++的全局变量（虽然依旧有很大的不同）。</p>
<p>Python试着通过变量在代码中的位置来判断其作用范围。如果函数包含任何赋值语句，那么该变量默认是局部的，除非我们刻意使用关键词<strong>global</strong>。因此，在<strong>checkline()</strong>代码中，Python会假设<strong>l</strong>和<strong>wordcount</strong>对于<strong>checkline()</strong>来说都是局部的，如果我们没有特别指出其是全局变量的话。</p>
<p>使用全局变量简化了代码，个人认为对全局变量矫揉造作的批评是没有根据的（见http://heather.cs.ucdavis.edu/˜matloff/globals.html）。事实上，在重要的多线程（<strong>threads</strong>）编程中，是强制使用全局变量的。</p>
<p>但是你可能希望至少将所有的全局变量集结成一个组，如我在这里所做的。见附录1.24。</p>
</div>
<div id="section-4.1.2.6" class="section level4">
<h4><span class="header-section-number">4.1.2.6</span> 若干内置函数</h4>
<p>函数<strong>len()</strong>返回的是一个列表中元素的个数。在上述<strong>tme.py</strong>的例子中，我们通过其来找到文件中的内容行，因为<strong>readlines()</strong>会返回一个列表，其中每个元素对应文件中的每行内容。</p>
<p><strong>split()</strong>方法是<strong>string</strong>类【脚注8：类别函数被称为方法（methods）】。该方法会将一个字符串分成一列单词的列表【脚注9：默认设置是使用空格作为分割符，但也可以使用其它符号和字符串分割。】。因此，如在<strong>checkline()</strong>中，当<strong>l</strong>是’ This is an’时，列表w就是[’This’,’is’,’an’]。（在这里第一行是空行，相应的<strong>w</strong>就是一个空列表[]。）</p>
</div>
</div>
<div id="section-4.1.3" class="section level3">
<h3><span class="header-section-number">4.1.3</span> 变量/取值的类型</h3>
<p>在典型的脚本语言中，C/C++意义上的<strong>int</strong>或者<strong>float</strong>类型变量在Python中并没有声明。 但是，Python解释器具有追踪所有对象的内在功能。因此Python变量没有类型，但是它们的取值有类别。换句话说，变量<strong>X</strong>可能在某个地方被当成整数使用，在另外一个地方又被当成类别使用。</p>
<p>Python的类别含有下面概念：标量，序列（列表或者元组）和字典（关联数组，将在第1.6小节讨论），类别，函数等等。</p>
</div>
<div id="section-4.1.4" class="section level3">
<h3><span class="header-section-number">4.1.4</span> 字符串和数值</h3>
<p>与Perl不同， Python确实能够区分数字和字符串。函数<strong>eval()</strong>和<strong>str()</strong>可以在这两者之间相互转化。如：</p>
<pre>
>>> 2 + ’1.5’
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: unsupported operand type(s) for +: ’int’ and ’str’
>>> 2 + eval(’1.5’)
3.5
>>> str(2 + eval(’1.5’))
’3.5’
</pre>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="section-3.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page"><i class="fa fa-angle-left"></i></a>


<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/index.Rmd",
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
