<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>The Science and Art of Data</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="This is the handouts for CE course at JSM 2017">
  <meta name="generator" content="bookdown 0.1 and GitBook 2.6.7">

  <meta property="og:title" content="The Science and Art of Data" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is the handouts for CE course at JSM 2017" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="The Science and Art of Data" />
  
  <meta name="twitter:description" content="This is the handouts for CE course at JSM 2017" />
  

<meta name="author" content="Hui Lin and Ming Li">

<meta name="date" content="2017-04-30">

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="introduction-to-the-data.html">
<link rel="next" href="data-pre-processing.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="http://scientistcafe.com">Homepage</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> </a></li>
<li class="chapter" data-level="2" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html"><i class="fa fa-check"></i><b>2</b> The art of data science</a><ul>
<li class="chapter" data-level="2.1" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#what-is-data-science"><i class="fa fa-check"></i><b>2.1</b> What is data science?</a></li>
<li class="chapter" data-level="2.2" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#is-it-science-totally"><i class="fa fa-check"></i><b>2.2</b> Is it science? Totally?</a></li>
<li class="chapter" data-level="2.3" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#what-kind-of-questions-can-data-science-solve"><i class="fa fa-check"></i><b>2.3</b> What kind of questions can data science solve?</a><ul>
<li class="chapter" data-level="2.3.1" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#what-is-a-good-question"><i class="fa fa-check"></i><b>2.3.1</b> What is a good question?</a></li>
<li class="chapter" data-level="2.3.2" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#types-of-questions"><i class="fa fa-check"></i><b>2.3.2</b> Types of questions</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#what-are-the-required-skills-for-data-scientist"><i class="fa fa-check"></i><b>2.4</b> What are the required skills for data scientist?</a><ul>
<li class="chapter" data-level="2.4.1" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#types-of-learning"><i class="fa fa-check"></i><b>2.4.1</b> Types of Learning</a></li>
<li class="chapter" data-level="2.4.2" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#types-of-algorithm"><i class="fa fa-check"></i><b>2.4.2</b> Types of Algorithm</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#general-process-of-data-science"><i class="fa fa-check"></i><b>2.5</b> General Process of Data Science</a></li>
<li class="chapter" data-level="2.6" data-path="the-art-of-data-science.html"><a href="the-art-of-data-science.html#cloud-based-computation-environment"><i class="fa fa-check"></i><b>2.6</b> Cloud-based computation environment</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="big-data-cloud-platform.html"><a href="big-data-cloud-platform.html"><i class="fa fa-check"></i><b>3</b> Big Data Cloud Platform</a><ul>
<li class="chapter" data-level="3.1" data-path="big-data-cloud-platform.html"><a href="big-data-cloud-platform.html#introduction-of-databricks-cloud-based-distributed-system"><i class="fa fa-check"></i><b>3.1</b> Introduction of Databricks cloud-based distributed system</a></li>
<li class="chapter" data-level="3.2" data-path="big-data-cloud-platform.html"><a href="big-data-cloud-platform.html#linux-system-and-hadoop-environment"><i class="fa fa-check"></i><b>3.2</b> Linux system and Hadoop environment</a></li>
<li class="chapter" data-level="3.3" data-path="big-data-cloud-platform.html"><a href="big-data-cloud-platform.html#database-basic-through-hive"><i class="fa fa-check"></i><b>3.3</b> Database basic through Hive</a></li>
<li class="chapter" data-level="3.4" data-path="big-data-cloud-platform.html"><a href="big-data-cloud-platform.html#spark-and-h2o"><i class="fa fa-check"></i><b>3.4</b> Spark and H2O</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="introduction-to-the-data.html"><a href="introduction-to-the-data.html"><i class="fa fa-check"></i><b>4</b> Introduction to the data</a><ul>
<li class="chapter" data-level="4.1" data-path="introduction-to-the-data.html"><a href="introduction-to-the-data.html#customer-data-for-clothing-company"><i class="fa fa-check"></i><b>4.1</b> Customer data for clothing company</a></li>
<li class="chapter" data-level="4.2" data-path="introduction-to-the-data.html"><a href="introduction-to-the-data.html#customer-satisfaction-survey-data-from-airline-company"><i class="fa fa-check"></i><b>4.2</b> Customer Satisfaction Survey Data from Airline Company</a></li>
<li class="chapter" data-level="4.3" data-path="introduction-to-the-data.html"><a href="introduction-to-the-data.html#swine-disease-breakout-data"><i class="fa fa-check"></i><b>4.3</b> Swine Disease Breakout Data</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="data-wrangling.html"><a href="data-wrangling.html"><i class="fa fa-check"></i><b>5</b> Data Wrangling</a><ul>
<li class="chapter" data-level="5.1" data-path="data-wrangling.html"><a href="data-wrangling.html#read-and-write-data"><i class="fa fa-check"></i><b>5.1</b> Read and write data</a><ul>
<li class="chapter" data-level="5.1.1" data-path="data-wrangling.html"><a href="data-wrangling.html#readr"><i class="fa fa-check"></i><b>5.1.1</b> <code>readr</code></a></li>
<li class="chapter" data-level="5.1.2" data-path="data-wrangling.html"><a href="data-wrangling.html#data.table-enhanced-data.frame"><i class="fa fa-check"></i><b>5.1.2</b> <code>data.table</code>— enhanced <code>data.frame</code></a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="data-wrangling.html"><a href="data-wrangling.html#summarize-data"><i class="fa fa-check"></i><b>5.2</b> Summarize data</a><ul>
<li class="chapter" data-level="5.2.1" data-path="data-wrangling.html"><a href="data-wrangling.html#apply-lapply-and-sapply-in-base-r"><i class="fa fa-check"></i><b>5.2.1</b> <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code> in base R</a></li>
<li class="chapter" data-level="5.2.2" data-path="data-wrangling.html"><a href="data-wrangling.html#ddply-in-plyr-package"><i class="fa fa-check"></i><b>5.2.2</b> <code>ddply()</code> in <code>plyr</code> package</a></li>
<li class="chapter" data-level="5.2.3" data-path="data-wrangling.html"><a href="data-wrangling.html#dplyr-package"><i class="fa fa-check"></i><b>5.2.3</b> <code>dplyr</code> package</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="data-wrangling.html"><a href="data-wrangling.html#tidy-and-reshape-data"><i class="fa fa-check"></i><b>5.3</b> Tidy and Reshape Data</a><ul>
<li class="chapter" data-level="5.3.1" data-path="data-wrangling.html"><a href="data-wrangling.html#reshape2-package"><i class="fa fa-check"></i><b>5.3.1</b> <code>reshape2</code> package</a></li>
<li class="chapter" data-level="5.3.2" data-path="data-wrangling.html"><a href="data-wrangling.html#tidyr-package"><i class="fa fa-check"></i><b>5.3.2</b> <code>tidyr</code> package</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="data-pre-processing.html"><a href="data-pre-processing.html"><i class="fa fa-check"></i><b>6</b> Data Pre-processing</a><ul>
<li class="chapter" data-level="6.1" data-path="data-pre-processing.html"><a href="data-pre-processing.html#start"><i class="fa fa-check"></i><b>6.1</b> Start</a></li>
<li class="chapter" data-level="6.2" data-path="data-pre-processing.html"><a href="data-pre-processing.html#centering-and-scaling"><i class="fa fa-check"></i><b>6.2</b> <strong>Centering and Scaling</strong></a></li>
<li class="chapter" data-level="6.3" data-path="data-pre-processing.html"><a href="data-pre-processing.html#resolve-skewness"><i class="fa fa-check"></i><b>6.3</b> <strong>Resolve Skewness</strong></a></li>
<li class="chapter" data-level="6.4" data-path="data-pre-processing.html"><a href="data-pre-processing.html#resolve-outliers"><i class="fa fa-check"></i><b>6.4</b> <strong>Resolve Outliers</strong></a></li>
<li class="chapter" data-level="6.5" data-path="data-pre-processing.html"><a href="data-pre-processing.html#missing-values"><i class="fa fa-check"></i><b>6.5</b> <strong>Missing Values</strong></a><ul>
<li class="chapter" data-level="6.5.1" data-path="data-pre-processing.html"><a href="data-pre-processing.html#impute-missing-values-with-medianmode"><i class="fa fa-check"></i><b>6.5.1</b> Impute missing values with median/mode</a></li>
<li class="chapter" data-level="6.5.2" data-path="data-pre-processing.html"><a href="data-pre-processing.html#impute-missing-values-based-on-k-nearest-neighbors"><i class="fa fa-check"></i><b>6.5.2</b> Impute missing values based on K-nearest neighbors</a></li>
</ul></li>
<li class="chapter" data-level="6.6" data-path="data-pre-processing.html"><a href="data-pre-processing.html#collinearity"><i class="fa fa-check"></i><b>6.6</b> <strong>Collinearity</strong></a></li>
<li class="chapter" data-level="6.7" data-path="data-pre-processing.html"><a href="data-pre-processing.html#sparse-variables"><i class="fa fa-check"></i><b>6.7</b> <strong>Sparse Variables</strong></a></li>
<li class="chapter" data-level="6.8" data-path="data-pre-processing.html"><a href="data-pre-processing.html#re-encode-dummy-variables"><i class="fa fa-check"></i><b>6.8</b> <strong>Re-encode Dummy Variables</strong></a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html"><i class="fa fa-check"></i><b>7</b> Basic Model Techniques</a><ul>
<li class="chapter" data-level="7.1" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#supervised-v.s.-unsupervised-model"><i class="fa fa-check"></i><b>7.1</b> Supervised v.s. unsupervised model</a></li>
<li class="chapter" data-level="7.2" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#model-error"><i class="fa fa-check"></i><b>7.2</b> Model Error</a><ul>
<li class="chapter" data-level="7.2.1" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#systematic-error-and-random-error"><i class="fa fa-check"></i><b>7.2.1</b> Systematic Error and Random Error</a></li>
<li class="chapter" data-level="7.2.2" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#error-in-response"><i class="fa fa-check"></i><b>7.2.2</b> Error in Response</a></li>
<li class="chapter" data-level="7.2.3" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#error-in-independent-variable"><i class="fa fa-check"></i><b>7.2.3</b> Error in Independent Variable</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#data-dividing-and-resampling"><i class="fa fa-check"></i><b>7.3</b> Data Dividing and Resampling</a><ul>
<li class="chapter" data-level="7.3.1" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#training-and-testing-set"><i class="fa fa-check"></i><b>7.3.1</b> Training and Testing Set</a></li>
<li class="chapter" data-level="7.3.2" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#resampling"><i class="fa fa-check"></i><b>7.3.2</b> Resampling</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="basic-model-techniques.html"><a href="basic-model-techniques.html#summary"><i class="fa fa-check"></i><b>7.4</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="shiny-intro.html"><a href="shiny-intro.html"><i class="fa fa-check"></i><b>8</b> R-Shiny Introduction</a><ul>
<li class="chapter" data-level="8.1" data-path="shiny-intro.html"><a href="shiny-intro.html#softwares"><i class="fa fa-check"></i><b>8.1</b> Softwares</a></li>
<li class="chapter" data-level="8.2" data-path="shiny-intro.html"><a href="shiny-intro.html#web-development"><i class="fa fa-check"></i><b>8.2</b> Web development</a></li>
<li class="chapter" data-level="8.3" data-path="shiny-intro.html"><a href="shiny-intro.html#shiny"><i class="fa fa-check"></i><b>8.3</b> Shiny</a></li>
<li class="chapter" data-level="8.4" data-path="shiny-intro.html"><a href="shiny-intro.html#resources"><i class="fa fa-check"></i><b>8.4</b> Resources</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="dynamicreproducible-report.html"><a href="dynamicreproducible-report.html"><i class="fa fa-check"></i><b>9</b> Dynamic/Reproducible report</a></li>
<li class="chapter" data-level="10" data-path="soft-skills-for-data-scientists.html"><a href="soft-skills-for-data-scientists.html"><i class="fa fa-check"></i><b>10</b> Soft Skills for Data Scientists</a><ul>
<li class="chapter" data-level="10.1" data-path="soft-skills-for-data-scientists.html"><a href="soft-skills-for-data-scientists.html#introduction-to-agile"><i class="fa fa-check"></i><b>10.1</b> Introduction to agile</a></li>
<li class="chapter" data-level="10.2" data-path="soft-skills-for-data-scientists.html"><a href="soft-skills-for-data-scientists.html#effective-communication-with-business-partners"><i class="fa fa-check"></i><b>10.2</b> Effective communication with business partners</a></li>
<li class="chapter" data-level="10.3" data-path="soft-skills-for-data-scientists.html"><a href="soft-skills-for-data-scientists.html#leadership-skills"><i class="fa fa-check"></i><b>10.3</b> Leadership skills</a></li>
<li class="chapter" data-level="10.4" data-path="soft-skills-for-data-scientists.html"><a href="soft-skills-for-data-scientists.html#decision-making-with-uncertainty"><i class="fa fa-check"></i><b>10.4</b> Decision making with uncertainty</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="case-study.html"><a href="case-study.html"><i class="fa fa-check"></i><b>11</b> Case Study</a><ul>
<li class="chapter" data-level="11.1" data-path="case-study.html"><a href="case-study.html#case-1-customer-perception-study-for-airline-company"><i class="fa fa-check"></i><b>11.1</b> Case 1: Customer Perception Study for Airline Company</a></li>
<li class="chapter" data-level="11.2" data-path="case-study.html"><a href="case-study.html#case-2-swine-disease-prediction"><i class="fa fa-check"></i><b>11.2</b> Case 2: Swine Disease Prediction</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>12</b> References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">The Science and Art of Data</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="data-wrangling" class="section level1">
<h1><span class="header-section-number">Chapter 5</span> Data Wrangling</h1>
<p>This chapter focuses on some of the most frequently used data manipulations and shows how to implement them in R. It is important to explore the data set with descriptive statistics (mean, standard deviation, etc.) and data visualization prior to analysis. Transform data so that the data structure is in line with the requirements of the model. You also need to summarize the results after analysis.</p>
<p>Here we assume the readers are already familiar with some of the traditional R data operations, such as subsetting data frame, deleting variables, read and write functions (<code>read.csv ()</code>, <code>write.csv ()</code>, etc.) in base R. We will also skip some basic descriptive functions in R. For example, for discrete variables, we often use the frequency table to look at the frequency (<code>table ()</code>) of the variable at various levels as needed, or a crosstab of two variables. You can also draw a bar chart for discrete variables (<code>bar()</code>). For continuous variables, we need to look at the mean (<code>mean ()</code>), standard deviation (<code>sd()</code>), quantile (<code>quantile()</code>) of a variable from time to time. There are also functions like <code>summary()</code>, <code>str()</code> and <code>describe()</code> (a functions in the ‘psych’ package) that give a summary of a data frame.</p>
<!--
These are some of the most basic methods of exploring data at all stages (including model results). But only these are not enough, the flexibility of these methods is not high, the output of the information is fixed. We may not want the `summary ()` function to output all of the information, and some of the information we want is not. For example, if we want to know the mean of customer revenue, online spend, and so on for each category, or if we want to find the highest-earning people in each category, then extract them together, or we want a The new variable indicates whether the channel was purchased (online or in-store) and used this for modeling, where the data needs to be reshaped, the records for online purchases and the records for physical store purchases are row by row rather than now Of the column. These operations can be cumbersome and inefficient when used only with primitive functions. There are some other packages in R that can be very efficient and succinct to accomplish these seemingly complex tasks. The first contact with these functions of the small partners will feel that they are not very studious, it is natural, more flexible tools need to learn to master the natural longer, but this is a ** practice makes perfect process.
-->
<p>The focus here is to introduce some of the more efficient data wrangling methods in R.</p>
<div id="read-and-write-data" class="section level2">
<h2><span class="header-section-number">5.1</span> Read and write data</h2>
<div id="readr" class="section level3">
<h3><span class="header-section-number">5.1.1</span> <code>readr</code></h3>
<p>You must be familar with <code>read.csv()</code>, <code>read.table()</code> and <code>write.csv()</code> in base R. Here we will introduce a more efficient package from RStudio in 2015 for reading and writing data: <code>readr</code> package. The corresponding functions are <code>read_csv()</code>, <code>read_table()</code> and <code>write_csv()</code>. The commands look quite similar, but <code>readr</code> is different in the following respects:</p>
<ol style="list-style-type: decimal">
<li><p>It is 10x faster. The trick is that <code>readr</code> uses C++ to process the data quickly.</p></li>
<li><p>It doesn’t change the column names. The names can start with number and “<code>.</code>” will not be substitued to “<code>_</code>”. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(readr)
<span class="kw">read_csv</span>(<span class="st">&quot;2015,2016,2017</span>
<span class="st">1,2,3</span>
<span class="st">4,5,6&quot;</span>)</code></pre></div></li>
<li><p><code>readr</code> functions do not convert strings to factors by default, are able to parse dates and times and can automatically determine the data types in each column.</p></li>
<li><p>The killing character in my opinion is that <code>readr</code> provides <strong>progress bar</strong>. What makes you feel worse than waiting is not knowing how long you have to wait. Without “progress bar” might be the No.1 reason that people break up with the one they have been dating.</p></li>
</ol>
<p>(add progress bar)</p>
<p>The major functions of readr is to turn flat files into data frames:</p>
<ul>
<li><code>read_csv()</code>: reads comma delimited files</li>
<li><code>read_csv2()</code>: reads semicolon separated files (common in countries where <code>,</code> is used as the decimal place)</li>
<li><code>read_tsv()</code>: reads tab delimited files</li>
<li><code>read_delim()</code>: reads in files with any delimiter</li>
<li><code>read_fwf()</code>: reads fixed width files. You can specify fields either by their widths with <code>fwf_widths()</code> or their position with <code>fwf_positions()</code><br />
</li>
<li><code>read_table()</code>: reads a common variation of fixed width files where columns are separated by white space</li>
<li><code>read_log()</code>: reads Apache style log files</li>
</ul>
<p>The good thing is that those functions have similar syntax. Once you learn one, the others become easy. Here we will focus on <code>read_csv()</code>.</p>
<p>The most important information for <code>read_csv()</code> is the path to your data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(readr)
sim.dat &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv &quot;</span>)
<span class="kw">head</span>(sim.dat)</code></pre></div>
<p>The function reads the file to R as a <code>tibble</code>. You can consider <code>tibble</code> as next iteration of data frame. They are different with data frame for the following aspects:</p>
<ul>
<li>It never changes an input’s type (i.e., no more <code>stringsAsFactors = FALSE</code>!)</li>
<li>It never adjusts the names of variables</li>
<li>It has a refined print method that shows only the first 10 rows, and all the columns that fit on screen. You can also control the default print behavior by setting options.</li>
</ul>
<p>Refer to <a href="http://r4ds.had.co.nz/tibbles.html" class="uri">http://r4ds.had.co.nz/tibbles.html</a> for more information about ‘tibble’.</p>
<p>When you run <code>read_csv()</code> it prints out a column specification that gives the name and type of each column. In order to better understanding how <code>readr</code> works, it is helpful to type in some baby data set and check the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;2015,2016,2017</span>
<span class="st">100,200,300</span>
<span class="st">canola,soybean,corn&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>You can also add comments on the top and tell R to skip those lines:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;# I will never let you know that</span>
<span class="st">          # my favorite food is carrot</span>
<span class="st">          Date,Food,Mood</span>
<span class="st">          Monday,carrot,happy</span>
<span class="st">          Tuesday,carrot,happy</span>
<span class="st">          Wednesday,carrot,happy</span>
<span class="st">          Thursday,carrot,happy</span>
<span class="st">          Friday,carrot,happy</span>
<span class="st">          Saturday,carrot,extremely happy</span>
<span class="st">          Sunday,carrot,extremely happy&quot;</span>, <span class="dt">skip =</span> <span class="dv">2</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>If you don’t have column names, set <code>col_names = FALSE</code> then R will assign names “<code>X1</code>”,“<code>X2</code>”… to the columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;Saturday,carrot,extremely happy</span>
<span class="st">          Sunday,carrot,extremely happy&quot;</span>, <span class="dt">col_names=</span><span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>You can also pass <code>col_names</code> a character vector which will be used as the column names. Try to replace <code>col_names=FALSE</code> with <code>col_names=c(&quot;Date&quot;,&quot;Food&quot;,&quot;Mood&quot;)</code> and see what happen.</p>
<p>As mentioned before, you can use <code>read_csv2()</code> to read semicolon separated files:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv2</span>(<span class="st">&quot;Saturday; carrot; extremely happy </span><span class="ch">\n</span><span class="st"> Sunday; carrot; extremely happy&quot;</span>, <span class="dt">col_names=</span><span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>Here “<code>\n</code>” is a convenient shortcut for adding a new line.</p>
<p>You can use <code>read_tsv()</code> to read tab delimited files：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_tsv</span>(<span class="st">&quot;every</span><span class="ch">\t</span><span class="st">man</span><span class="ch">\t</span><span class="st">is</span><span class="ch">\t</span><span class="st">a</span><span class="ch">\t</span><span class="st">poet</span><span class="ch">\t</span><span class="st">when</span><span class="ch">\t</span><span class="st">he</span><span class="ch">\t</span><span class="st">is</span><span class="ch">\t</span><span class="st">in</span><span class="ch">\t</span><span class="st">love</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>Or more generally, you can use <code>read_delim()</code> and assign separating character：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_delim</span>(<span class="st">&quot;THE|UNBEARABLE|RANDOMNESS|OF|LIFE</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">delim =</span> <span class="st">&quot;|&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>Another situation you will often run into is missing value. In marketing survey, people like to use “99” to represent missing. You can tell R to set all observation with value “99” as missing when you read the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat=<span class="kw">read_csv</span>(<span class="st">&quot;Q1,Q2,Q3</span>
<span class="st">               5, 4,99&quot;</span>,<span class="dt">na=</span><span class="st">&quot;99&quot;</span>)
<span class="kw">print</span>(dat)</code></pre></div>
<p>For writing data back to disk, you can use <code>write_csv()</code> and <code>write_tsv()</code>. The following two characters of the two functions increase the chances of the output file being read back in correctly:</p>
<ul>
<li>Encode strings in UTF-8</li>
<li>Save dates and date-times in ISO8601 format so they are easily parsed elsewhere</li>
</ul>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_csv</span>(sim.dat, <span class="st">&quot;sim_dat.csv&quot;</span>)</code></pre></div>
<p>For other data types, you can use the following packages:</p>
<ul>
<li><code>Haven</code>: SPSS, Stata and SAS data</li>
<li><code>Readxl</code> and <code>xlsx</code>: excel data(.xls and .xlsx)</li>
<li><code>DBI</code>: given data base, such as RMySQL, RSQLite and RPostgreSQL, read data directly from the database using SQL</li>
</ul>
<p>Some other useful materials:</p>
<ul>
<li>For getting data from internet, you can refere to the book “XML and Web Technologies for Data Sciences with R”.</li>
<li><a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html#Acknowledgements">R data import/export manual</a></li>
<li><code>rio</code> package：<a href="https://github.com/leeper/rio" class="uri">https://github.com/leeper/rio</a></li>
</ul>
</div>
<div id="data.table-enhanced-data.frame" class="section level3">
<h3><span class="header-section-number">5.1.2</span> <code>data.table</code>— enhanced <code>data.frame</code></h3>
<p>What is <code>data.table</code>? It is an R package that provides an enhanced version of <code>data.frame</code>. The most used object in R is <code>data frame</code>. Before we move on, let’s briefly review some basic characters and manipulations of data.frame:</p>
<ul>
<li>It is a set of rows and columns.</li>
<li>Each row is of the same length and data type</li>
<li>Every column is of the same length but can be of differing data types</li>
<li>It has characteristics of both a matrix and a list</li>
<li>It uses <code>[]</code> to subset data</li>
</ul>
<p>I will use the clothes customer data to illustrate. There are two dimensions in <code>[]</code>. The first one indicates row and second one indicates column. It uses comma to separate them.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># read data</span>
sim.dat&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)
<span class="co"># subset the first two rows</span>
sim.dat[<span class="dv">1</span>:<span class="dv">2</span>,]</code></pre></div>
<pre><code>##   age gender   income house store_exp online_exp store_trans online_trans
## 1  57 Female 120963.4   Yes  529.1344   303.5125           2            2
## 2  63 Female 122008.1   Yes  478.0058   109.5297           4            2
##   Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 segment
## 1  4  2  1  2  1  4  1  4  2   4   Price
## 2  4  1  1  2  1  4  1  4  1   4   Price</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># subset the first two rows and column 3 and 5</span>
sim.dat[<span class="dv">1</span>:<span class="dv">2</span>,<span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">5</span>)]</code></pre></div>
<pre><code>##     income store_exp
## 1 120963.4  529.1344
## 2 122008.1  478.0058</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get all rows with age&gt;70</span>
sim.dat[sim.dat$age&gt;<span class="dv">70</span>,]</code></pre></div>
<pre><code>##     age gender   income house store_exp online_exp store_trans
## 288 300   Male 208017.5   Yes  5076.801   6053.485          12
##     online_trans Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10     segment
## 288           11  1  4  5  4  4  4  4  1  4   2 Conspicuous</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get rows with age&gt; 60 and gender is Male</span>
<span class="co"># select column 3 and 4</span>
sim.dat[sim.dat$age&gt;<span class="dv">68</span> &amp;<span class="st"> </span>sim.dat$gender ==<span class="st"> &quot;Male&quot;</span>, <span class="dv">3</span>:<span class="dv">4</span>]</code></pre></div>
<pre><code>##       income house
## 204 119552.0    No
## 288 208017.5   Yes</code></pre>
<p>Remember that there are usually different ways to conduct the same manipulation. For example, the following code presents three ways to calculate average number of online transactions for male and female:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tapply</span>(sim.dat$online_trans, sim.dat$gender, mean )</code></pre></div>
<pre><code>##   Female     Male 
## 15.38448 11.26233</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">aggregate</span>(online_trans ~<span class="st"> </span>gender, <span class="dt">data =</span> sim.dat, mean)</code></pre></div>
<pre><code>##   gender online_trans
## 1 Female     15.38448
## 2   Male     11.26233</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
sim.dat%&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(gender)%&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">Avg_online_trans=</span><span class="kw">mean</span>(online_trans))</code></pre></div>
<p>There is no gold standard to choose a specific function to manipulate data. The goal is to solve real problem not the tool itself. So just use whatever tool that is convenient for you.</p>
<p>The way to use <code>[]</code> is straightforward. But the manipulations are limited. If you need more complicated data reshaping or aggregation, there are other packages to use such as <code>dplyr</code>, <code>reshape2</code>, <code>tidyr</code> etc. But the usage of those packages are not as straightforward as <code>[]</code>. You often need to change functions. Keeping related operations together, such as subset, group, update, join etc, will allow for:</p>
<ul>
<li>concise, consistent and readable syntax irrespective of the set of operations you would like to perform to achieve your end goal</li>
<li>performing data manipulation fluidly without the cognitive burden of having to change among different functions</li>
<li>by knowing precisely the data required for each operation, you can automatically optimize operations effectively</li>
</ul>
<p><code>data.table</code> is the package for that. If you are not familiar with other data manipulating packages and are interested in reducing programming time tremendously, then this package is for you.</p>
<p>Other than extending the function of <code>[]</code>, <code>data.table</code> has the following advantages:</p>
<p>Offers fast import, subset, grouping, update, and joins for large data files It is easy to turn data frame to data table Can behave just like a data frame</p>
<p>You need to install and load the package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># If you haven&#39;t install it, use the code to instal</span>
<span class="co"># install.packages(&quot;data.table&quot;)</span>
<span class="co"># load packagw</span>
<span class="kw">library</span>(data.table)</code></pre></div>
<p>Use <code>data.table()</code> to covert the existing data frame <code>sim.dat</code> to data table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt &lt;-<span class="st"> </span><span class="kw">data.table</span>(sim.dat)
<span class="kw">class</span>(dt)</code></pre></div>
<pre><code>## [1] &quot;data.table&quot; &quot;data.frame&quot;</code></pre>
<p>Calculate mean for counts of online transactions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[, <span class="kw">mean</span>(online_trans)]</code></pre></div>
<pre><code>## [1] 13.546</code></pre>
<p>You can’t do the same thing using data frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat[,<span class="kw">mean</span>(online_trans)]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">Error in mean(online_trans) : object &#39;online_trans&#39; not found</code></pre></div>
<p>If you want to calculate mean by a categories as before, set “<code>by =</code>” argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>gender]</code></pre></div>
<p>You can group by more than one variables. For example, group by “<code>gender</code>” and “<code>house</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<p>Assign column names for aggregated variables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<p><code>data.table</code> can accomplish all operations that <code>aggregate()</code> and <code>tapply()</code>can do for data frame.</p>
<ul>
<li>General setting of <code>data.table</code></li>
</ul>
<p>Different from data frame, there are three arguments for data table:</p>
<center>
<img src="http://scientistcafe.com/book/Figure/datable1.png" />
</center>
<p>It is analogous to SQL. You don’t have to know SQL to learn data table. But experience with SQL will help you understand data table. In SQL, you select column <code>j</code> (use command <code>SELECT</code>) for row <code>i</code> (using command <code>WHERE</code>). <code>GROUP BY</code> in SQL will assign the variable to group the observations.</p>
<center>
<img src="http://scientistcafe.com/book/Figure/rSQL.png" />
</center>
<p>Let’s review our previous code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , <span class="kw">mean</span>(online_trans), by =<span class="st"> </span>gender]</code></pre></div>
<p>The code above is equal to the following SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span>  gender, <span class="fu">avg</span>(online_trans) <span class="kw">FROM</span> sim.dat <span class="kw">GROUP</span> <span class="kw">BY</span> gender</code></pre></div>
<p>R code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ , .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<p>is equal to SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> gender, house, <span class="fu">avg</span>(online_trans) <span class="kw">AS</span> <span class="fu">avg</span> <span class="kw">FROM</span> sim.dat <span class="kw">GROUP</span> <span class="kw">BY</span> gender, house</code></pre></div>
<p>R code：</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[ age &lt;<span class="st"> </span><span class="dv">40</span>, .(<span class="dt">avg =</span> <span class="kw">mean</span>(online_trans)), by =<span class="st"> </span>.(gender, house)]</code></pre></div>
<p>is equal to SQL：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> gender, house, <span class="fu">avg</span>(online_trans) <span class="kw">AS</span> <span class="fu">avg</span> <span class="kw">FROM</span> sim.dat <span class="kw">WHERE</span> age &lt; <span class="dv">40</span> <span class="kw">GROUP</span> <span class="kw">BY</span> gender, house</code></pre></div>
<p>You can see the analogy between <code>data.table</code> and <code>SQL</code>. Now let’s focus on operations in data table.</p>
<ul>
<li>select row</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select rows with age&lt;20 and income &gt; 80000</span>
dt[age &lt;<span class="st"> </span><span class="dv">20</span> &amp;<span class="st"> </span>income &gt;<span class="st"> </span><span class="dv">80000</span>]
<span class="co"># select the first two rows</span>
dt[<span class="dv">1</span>:<span class="dv">2</span>]</code></pre></div>
<ul>
<li>select column</li>
</ul>
<p>Selecting columns in <code>data.table</code> don’t need <code>$</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select column “age” but return it as a vector</span>
<span class="co"># the argument for row is empty so the result will return all observations</span>
ans &lt;-<span class="st"> </span>dt[, age]
<span class="kw">head</span>(ans)</code></pre></div>
<pre><code>## [1] 57 63 59 60 51 59</code></pre>
<p>To return <code>data.table</code> object, put column names in <code>list()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Select age and online_exp columns and return as a data.table instead</span>
ans &lt;-<span class="st"> </span>dt[, <span class="kw">list</span>(age, online_exp)]
<span class="kw">head</span>(ans)</code></pre></div>
<p>Or you can also put column names in <code>.()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>dt[, .(age, online_exp)]
<span class="co"># head(ans)</span></code></pre></div>
<p>To select all columns from “<code>age</code>” to “<code>income</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>dt[, age:income, with =<span class="st"> </span><span class="ot">FALSE</span>]
<span class="kw">head</span>(ans,<span class="dv">2</span>)</code></pre></div>
<p>Delete columns using <code>-</code> or <code>!</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># delete columns from  age to online_exp</span>
ans &lt;-<span class="st"> </span>dt[, -(age:online_exp), with =<span class="st"> </span><span class="ot">FALSE</span>]
ans &lt;-<span class="st"> </span>dt[, !(age:online_exp), with =<span class="st"> </span><span class="ot">FALSE</span>]</code></pre></div>
<ul>
<li>tabulation</li>
</ul>
<p>In data table. <code>.N</code> means to count。</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># row count</span>
dt[, .N] </code></pre></div>
<pre><code>## [1] 1000</code></pre>
<p>If you assign the group variable, then it will count by groups:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># counts by gender</span>
dt[, .N, by=<span class="st"> </span>gender]  
<span class="co"># for those younger than 30, count by gender</span>
 dt[age &lt;<span class="st"> </span><span class="dv">30</span>, .(<span class="dt">count=</span>.N), by=<span class="st"> </span>gender] </code></pre></div>
<p>Order table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get records with the highest 5 online expense:</span>
<span class="kw">head</span>(dt[<span class="kw">order</span>(-online_exp)],<span class="dv">5</span>) </code></pre></div>
<p>Since data table keep some characters of data frame, they share some operations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[<span class="kw">order</span>(-online_exp)][<span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<p>You can also order the table by more than one variable. The following code will order the table by <code>gender</code>, then order within <code>gender</code> by <code>online_exp</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt[<span class="kw">order</span>(gender, -online_exp)][<span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<ul>
<li>Use <code>fread()</code> to import dat</li>
</ul>
<p>Other than <code>read.csv</code> in base R, we have introduced ‘read_csv’ in ‘readr’. <code>read_csv</code> is much faster and will provide progress bar which makes user feel much better (at least make me feel better). <code>fread()</code> in <code>data.table</code> further increase the efficiency of reading data. The following are three examples of reading the same data file <code>topic.csv</code>. The file includes text data scraped from an agriculture forum with 209670 rows and 6 columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;/Users/happyrabbit/Documents/GitHub/DataScientistR/Data/topic.csv&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">  user  system elapsed 
  4.313   0.027   4.340</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-readr::<span class="kw">read_csv</span>(<span class="st">&quot;/Users/happyrabbit/Documents/GitHub/DataScientistR/Data/topic.csv&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">   user  system elapsed 
  0.267   0.008   0.274 </code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(topic&lt;-data.table::<span class="kw">fread</span>(<span class="st">&quot;/Users/happyrabbit/Documents/GitHub/DataScientistR/Data/topic.csv&quot;</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">   user  system elapsed 
  0.217   0.005   0.221 </code></pre></div>
<p>It is clear that <code>read_csv()</code> is much faster than <code>read.csv()</code>. <code>fread()</code> is a little faster than <code>read_csv()</code>. As the size increasing, the difference will become for significant. Note that <code>fread()</code> will read file as <code>data.table</code> by default.</p>
</div>
</div>
<div id="summarize-data" class="section level2">
<h2><span class="header-section-number">5.2</span> Summarize data</h2>
<div id="apply-lapply-and-sapply-in-base-r" class="section level3">
<h3><span class="header-section-number">5.2.1</span> <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code> in base R</h3>
<p>There are some powerful functions to summarize data in base R, such as <code>apply()</code>, <code>lapply()</code> and <code>sapply()</code>. They do the same basic things and are all from “apply” family: apply functions over parts of data. They differ in two important respects:</p>
<ol style="list-style-type: decimal">
<li>the type of object they apply to</li>
<li>the type of result they will return</li>
</ol>
<p>When do we use <code>apply()</code>? When we want to apply a function to margins of an array or matrix. That means our data need to be structured. The operations can be very flexible. It returns a vector or array or list of values obtained by applying a function to margins of an array or matrix.</p>
<p>For example you can compute row and column sums for a matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## simulate a matrix
x &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dt">x1 =</span><span class="dv">1</span>:<span class="dv">8</span>, <span class="dt">x2 =</span> <span class="kw">c</span>(<span class="dv">4</span>:<span class="dv">1</span>, <span class="dv">2</span>:<span class="dv">5</span>))
<span class="kw">dimnames</span>(x)[[<span class="dv">1</span>]] &lt;-<span class="st"> </span>letters[<span class="dv">1</span>:<span class="dv">8</span>]
<span class="kw">apply</span>(x, <span class="dv">2</span>, mean)</code></pre></div>
<pre><code>##  x1  x2 
## 4.5 3.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">col.sums &lt;-<span class="st"> </span><span class="kw">apply</span>(x, <span class="dv">2</span>, sum)
row.sums &lt;-<span class="st"> </span><span class="kw">apply</span>(x, <span class="dv">1</span>, sum)</code></pre></div>
<p>You can also apply other functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ma &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">6</span>:<span class="dv">8</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)
ma</code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    3    1    7
## [2,]    2    4    6    8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(ma, <span class="dv">1</span>, table)  <span class="co">#--&gt; a list of length 2</span></code></pre></div>
<pre><code>## [[1]]
## 
## 1 3 7 
## 2 1 1 
## 
## [[2]]
## 
## 2 4 6 8 
## 1 1 1 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(ma, <span class="dv">1</span>, stats::quantile) <span class="co"># 5 x n matrix with rownames</span></code></pre></div>
<pre><code>##      [,1] [,2]
## 0%      1  2.0
## 25%     1  3.5
## 50%     2  5.0
## 75%     4  6.5
## 100%    7  8.0</code></pre>
<p>Results can have different lengths for each call. This is a trickier example. What will you get?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Example with different lengths for each call
z &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span>:<span class="dv">24</span>, <span class="dt">dim =</span> <span class="dv">2</span>:<span class="dv">4</span>)
zseq &lt;-<span class="st"> </span><span class="kw">apply</span>(z, <span class="dv">1</span>:<span class="dv">2</span>, function(x) <span class="kw">seq_len</span>(<span class="kw">max</span>(x)))
zseq         ## a 2 x 3 matrix
<span class="kw">typeof</span>(zseq) ## list
<span class="kw">dim</span>(zseq) ## 2 3
zseq[<span class="dv">1</span>,]
<span class="kw">apply</span>(z, <span class="dv">3</span>, function(x) <span class="kw">seq_len</span>(<span class="kw">max</span>(x)))</code></pre></div>
<p><code>lapply()</code> applies a function over a list, data.frame or vector and returns a list of the same length. <code>sapply()</code> is a user-friendly version and wrapper of <code>lapply()</code>. By default it returns a vector, matrix or if <code>simplify = &quot;array&quot;</code>, an array if appropriate. <code>apply(x, f, simplify = FALSE, USE.NAMES = FALSE)</code> is the same as <code>lapply(x, f)</code>. If <code>simplify=TRUE</code>, then it will return a <code>data.frame</code> instead of <code>list</code>.</p>
<p>Let’s use some data with context to help you better understand the functions.</p>
<ul>
<li>Get the mean and standard deviation of all numerical variables in the data set.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Read data</span>
sim.dat&lt;-<span class="kw">read.csv</span>(<span class="st">&quot;https://raw.githubusercontent.com/happyrabbit/DataScientistR/master/Data/SegData.csv&quot;</span>)
<span class="co"># Get numerical variables</span>
sdat&lt;-sim.dat[,!<span class="kw">lapply</span>(sim.dat,class)==<span class="st">&quot;factor&quot;</span>]
## Try the following code with apply() function
## apply(sim.dat,class)
## Why is there the error?</code></pre></div>
<p>The data frame <code>sdat</code> only includes numeric columns. Now we can go head and use <code>apply()</code> to get mean and standard deviation for each column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,function(x) <span class="kw">mean</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp  store_trans 
##       38.840   113543.065     1356.851     2120.181        5.350 
## online_trans           Q1           Q2           Q3           Q4 
##       13.546        3.101        1.823        1.992        2.763 
##           Q5           Q6           Q7           Q8           Q9 
##        2.945        2.448        3.434        2.396        3.085 
##          Q10 
##        2.320</code></pre>
<p>Here we defined a function using <code>function(x) mean(na.omit(x))</code>. It is a very simple function. It tells R to ignore the missing value when calculating the mean. <code>MARGIN=2</code> tells R to apply function to each column. It is not hard to guess what <code>MARGIN=1</code> mean. The result show that the average online expense is much higher than store expense. You can also compare the average scores across different questions. The command to calculate standard deviation is very similar. The only difference is to change <code>mean()</code> to <code>sd()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(sdat, <span class="dt">MARGIN=</span><span class="dv">2</span>,function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))</code></pre></div>
<pre><code>##          age       income    store_exp   online_exp  store_trans 
##    16.416818 49842.287197  2774.399785  1731.224308     3.695559 
## online_trans           Q1           Q2           Q3           Q4 
##     7.956959     1.450139     1.168348     1.402106     1.155061 
##           Q5           Q6           Q7           Q8           Q9 
##     1.284377     1.438529     1.455941     1.154347     1.118493 
##          Q10 
##     1.136174</code></pre>
<p>Even the average online expense is higher than store expense, the standard deviation for store expense is much higher than online expense which indicates there are very likely some big/small purchase in store. We can check it quickly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(sdat$store_exp)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  -500.0   205.0   329.0  1357.0   597.3 50000.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(sdat$online_exp)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   68.82  420.30 1942.00 2120.00 2441.00 9479.00</code></pre>
<p>There are some odd values in store expense. The minimum value is -500 which is a wrong imputation which indicates that you should preprocess data before analyzing it. Checking those simple statistics will help you better understand your data. It then give you some idea how to preprocess and analyze them. How about using <code>lapply()</code> and <code>sapply()</code>?</p>
<p>Run the following code and compare the results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lapply</span>(sdat, function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))
<span class="kw">sapply</span>(sdat, function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)))
<span class="kw">sapply</span>(sdat, function(x) <span class="kw">sd</span>(<span class="kw">na.omit</span>(x)), <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</code></pre></div>
</div>
<div id="ddply-in-plyr-package" class="section level3">
<h3><span class="header-section-number">5.2.2</span> <code>ddply()</code> in <code>plyr</code> package</h3>
<p><em><code>dplyr</code> is a set of clean and consistent tools that implement the split-apply-combine pattern in R. This is an extremely common pattern in data analysis: you solve a complex problem by breaking it down into small pieces, doing something to each piece and then combining the results back together again. [From package description]</em></p>
<p>You may find the description sounds familiar. The package is sort of a wrapper of apply family. We will only introduce the main function <code>ddply()</code>. Because the package has next iteration which is <code>dplyr</code> package. We will introduce <code>dplyr</code> in more details. The reason we still want to spend some time on the older version is because they have similar idea and knowing the lineage will deeper your understanding of the whole family.</p>
<p>We will use the same data frame <code>sim.dat</code> to illustrate. Run the following command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plyr)</code></pre></div>
<pre><code>## -------------------------------------------------------------------------</code></pre>
<pre><code>## You have loaded plyr after dplyr - this is likely to cause problems.
## If you need functions from both plyr and dplyr, please load plyr first, then dplyr:
## library(plyr); library(dplyr)</code></pre>
<pre><code>## -------------------------------------------------------------------------</code></pre>
<pre><code>## 
## Attaching package: &#39;plyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:dplyr&#39;:
## 
##     arrange, count, desc, failwith, id, mutate, rename, summarise,
##     summarize</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(sim.dat,<span class="st">&quot;segment&quot;</span>,summarize, <span class="dt">Age=</span><span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(age)),<span class="dv">0</span>),
      <span class="dt">FemalePct=</span><span class="kw">round</span>(<span class="kw">mean</span>(gender==<span class="st">&quot;Female&quot;</span>),<span class="dv">2</span>),
      <span class="dt">HouseYes=</span><span class="kw">round</span>(<span class="kw">mean</span>(house==<span class="st">&quot;Yes&quot;</span>),<span class="dv">2</span>),
      <span class="dt">store_exp=</span><span class="kw">round</span>(<span class="kw">mean</span>(<span class="kw">na.omit</span>(store_exp),<span class="dt">trim=</span><span class="fl">0.1</span>),<span class="dv">0</span>),
      <span class="dt">online_exp=</span><span class="kw">round</span>(<span class="kw">mean</span>(online_exp),<span class="dv">0</span>),
      <span class="dt">store_trans=</span><span class="kw">round</span>(<span class="kw">mean</span>(store_trans),<span class="dv">1</span>),
      <span class="dt">online_trans=</span><span class="kw">round</span>(<span class="kw">mean</span>(online_trans),<span class="dv">1</span>))</code></pre></div>
<pre><code>##       segment Age FemalePct HouseYes store_exp online_exp store_trans
## 1 Conspicuous  42      0.32     0.86      4990       4898        10.9
## 2       Price  60      0.45     0.94       501        205         6.1
## 3     Quality  35      0.47     0.34       301       2013         2.9
## 4       Style  24      0.81     0.27       200       1962         3.0
##   online_trans
## 1         11.1
## 2          3.0
## 3         16.0
## 4         21.1</code></pre>
<p>Now, let’s peel the onion in order.</p>
<p>The first argument <code>sim.dat</code> is easy. It is the data you want to work on.</p>
<p>The second argument <code>&quot;segment&quot;</code> is the column you want to group by. It is a very standard marketing segmentation problem. The final segment is the result you want to get by designing survey, collecting and analyzing data. Here we assume those segments are known and we want to understand how each group of customer look like. It is a common task in segmentation: figuring out a profile. Here we only summarize data by one categorical variable but you can group by multiply variables using <code>ddply(sim.dat, c(&quot;segment&quot;,&quot;house&quot;), .)</code>. So the second argument tell the function we want to divide data by customer segment.</p>
<p>The third argument <code>summarize</code> tells R the kind of manipulation you want to do which is to summarize data. There are other choices for this argument such as <code>transform</code> (transform data within each group) and <code>subset</code>(subset data within each group).</p>
<p>Then the rest commands tell R the exact action. For example, <code>Age=round(mean(na.omit(age)),0)</code> tell R the following things:</p>
<ol style="list-style-type: decimal">
<li>Calculate the mean of column <code>age</code> ignoring missing value</li>
<li>Round the result to the specified number of decimal places</li>
<li>Store the result to a new variable named <code>Age</code></li>
</ol>
<p>The rest of the command above are similar. In the end we calculate the following for each segment:</p>
<ol style="list-style-type: decimal">
<li><code>Age</code>: average age for each segment</li>
<li><code>FemalePct</code>: percentage for each segment</li>
<li><code>HouseYes</code>: percentage of people who own a house</li>
<li><code>stroe_exp</code>: average expense in store</li>
<li><code>online_exp</code>: average expense online</li>
<li><code>store_trans</code>: average times of transactions in store</li>
<li><code>online_trans</code>: average times of online transactions</li>
</ol>
<p>There is a lot of information you can draw from those simple averages.</p>
<ul>
<li><p>Conspicuous: average age is about 40. Target for middle-age wealthy people. 1/3 of them are female and 2/3 are male. They may be good target for candy dad. They buy regardless the price. Almost all of them own house (0.86). It makes us wonder what is wrong with the rest 14%? They may live in Manhattan</p></li>
<li><p>Price: They are older people, average age 60. Nearly all of them own a house(0.94). They are less likely to purchase online (store_trans=6 while online_trans=3). This is the only group that is less likely to purchase online.</p></li>
<li><p>Quality: The average age is 35. They are not way different with Conspicuous in terms of age. But they spend much less. The percentages of male and female are similar. They prefer online shopping. More than half of them don’t own a house (0.66).</p></li>
<li><p>Style: They are young people with average age 24. Majority of them are female (0.81). Most of them don’t own a house (0.73). They are very likely to be digital natives and definitely prefer online shopping.</p></li>
</ul>
<p>You may notice that Style group purchase more frequently online (online_trans=21) but the expense (online_exp=1962) is not higher. This makes us wondering what is the average expense each time so you have a better idea about the price range the group fall in.</p>
<p>The analytical process is aggregated instead of independent steps. What you learn before will help you decide what to do next. Sometimes you also need to go backward to fix something in the previous steps. For example, you may need to check those negative expense value.</p>
<p>We continue to use <code>ddply()</code> to calculate the two statistics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(sim.dat,<span class="st">&quot;segment&quot;</span>,summarize,<span class="dt">avg_online=</span><span class="kw">round</span>(<span class="kw">sum</span>(online_exp)/<span class="kw">sum</span>(online_trans),<span class="dv">2</span>),
      <span class="dt">avg_store=</span><span class="kw">round</span>(<span class="kw">sum</span>(store_exp)/<span class="kw">sum</span>(store_trans),<span class="dv">2</span>))</code></pre></div>
<pre><code>##       segment avg_online avg_store
## 1 Conspicuous     442.27    479.25
## 2       Price      69.28     81.30
## 3     Quality     126.05    105.12
## 4       Style      92.83    121.07</code></pre>
<p>Price group has the lowest averaged one time purchasing price. The Conspicuous group will pay the highest price. When we build profile in real life, we will need to look at the survey results too. Those simple data manipulations can provide you lots of information already. As mentioned before, other than “<code>summarize</code>” there are other functions such as “<code>transform</code>” and “<code>subset</code>”.</p>
<p>For simplicity, I draw 11 random samples and 3 variables (<code>age</code>, <code>store_exp</code> and <code>segment</code>) from the original data according to the different segments. We will explain stratified sampling later. Here we just do it without explanation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(caret)</code></pre></div>
<pre><code>## Loading required package: lattice</code></pre>
<pre><code>## Loading required package: ggplot2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">2016</span>)
trainIndex&lt;-<span class="kw">createDataPartition</span>(sim.dat$segment,<span class="dt">p=</span><span class="fl">0.01</span>,<span class="dt">list=</span>F,<span class="dt">times=</span><span class="dv">1</span>)
examp&lt;-sim.dat[trainIndex,<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>,<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;segment&quot;</span>)]</code></pre></div>
<p>Now data frame <code>examp</code> only has 11 rows and 3 columns. Let’s look at the function of <code>transform</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(examp,<span class="st">&quot;segment&quot;</span>,transform,<span class="dt">store_pct=</span><span class="kw">round</span>(store_exp/<span class="kw">sum</span>(store_exp),<span class="dv">2</span>))</code></pre></div>
<pre><code>##    age store_exp     segment store_pct
## 1   42 6319.0718 Conspicuous      0.55
## 2   42 5106.4816 Conspicuous      0.45
## 3   55  595.2520       Price      0.42
## 4   64  399.3550       Price      0.28
## 5   64  426.6653       Price      0.30
## 6   39  362.4795     Quality      0.58
## 7   35  260.5065     Quality      0.42
## 8   23  205.6099       Style      0.25
## 9   24  212.3040       Style      0.26
## 10  24  202.1017       Style      0.25
## 11  28  200.1906       Style      0.24</code></pre>
<p>What “<code>transform</code>” does is to transform data within the specified group (segment) and append the result as a new column.</p>
<p>Next let’s look at the function of “<code>subset</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ddply</span>(examp,<span class="st">&quot;segment&quot;</span>,subset,store_exp&gt;<span class="kw">median</span>(store_exp))</code></pre></div>
<pre><code>##   age store_exp     segment
## 1  42 6319.0718 Conspicuous
## 2  55  595.2520       Price
## 3  39  362.4795     Quality
## 4  23  205.6099       Style
## 5  24  212.3040       Style</code></pre>
<p>You get all rows with <code>store_exp</code> greater than its group median.</p>
</div>
<div id="dplyr-package" class="section level3">
<h3><span class="header-section-number">5.2.3</span> <code>dplyr</code> package</h3>
<p><code>dplyr</code> provides a flexible grammar of data manipulation focusing on tools for working with data frames (hence the <code>d</code> in the name). It is faster and more friendly:</p>
<ul>
<li>It identifies the most important data manipulations and make they easy to use from R</li>
<li>It performs faster for in-memory data by writing key pieces in C++ using <code>Rcpp</code></li>
<li>The interface is the same for data frame, data table or database</li>
</ul>
<p>I will illustrate the following functions in order:</p>
<ol style="list-style-type: decimal">
<li>Display</li>
<li>Subset</li>
<li>Summarize</li>
<li>Create new variable</li>
<li>Merge</li>
</ol>
<p><strong>Display</strong></p>
<ul>
<li><code>tbl_df()</code>: Convert the data to <code>tibble</code> which offers better checking and printing capabilities than traditional data frames. It will adjust output width according to fit the current window.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="kw">tbl_df</span>(sim.dat)</code></pre></div>
<ul>
<li><code>glimpse()</code>: This is like a transposed version of <code>tbl_df()</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glimpse</span>(sim.dat)</code></pre></div>
<p><strong>Subset</strong></p>
<p>Get rows with <code>income</code> more than 300000:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)
<span class="kw">filter</span>(sim.dat, income &gt;<span class="dv">300000</span>) %&gt;%
<span class="st">  </span><span class="kw">tbl_df</span>()</code></pre></div>
<p>Here we meet a new operator <code>%&gt;%</code>. It is called “Pipe operator” which pipes a value forward into an expression or function call. What you get in the left operation will be the first argument or the only argument in the right operation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x %&gt;%<span class="st"> </span><span class="kw">f</span>(y) =<span class="st"> </span><span class="kw">f</span>(x, y)
y %&gt;%<span class="st"> </span><span class="kw">f</span>(x, ., z) =<span class="st"> </span><span class="kw">f</span>(x, y, z )</code></pre></div>
<p>It is an operator from <code>magrittr</code> which can be really beneficial. Look at the following code. Can you tell me what it does?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ave_exp &lt;-<span class="st"> </span><span class="kw">filter</span>( 
  <span class="kw">summarise</span>(
    <span class="kw">group_by</span>( 
      <span class="kw">filter</span>(
        sim.dat, 
        !<span class="kw">is.na</span>(income)
      ), 
      segment
    ), 
    <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
    <span class="dt">n =</span> <span class="kw">n</span>()
  ), 
  n &gt;<span class="st"> </span><span class="dv">200</span>
) </code></pre></div>
<p>Now look at the identical code using “<code>%&gt;%</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">avg_exp &lt;-<span class="st"> </span>sim.dat %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">filter</span>(!<span class="kw">is.na</span>(income)) %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">group_by</span>(segment) %&gt;%<span class="st"> </span>
<span class="st"> </span><span class="kw">summarise</span>( 
   <span class="dt">ave_online_exp =</span> <span class="kw">mean</span>(online_exp), 
   <span class="dt">n =</span> <span class="kw">n</span>() ) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n &gt;<span class="st"> </span><span class="dv">200</span>)</code></pre></div>
<p>Isn’t it much more straight forward now? Let’s read it:</p>
<ol style="list-style-type: decimal">
<li>Delete observations from <code>sim.dat</code> with missing income values</li>
<li>Group the data from step 1 by variable <code>segment</code></li>
<li>Calculate mean of online expense for each segment and save the result as a new variable named <code>ave_online_exp</code></li>
<li>Calculate the size of each segment and saved it as a new variable named <code>n</code></li>
<li>Get segments with size larger than 200</li>
</ol>
<p>You can use <code>distinct()</code> to delete duplicated rows. It is a generalization of <code>unique()</code> from vector to data frame.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr <span class="kw">distinct</span>(sim.dat)</code></pre></div>
<p><code>sample_frac()</code> will randomly select some rows with specified percentage. <code>sample_n()</code> can randomly select rows with specified number.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">sample_frac</span>(sim.dat, <span class="fl">0.5</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) 
dplyr::<span class="kw">sample_n</span>(sim.dat, <span class="dv">10</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>) </code></pre></div>
<p><code>slice()</code> will select rows by position:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">slice</span>(sim.dat, <span class="dv">10</span>:<span class="dv">15</span>) </code></pre></div>
<p>It is equivalent to <code>sim.dat[10:15,]</code>.</p>
<p><code>top_n()</code> will select the order top n entries:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">top_n</span>(sim.dat,<span class="dv">2</span>,income)</code></pre></div>
<p>If you want to select columns instead of rows, you can use <code>select()</code>. The following are some sample codes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># select by column name</span>
dplyr::<span class="kw">select</span>(sim.dat,income,age,store_exp)

<span class="co"># select columns whose name contains a character string</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">contains</span>(<span class="st">&quot;_&quot;</span>))

<span class="co"># select columns whose name ends with a character string</span>
<span class="co"># similar there is &quot;starts_with&quot;</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">ends_with</span>(<span class="st">&quot;e&quot;</span>))

<span class="co"># select columns Q1,Q2,Q3,Q4 and Q5</span>
<span class="kw">select</span>(sim.dat, <span class="kw">num_range</span>(<span class="st">&quot;Q&quot;</span>, <span class="dv">1</span>:<span class="dv">5</span>)) 

<span class="co"># select columns whose names are in a group of names</span>
dplyr::<span class="kw">select</span>(sim.dat, <span class="kw">one_of</span>(<span class="kw">c</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;income&quot;</span>)))

<span class="co"># select columns between age and online_exp</span>
dplyr::<span class="kw">select</span>(sim.dat, age:online_exp)

<span class="co"># select all columns except for age</span>
dplyr::<span class="kw">select</span>(sim.dat, -age)</code></pre></div>
<p><strong>Summarize</strong></p>
<p>The operations here are similar what we did before with <code>apply()</code> and <code>ddply()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">summarise</span>(sim.dat, <span class="dt">avg_online =</span> <span class="kw">mean</span>(online_trans)) </code></pre></div>
<pre><code>##   avg_online
## 1     13.546</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># apply function anyNA() to each column</span>
<span class="co"># you can also assign a function vector such as: c(&quot;anyNA&quot;,&quot;is.factor&quot;)</span>
dplyr::<span class="kw">summarise_each</span>(sim.dat, <span class="kw">funs_</span>(<span class="kw">c</span>(<span class="st">&quot;anyNA&quot;</span>)))</code></pre></div>
<pre><code>##     age gender income house store_exp online_exp store_trans online_trans
## 1 FALSE  FALSE   TRUE FALSE     FALSE      FALSE       FALSE        FALSE
##      Q1    Q2    Q3    Q4    Q5    Q6    Q7    Q8    Q9   Q10 segment
## 1 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE   FALSE</code></pre>
<p>You can use <code>group_by()</code> to indicate the variables you want to group by as before:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sim.dat %&gt;%<span class="st"> </span><span class="kw">group_by</span>(segment) %&gt;%<span class="st"> </span><span class="kw">summarise_each</span>(<span class="kw">funs_</span>(<span class="kw">c</span>(<span class="st">&quot;anyNA&quot;</span>)))</code></pre></div>
<p><strong>Create new variable</strong></p>
<p><code>mutate()</code> will compute and append one or more new columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">mutate</span>(sim.dat, <span class="dt">total_exp =</span> store_exp +<span class="st"> </span>online_exp)</code></pre></div>
<p>It will apply <strong>window function</strong> to the columns and return a column with the same length. It is a different type of function as before.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># min_rank=rank(ties.method = &quot;min&quot;)</span>
<span class="co"># mutate_each() means apply function to each column</span>
dplyr::<span class="kw">mutate_each</span>(sim.dat, <span class="kw">funs</span>(min_rank)) </code></pre></div>
<p>The other similar function is <code>transmute()</code>. The differece is that <code>transmute()</code> will delete the original columns and only keep the new ones.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr::<span class="kw">transmute</span>(sim.dat, <span class="dt">total_exp =</span> store_exp +<span class="st"> </span>online_exp) </code></pre></div>
<p><strong>Merge</strong></p>
<p>We create two baby data sets to show how the functions work.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(x&lt;-<span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="dt">ID=</span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>),<span class="dt">x1=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))))</code></pre></div>
<pre><code>##   ID x1
## 1  A  1
## 2  B  2
## 3  C  3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(y&lt;-<span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="dt">ID=</span><span class="kw">c</span>(<span class="st">&quot;B&quot;</span>,<span class="st">&quot;C&quot;</span>,<span class="st">&quot;D&quot;</span>),<span class="dt">y1=</span><span class="kw">c</span>(T,T,F))))</code></pre></div>
<pre><code>##   ID    y1
## 1  B  TRUE
## 2  C  TRUE
## 3  D FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># join to the left</span>
<span class="co"># keep all rows in x</span>
<span class="kw">left_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1   y1
## 1  A  1 &lt;NA&gt;
## 2  B  2 TRUE
## 3  C  3 TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get rows matched in both data sets</span>
<span class="kw">inner_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1   y1
## 1  B  2 TRUE
## 2  C  3 TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get rows in either data set</span>
<span class="kw">full_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID   x1    y1
## 1  A    1  &lt;NA&gt;
## 2  B    2  TRUE
## 3  C    3  TRUE
## 4  D &lt;NA&gt; FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># filter out rows in x that can be matched in y </span>
<span class="co"># it doesn&#39;t bring in any values from y </span>
<span class="kw">semi_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1
## 1  B  2
## 2  C  3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># the opposite of  semi_join()</span>
<span class="co"># it gets rows in x that cannot be matched in y</span>
<span class="co"># it doesn&#39;t bring in any values from y</span>
<span class="kw">anti_join</span>(x,y,<span class="dt">by=</span><span class="st">&quot;ID&quot;</span>)</code></pre></div>
<pre><code>##   ID x1
## 1  A  1</code></pre>
<p>There are other functions(<code>intersect()</code>, <code>union()</code> and <code>setdiff()</code>). Also the data frame version of <code>rbind</code> and <code>cbind</code> which are <code>bind_rows()</code> and <code>bind_col()</code>. We are not going to go through them all. You can try them yourself. If you understand the functions we introduced so far. It should be easy for you to figure out the rest.</p>
</div>
</div>
<div id="tidy-and-reshape-data" class="section level2">
<h2><span class="header-section-number">5.3</span> Tidy and Reshape Data</h2>
<p>“Tidy data” represent the information from a dataset as data frames where each row is an observation and each column contains the values of a variable (i.e. an attribute of what we are observing). Depending on the situation, the requirements on what to present as rows and columns may change. In order to make data easy to work with for the problem at hand, in practice, we often need to convert data between the “wide” and the “long” format. The process feels like playing with a dough.</p>
<p>There are two commonly used packages for this kind of manipulations: <code>tidyr</code> and <code>reshape2</code>. We will show how to tidy and reshape data using the two packages. By comparing the functions to show how they overlap and where they differ.</p>
<div id="reshape2-package" class="section level3">
<h3><span class="header-section-number">5.3.1</span> <code>reshape2</code> package</h3>
<p>It is a reboot of previous package <code>reshape</code>. Why? Here is what I got from Stack Overflow:</p>
<p><em>“<code>reshape2</code> let Hadley make a rebooted reshape that was way, way faster, while avoiding busting up people’s dependencies and habits.”</em></p>
<p>Take a baby subset of our exemplary clothes consumers data to illustrate:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(sdat&lt;-sim.dat[<span class="dv">1</span>:<span class="dv">5</span>,<span class="dv">1</span>:<span class="dv">6</span>])</code></pre></div>
<pre><code>##   age gender   income house store_exp online_exp
## 1  57 Female 120963.4   Yes  529.1344   303.5125
## 2  63 Female 122008.1   Yes  478.0058   109.5297
## 3  59   Male 114202.3   Yes  490.8107   279.2496
## 4  60   Male 113616.3   Yes  347.8090   141.6698
## 5  51   Male 124252.6   Yes  379.6259   112.2372</code></pre>
<p>For the above data <code>sdat</code>, what if we want to have a variable indicating the purchasing channel (i.e. online or in-store) and another column with the corresponding expense amount? Assume we want to keep the rest of the columns the same. It is a task to change data from “wide” to “long”. There are two general ways to shape data:</p>
<ul>
<li>Use <code>melt()</code> to convert an object into a molten data frame, i.e. from wide to long</li>
<li>Use <code>dcast()</code> to cast a molten data frame into the shape you want, i.e. from long to wide</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(reshape2)</code></pre></div>
<pre><code>## 
## Attaching package: &#39;reshape2&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:data.table&#39;:
## 
##     dcast, melt</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(mdat &lt;-<span class="st"> </span><span class="kw">melt</span>(sdat, <span class="dt">measure.vars=</span><span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>),
              <span class="dt">variable.name =</span> <span class="st">&quot;Channel&quot;</span>,
              <span class="dt">value.name =</span> <span class="st">&quot;Expense&quot;</span>))</code></pre></div>
<pre><code>##    age gender   income house    Channel  Expense
## 1   57 Female 120963.4   Yes  store_exp 529.1344
## 2   63 Female 122008.1   Yes  store_exp 478.0058
## 3   59   Male 114202.3   Yes  store_exp 490.8107
## 4   60   Male 113616.3   Yes  store_exp 347.8090
## 5   51   Male 124252.6   Yes  store_exp 379.6259
## 6   57 Female 120963.4   Yes online_exp 303.5125
## 7   63 Female 122008.1   Yes online_exp 109.5297
## 8   59   Male 114202.3   Yes online_exp 279.2496
## 9   60   Male 113616.3   Yes online_exp 141.6698
## 10  51   Male 124252.6   Yes online_exp 112.2372</code></pre>
<p>You melted the data frame <code>sdat</code> by two variables: <code>store_exp</code> and <code>online_exp</code> (<code>measure.vars=c(&quot;store_exp&quot;,&quot;online_exp&quot;)</code>). The new variable name is <code>Channel</code> set by command <code>variable.name = &quot;Channel&quot;</code>. The value name is <code>Expense</code> set by command <code>value.name = &quot;Expense&quot;</code>.</p>
<p>You can run a regression to study the effect of purchasing channel:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Here we use all observations from sim.dat</span>
mdat&lt;-<span class="kw">melt</span>(sim.dat[,<span class="dv">1</span>:<span class="dv">6</span>], <span class="dt">measure.vars=</span><span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;online_exp&quot;</span>),
            <span class="dt">variable.name =</span> <span class="st">&quot;Channel&quot;</span>,
              <span class="dt">value.name =</span> <span class="st">&quot;Expense&quot;</span>)
fit&lt;-<span class="kw">lm</span>(Expense~gender+house+income+Channel+age,<span class="dt">data=</span>mdat)
<span class="kw">summary</span>(fit)</code></pre></div>
<pre><code>## 
## Call:
## lm(formula = Expense ~ gender + house + income + Channel + age, 
##     data = mdat)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
##  -4208   -821   -275    533  44353 
## 
## Coefficients:
##                     Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)       -9.132e+02  1.560e+02  -5.855 5.76e-09 ***
## genderMale         3.572e+02  1.028e+02   3.475 0.000524 ***
## houseYes          -5.687e+01  1.138e+02  -0.500 0.617275    
## income             2.834e-02  1.079e-03  26.268  &lt; 2e-16 ***
## Channelonline_exp  8.296e+02  9.772e+01   8.489  &lt; 2e-16 ***
## age               -2.793e+01  3.356e+00  -8.321  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1974 on 1626 degrees of freedom
##   (368 observations deleted due to missingness)
## Multiple R-squared:  0.348,  Adjusted R-squared:  0.346 
## F-statistic: 173.5 on 5 and 1626 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>You can <code>melt()</code> list, matrix, table too. The syntax is similar and we won’t go through every situation. Sometimes we want to convert the data from “long” to “wide”. For example, <strong>you want to compare the online and in store expense between male and female based on the house ownership. </strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dcast</span>(mdat, house +<span class="st"> </span>gender ~<span class="st"> </span>Channel, sum)</code></pre></div>
<pre><code>## Using Expense as value column: use value.var to override.</code></pre>
<pre><code>##   house gender store_exp online_exp
## 1    No Female  171102.2   583492.4
## 2    No   Male  133130.8   332499.9
## 3   Yes Female  355320.2   500856.9
## 4   Yes   Male  697297.3   703332.0</code></pre>
<p>In the above code, what is the left side of <code>~</code> are variables that you want to group by. The right side is the variable you want to spread as columns. It will use the column indicating value from <code>melt()</code> before. Here is “<code>Expense</code>” .</p>
</div>
<div id="tidyr-package" class="section level3">
<h3><span class="header-section-number">5.3.2</span> <code>tidyr</code> package</h3>
<p>The other package that will do similar manipulations is <code>tidyr</code>. Let’s get a subset to illustrate the usage.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="co"># practice functions we learnt before</span>
sdat&lt;-sim.dat[<span class="dv">1</span>:<span class="dv">5</span>,]%&gt;%
<span class="st">  </span>dplyr::<span class="kw">select</span>(age,gender,store_exp,store_trans)
sdat %&gt;%<span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<p><code>gather()</code> function in <code>tidyr</code> is analogous to <code>melt()</code> in <code>reshape2</code>. The following code will do the same thing as we did before using <code>melt()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyr)
msdat&lt;-tidyr::<span class="kw">gather</span>(sdat,<span class="st">&quot;variable&quot;</span>,<span class="st">&quot;value&quot;</span>,store_exp,store_trans)
msdat %&gt;%<span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<p>Or if we use the pipe operation, we can write the above code as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sdat%&gt;%<span class="kw">gather</span>(<span class="st">&quot;variable&quot;</span>,<span class="st">&quot;value&quot;</span>,store_exp,store_trans)</code></pre></div>
<p>It is identical with the following code using <code>melt()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">melt</span>(sdat, <span class="dt">measure.vars=</span><span class="kw">c</span>(<span class="st">&quot;store_exp&quot;</span>,<span class="st">&quot;store_trans&quot;</span>),
            <span class="dt">variable.name =</span> <span class="st">&quot;variable&quot;</span>,
              <span class="dt">value.name =</span> <span class="st">&quot;value&quot;</span>)</code></pre></div>
<p>The opposite operation to <code>gather()</code> is <code>spread()</code>. The previous one stacks columns and the latter one spread the columns.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msdat %&gt;%<span class="st"> </span><span class="kw">spread</span>(variable,value)</code></pre></div>
<pre><code>##   age gender store_exp store_trans
## 1  51   Male  379.6259           4
## 2  57 Female  529.1344           2
## 3  59   Male  490.8107           7
## 4  60   Male  347.8090          10
## 5  63 Female  478.0058           4</code></pre>
<p>Another pair of functions that do opposite manipulations are <code>separate()</code> and <code>unite()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sepdat&lt;-<span class="st"> </span>msdat %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(variable,<span class="kw">c</span>(<span class="st">&quot;Source&quot;</span>,<span class="st">&quot;Type&quot;</span>))
sepdat %&gt;%<span class="st"> </span><span class="kw">tbl_df</span>()</code></pre></div>
<p>You can see that the function separates the original column “<code>variable</code>” to two new columns “<code>Source</code>” and “<code>Type</code>”. You can use <code>sep=</code> to set the string or regular express to separate the column. By default, it is “<code>_</code>”.</p>
<p>The <code>unite()</code> function will do the opposite: combining two columns. It is like the generalization of <code>paste()</code> to data frame.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sepdat %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">unite</span>(<span class="st">&quot;variable&quot;</span>,Source,Type,<span class="dt">sep=</span><span class="st">&quot;_&quot;</span>)</code></pre></div>
<pre><code>##    age gender    variable    value
## 1   57 Female   store_exp 529.1344
## 2   63 Female   store_exp 478.0058
## 3   59   Male   store_exp 490.8107
## 4   60   Male   store_exp 347.8090
## 5   51   Male   store_exp 379.6259
## 6   57 Female store_trans   2.0000
## 7   63 Female store_trans   4.0000
## 8   59   Male store_trans   7.0000
## 9   60   Male store_trans  10.0000
## 10  51   Male store_trans   4.0000</code></pre>
<p>The reshaping manipulations may be the trickiest part. You have to practice a lot to get familiar with those functions. Unfortunately there is no short cut.</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="introduction-to-the-data.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="data-pre-processing.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/04-DataWrangling.Rmd",
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
